/**
 * Minified by jsDelivr using Terser v5.15.1.
 * Original file: /gh/diarmidmackenzie/instanced-mesh@0.7.0/src/instanced-mesh.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
AFRAME.registerComponent("instanced-mesh",{schema:{capacity:{type:"number",default:100},fcradius:{type:"number",default:0},fccenter:{type:"vec3"},positioning:{type:"string",default:"local"},debug:{type:"boolean",default:!1},layers:{type:"string",default:""},updateMode:{type:"string",default:"manual",oneOf:["auto","manual"]},decompose:{type:"boolean",default:!1},drainColor:{type:"boolean",default:!1}},init:function(){this.capacity=this.data.capacity,this.members=0,this.debug=this.data.debug,this.meshLoaded=!1,this.texturesLoaded=0,this.eventQueue=[],this.boundingSphere=new THREE.Sphere(new THREE.Vector3(0,0,0),0),this.position=new THREE.Vector3,this.quaternion=new THREE.Quaternion,this.scale=new THREE.Vector3,this.membersToRemove=[],this.membersToUpdate=new Set,this.orderedMembersList=[],this.listeners={memberAdded:this.memberAdded.bind(this),memberModified:this.memberModified.bind(this),memberRemoved:this.memberRemoved.bind(this)},this.attachEventListeners(),this.matrix=new THREE.Matrix4,this.inverseMatrix=new THREE.Matrix4,this.debugMatrix=new THREE.Matrix4,this.componentMatrix=new THREE.Matrix4,this.parentWorldMatrixInverse=this.el.object3D.parent.matrixWorld.clone(),this.parentWorldMatrixInverse.invert(),this.color=new THREE.Color,this.addOnBeforeRenderToScene()},attachEventListeners:function(){this.el.addEventListener("memberAdded",this.listeners.memberAdded,!1),this.el.addEventListener("memberModified",this.listeners.memberModified,!1),this.el.addEventListener("memberRemoved",this.listeners.memberRemoved,!1)},update:function(){switch(this.data.positioning){case"local":this.localPositioning=!0;break;case"world":this.localPositioning=!1;break;default:console.log(`Unexpected value for 'positioning' attribute: ${this.data.positioning}`),console.log('Defaulting to "local" positioning'),this.localPositioning=!0}this.autoMode="auto"===this.data.updateMode;var e=this.el.getObject3D("mesh");e?this.el.components.material&&this.el.components.material.shader&&this.el.components.material.shader.materialSrcs&&(this.countTexturesToLoad(),this.texturesToLoad!==this.texturesLoaded)?this.el.addEventListener("materialtextureloaded",(e=>{this.texturesLoaded++,this.texturesToLoad===this.texturesLoaded&&this.update.call(this,this.data)})):(e.count>0?(console.assert(e===this.instancedMeshes[0]),e.instanceMatrix.count<this.data.capacity&&this.increaseInstancedMeshCapacity()):(this.meshNodes=this.constructMeshNodes(e),this.instancedMeshes=[],this.componentMatrices=[],this.componentMaterialIndices=[],this.componentOriginalColors=[],this.meshNodes.forEach(((e,t)=>{var s=new THREE.InstancedMesh(e.geometry,e.material,this.data.capacity);this.instancedMeshes.push(s),this.componentMatrices.push(e.matrixWorld),this.componentMaterialIndices.push(e.materialIndex),this.componentOriginalColors.push(e.originalColor)})),this.instancedMeshes.forEach((e=>{this.el.object3D.add(e)})),this.originalMesh=e,this.el.emit("original-mesh-ready"),e.visible=!1,this.el.setObject3D("mesh",this.instancedMeshes[0])),this.updateFrustrumCulling(),this.updateLayers(),this.el.setObject3D("mesh",this.instancedMeshes[0]),this.meshLoaded=!0,this.processQueuedEvents()):this.el.addEventListener("model-loaded",(e=>{this.update.call(this,this.data)}))},countTexturesToLoad:function(){const e=this.el.components.material,t=e.shader;t.materialSrcs;this.texturesToLoad=Object.keys(t.materialSrcs).length,this.texturesToLoad+=t.ambientOcclusionTextureSrc?1:0,this.texturesToLoad+=t.displacementTextureSrc?1:0,this.texturesToLoad+=t.normalTextureSrc?1:0,this.texturesToLoad+=t.isLoadingEnvMap||e.material.envMap?1:0},increaseInstancedMeshCapacity:function(){newMeshes=[],this.meshNodes.forEach(((e,t)=>{const s=this.instancedMeshes[t];var i=new THREE.InstancedMesh(e.geometry,e.material,this.data.capacity);for(newMeshes.push(i),ii=0;ii<Math.min(s.count,this.data.capacity);ii++)s.getMatrixAt(ii,this.matrix),i.setMatrixAt(ii,this.matrix);if(s.instanceColor)for(ii=0;ii<Math.min(s.count,this.data.capacity);ii++)s.getColorAt(ii,this.color),i.setColorAt(ii,this.color);this.el.object3D.add(i),this.el.object3D.remove(s)})),this.instancedMeshes=newMeshes,this.el.setObject3D("mesh",this.instancedMeshes[0])},updateFrustrumCulling:function(){this.data.fcradius>0?(this.boundingSphere.center.copy(this.data.fccenter),this.boundingSphere.radius=this.data.fcradius,this.instancedMeshes.forEach((e=>{e.geometry.userData.instancedMeshPrivateGeometry===this||(e.geometry=e.geometry.clone(),e.geometry.userData.instancedMeshPrivateGeometry=this),e.geometry.boundingSphere=this.boundingSphere,e.frustumCulled=!0}))):this.instancedMeshes.forEach((e=>{e.frustumCulled=!1}))},updateLayers:function(){if(""!==this.data.layers){const e=this.data.layers.split(",").map(Number);this.instancedMeshes.forEach((e=>{e.layers.disableAll()}));for(let t of e)this.instancedMeshes.forEach((e=>{e.layers.enable(t)}))}},constructMeshNodes:function(e){meshNodes=[],e.updateMatrixWorld(),this.inverseMatrix.copy(e.matrixWorld),this.inverseMatrix.invert();const t=this.inverseMatrix;return e.traverse((e=>{let s;if("Mesh"==e.type)if(s=e.geometry,this.data.decompose&&s.groups&&s.groups.length>1){const i=new Set;s.groups.forEach((e=>{i.add(e.materialIndex)})),i.forEach((i=>{this.constructPartGeometries(s,i).forEach((s=>{const o=this.cloneMaterial(e.material,i);let r;this.data.drainColor?r=this.drainColor(o):(console.warn("Decomposing Instanced Mesh without draining color"),console.warn("If your intention is to re-color individual mesh members, you should"),console.warn("drain colors using drainColors: true, to allow individual mesh members to be re-colored correctly")),e.updateMatrixWorld();const n=e.matrixWorld.clone();n.premultiply(t),meshNodes.push({geometry:s,material:o,originalColor:r,materialIndex:i,matrixWorld:n})}))}))}else{const i=this.cloneMaterial(e.material);let o;this.data.drainColor&&(o=this.drainColor(i)),e.updateMatrixWorld();const r=e.matrixWorld.clone();r.premultiply(t),meshNodes.push({geometry:s,material:i,originalColor:o,materialIndex:meshNodes.length,matrixWorld:r})}})),meshNodes},cloneMaterial(e,t){let s;return Array.isArray(e)?void 0===t?(s=[],e.forEach((e=>s.push(e.clone())))):s=e.length>t?e[t].clone():e[0].clone():s=e.clone(),s},drainColor(e){let t;return Array.isArray(e)?(e.forEach((e=>{this.drainColor(e)})),console.warn("Draining colors from multi-material non-decomposed instanced mesh"),console.warn("Multiple colors can't be set at the member level unless the mesh is decomposed"),console.warn("To avoid color loss, either decompose the instanced mesh (decompose: true), or don't drain colors (drainColor: false)"),t=new THREE.Color("grey")):(t=e.color.clone(),e.color.set("white")),t},constructPartGeometries(e,t){const s=[];return e.groups.forEach((i=>{if(i.materialIndex===t){const t=e.clone();t.setDrawRange(i.start,i.count),s.push(t),t.clearGroups()}})),s},memberAdded:function(e){if(!this.meshLoaded)return void this.queueEvent(e);this.debug&&console.log(`Member ${e.detail.member.id} to be added`);const t=e.detail.member;var s;if(this.membersToRemove.length>0){const e=this.membersToRemove[0];s=this.orderedMembersList.findIndex((t=>t==e)),this.membersToRemove.splice(0,1),this.orderedMembersList[s]=t}else{if(this.members>this.capacity)return console.warn(`Member not added to mesh ${this.el.id}.  Exceeded configured capacity of ${this.capacity}`),void console.warn(`To fix, set 'capacity' property on instanced-mesh attribute on entity:${this.el.id} (default is 100)`);s=this.members,this.members++,this.orderedMembersList.push(t)}this.membersToUpdate.add(t),this.instancedMeshes.forEach((e=>{e.count=this.members,e.instanceMatrix.needsUpdate=!0,e.instanceColor&&(e.instanceColor.needsUpdate=!0)}))},updateMatricesFromMemberObject(e,t){const s=this.matrixFromMemberObject(e),i=this.debug&&!this.autoMode,o=this.componentMatrix;this.instancedMeshes.forEach(((r,n)=>{if(i){console.log(`Setting matrix for component index ${n}`),r.getMatrixAt(t,this.debugMatrix);var a=this.position;a.setFromMatrixPosition(this.debugMatrix),console.log(`Old position:${a.x} ${a.y} ${a.z}`),a.setFromMatrixPosition(e.matrix),console.log(`New position:${a.x} ${a.y} ${a.z}`)}o.multiplyMatrices(s,this.componentMatrices[n]),r.setMatrixAt(t,o);this.getColorForComponent(e,n,this.color)&&(r.setColorAt(t,this.color),r.instanceColor.needsUpdate=!0),r.instanceMatrix.needsUpdate=!0}))},getColorForComponent(e,t,s){let i=!0;const o=this.componentMaterialIndices[t];let r=e.el?.components["instanced-mesh-member"]?.data.colors;return r&&r.length>o?s.set(r[o]):this.componentOriginalColors[t]?s.copy(this.componentOriginalColors[t]):i=!1,i},matrixFromMemberObject:function(e){if(this.localPositioning)return e.matrix;{const t=this.matrix;return t.multiplyMatrices(this.parentWorldMatrixInverse,e.matrixWorld),t}},memberModified:function(e){if(!this.meshLoaded)return void this.queueEvent(e);const t=e.detail.member;this.membersToUpdate.add(t)},memberRemoved:function(e){this.debug&&console.log(`Member ${e.detail.member.id} to be removed`),this.meshLoaded?(this.membersToRemove.push(e.detail.member),this.debug&&console.log(`Member ${e.detail.member.id} queued up for removal`)):this.queueEvent(e)},queueEvent:function(e){this.eventQueue.push(e)},processQueuedEvents:function(){this.eventQueue.forEach((e=>{switch(e.type){case"memberAdded":this.memberAdded(e);break;case"memberModified":this.memberModified(e);break;case"memberRemoved":this.memberRemoved(e);break;default:console.log(`Unexpected Event Type: ${e.type}`)}this.eventQueue=[]}))},tick:function(e,t){if(this.membersToRemove.length>0){for(var s=0,i=0;i<this.members;i++){var o=i,r=i-s;this.membersToRemove.includes(this.orderedMembersList[r])&&(this.debug&&console.log(`Removing member ${this.orderedMembersList[r]} at position ${r}`),this.orderedMembersList.splice(r,1),s++),s>0&&o+1<this.members&&this.instancedMeshes.forEach((e=>{e.getMatrixAt(o+1,this.matrix),e.setMatrixAt(o-s+1,this.matrix),e.instanceColor&&(e.getColorAt(o+1,this.color),e.setColorAt(o-s+1,this.color))}))}this.members-=s,this.instancedMeshes.forEach((e=>{e.count=this.members,e.instanceMatrix.needsUpdate=!0,e.instanceColor&&(e.instanceColor.needsUpdate=!0)})),this.membersToRemove=[]}},prerender(){if(!this.autoMode&&0===this.membersToUpdate.size)return;const e=this.el.object3D.parent,t=this.parentWorldMatrixInverse;if(t.copy(e.matrixWorld),t.invert(),this.autoMode){const e=this.orderedMembersList,t=this.members;for(let s=0;s<t;s++){const t=e[s].object3D;t&&this.updateMatricesFromMemberObject(t,s)}}else this.membersToUpdate.forEach((e=>{const t=this.orderedMembersList.findIndex((t=>t===e));-1==t&&console.error(`Member ${e.id} not found for modification`),this.updateMatricesFromMemberObject(e.object3D,t)})),this.membersToUpdate.clear()},addOnBeforeRenderToScene(){const e=this.el.sceneEl.object3D;this.oldOnBeforeRender=e.onBeforeRender,e.onBeforeRender=this.onBeforeRender.bind(this)},onBeforeRender(e,t,s,i,o,r){this.oldOnBeforeRender&&this.oldOnBeforeRender(e,t,s,i,o,r),this.prerender()}}),AFRAME.registerComponent("instanced-mesh-member",{schema:{mesh:{type:"selector"},debug:{type:"boolean",default:!1},memberMesh:{type:"boolean",default:!1},colors:{type:"array"}},init:function(){this.index=-1,this.added=!1,this.debug=this.data.debug,this.listeners={object3DUpdated:this.object3DUpdated.bind(this)},this.attachEventListeners(),this.visible=this.el.object3D.visible,this.colors=this.data.colors},update:function(){if(this.visible?this.el.object3D.visible?this.added&&this.data.mesh.emit("memberModified",{member:this.el}):(this.debug&&console.log("Removed (v):"+this.el.id),this.data.mesh.emit("memberRemoved",{member:this.el}),this.visible=!1):this.el.object3D.visible&&(this.debug&&console.log("Added (v):"+this.el.id),this.data.mesh.emit("memberAdded",{member:this.el}),this.visible=!0,this.added=!0),this.data.memberMesh&&!this.el.getObject3D("mesh")){const t=this.data.mesh.components["instanced-mesh"].originalMesh,s=this.el;function e(e){const t=e.clone();t.visible=!1,s.setObject3D("mesh",t)}t?e(t):this.data.mesh.addEventListener("original-mesh-ready",(t=>{e(this.data.mesh.components["instanced-mesh"].originalMesh)}))}else!this.data.memberMesh&&this.el.getObject3D("mesh")&&this.el.removeObject3D("mesh")},play:function(){!this.added&&this.el.object3D.visible&&(this.debug&&console.log("Added:"+this.el.id),this.data.mesh.emit("memberAdded",{member:this.el}),this.added=!0)},attachEventListeners:function(){this.el.addEventListener("object3DUpdated",this.listeners.object3DUpdated,!1)},remove:function(){this.debug&&console.log("Removed:"+this.el.id),this.data.mesh.emit("memberRemoved",{member:this.el})},object3DUpdated:function(e){this.debug&&console.log("Updated:"+this.el.id),this.el.object3D.updateMatrix(),this.update()}});
//# sourceMappingURL=/sm/21c4d7371ac55eec89544d12e3b5b9fce9036f5cfb76033b3a303954485308bb.map