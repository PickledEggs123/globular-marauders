!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e||self).threePathfinding={},e.THREE)}(this,function(e,t){class r{static roundNumber(e,t){return e}static sample(e){return e[Math.floor(Math.random()*e.length)]}static distanceToSquared(e,t){var r=e.x-t.x,n=e.y-t.y,s=e.z-t.z;return r*r+n*n+s*s}static isPointInPoly(e,t){const r=[];for(let n=0;n<e.length;n++){const s=e[n],o=e[(n+1)%e.length],i=(new THREE.Vector3).crossVectors(s,o).clone().dot(t.clone());r.push(i)}return r.every(e=>e>=0)||r.every(e=>e<=0)}static isVectorInPolygon(e,t,r){var n=1e5,s=-1e5,o=[];return t.vertexIds.forEach(e=>{n=Math.min(r[e].length(),n),s=Math.max(r[e].length(),s),o.push(r[e])}),!!(e.length()<s+.5&&e.length()>n-.5&&this.isPointInPoly(o,e))}static triarea2(e,t,r){var n=t.x-e.x,s=t.y-e.y,o=t.z-e.z,i=r.x-e.x,c=r.y-e.y,h=r.z-e.z,a=(new THREE.Vector3).set(n,s,o).normalize(),l=(new THREE.Vector3).set(i,c,h).normalize(),u=a.clone().normalize(),p=e.clone().normalize(),d=(new THREE.Vector3).crossVectors(u,p),g=(new THREE.Matrix4).makeBasis(d,u,p).invert();a=a.applyMatrix4(g),l=l.applyMatrix4(g);let f=(s=a.y)*(h=l.z)+(o=a.z)*(i=l.x)+(n=a.x)*(c=l.y)-n*h-s*i-o*c;return isNaN(f)?0:(a.dot(l)<0&&(f+=Math.sign(f)),f)}static vequal(e,t){return this.distanceToSquared(e,t)<1e-5}static mergeVertices(e,r=1e-4){r=Math.max(r,Number.EPSILON);for(var n={},s=e.getIndex(),o=e.getAttribute("position"),i=s?s.count:o.count,c=0,h=[],a=[],l=Math.log10(1/r),u=Math.pow(10,l),p=0;p<i;p++){var d=s?s.getX(p):p,g="";g+=~~(o.getX(d)*u)+",",g+=~~(o.getY(d)*u)+",",(g+=~~(o.getZ(d)*u)+",")in n?h.push(n[g]):(a.push(o.getX(d)),a.push(o.getY(d)),a.push(o.getZ(d)),n[g]=c,h.push(c),c++)}const f=new t.BufferAttribute(new Float32Array(a),o.itemSize,o.normalized),v=new t.BufferGeometry;return v.setAttribute("position",f),v.setIndex(new t.BufferAttribute(new Uint32Array(h),1)),v}}class n{constructor(e){this.content=[],this.scoreFunction=e}push(e){this.content.push(e),this.sinkDown(this.content.length-1)}pop(){const e=this.content[0],t=this.content.pop();return this.content.length>0&&(this.content[0]=t,this.bubbleUp(0)),e}remove(e){const t=this.content.indexOf(e),r=this.content.pop();t!==this.content.length-1&&(this.content[t]=r,this.scoreFunction(r)<this.scoreFunction(e)?this.sinkDown(t):this.bubbleUp(t))}size(){return this.content.length}rescoreElement(e){this.sinkDown(this.content.indexOf(e))}sinkDown(e){const t=this.content[e];for(;e>0;){const r=(e+1>>1)-1,n=this.content[r];if(!(this.scoreFunction(t)<this.scoreFunction(n)))break;this.content[r]=t,this.content[e]=n,e=r}}bubbleUp(e){const t=this.content.length,r=this.content[e],n=this.scoreFunction(r);for(;;){const s=e+1<<1,o=s-1;let i,c=null;if(o<t&&(i=this.scoreFunction(this.content[o]),i<n&&(c=o)),s<t&&this.scoreFunction(this.content[s])<(null===c?n:i)&&(c=s),null===c)break;this.content[e]=this.content[c],this.content[c]=r,e=c}}}class s{static init(e){for(let t=0;t<e.length;t++){const r=e[t];r.f=0,r.g=0,r.h=0,r.cost=1,r.visited=!1,r.closed=!1,r.parent=null}}static cleanUp(e){for(let t=0;t<e.length;t++){const r=e[t];delete r.f,delete r.g,delete r.h,delete r.cost,delete r.visited,delete r.closed,delete r.parent}}static heap(){return new n(function(e){return e.f})}static search(e,t,r,n){this.init(e);const s=this.heap();for(s.push(t);s.size()>0;){const t=s.pop();if(t===r){let e=t;const r=[];for(;e.parent;)r.push(e),e=e.parent;return this.cleanUp(r),r.reverse()}t.closed=!0;const o=this.neighbours(e,t);for(let e=0,i=o.length;e<i;e++){const i=o[e];if(i.closed)continue;const c=t.g+i.cost,h=i.visited;if(!h||c<i.g){if(i.visited=!0,i.parent=t,!i.centroid||!r.centroid)throw new Error("Unexpected state");i.h=i.h||this.heuristic(i,r.centroid,t.centroid,n),i.g=c,i.f=i.g+i.h,h?s.rescoreElement(i):s.push(i)}}}return[]}static heuristic(e,t,n,s){const o=e.centroid.clone(),i=(new THREE.Quaternion).setFromUnitVectors(o.clone().normalize(),new THREE.Vector3(0,0,1)),c=e.vertexIds.map(e=>s[e].clone());o.applyQuaternion(i),c.forEach(e=>e.applyQuaternion(i)),t=t.clone().applyQuaternion(i),n=n.clone().applyQuaternion(i);const h=c.map((e,t,r)=>[e,r[(t+1)%r.length]]),a=new THREE.Line3(n,t),l=h.map(([e,r])=>{const n=new THREE.Line3(e,r),s=n.closestPointToPointParameter(t.clone(),!1),o=a.closestPointToPointParameter(n.getCenter(new THREE.Vector3),!1);return s>=0&&s<=1&&o>=0&&o<=1}).some(e=>e);return Math.sqrt(r.distanceToSquared(e.centroid,t))+(l?0:1e3)}static neighbours(e,t){const r=[];for(let n=0;n<t.neighbours.length;n++)r.push(e[t.neighbours[n]]);return r}}class o{static buildZone(e,n){const s=this._buildNavigationMesh(e,n),o={};s.vertices.forEach(e=>{e.x=r.roundNumber(e.x,2),e.y=r.roundNumber(e.y,2),e.z=r.roundNumber(e.z,2)}),o.vertices=s.vertices;const i=this._buildPolygonGroups(s);return o.groups=new Array(i.length),i.forEach((e,n)=>{const s=new Map;e.forEach((e,t)=>{s.set(e,t)});const i=new Array(e.length);e.forEach((e,n)=>{const c=[];e.neighbours.forEach(e=>c.push(s.get(e)));const h=[];e.neighbours.forEach(t=>h.push(this._getSharedVerticesInOrder(e,t)));const a=new t.Vector3(0,0,0);a.add(o.vertices[e.vertexIds[0]]),a.add(o.vertices[e.vertexIds[1]]),a.add(o.vertices[e.vertexIds[2]]),a.divideScalar(3),a.x=r.roundNumber(a.x,2),a.y=r.roundNumber(a.y,2),a.z=r.roundNumber(a.z,2),i[n]={id:n,neighbours:c,vertexIds:e.vertexIds,centroid:a,portals:h}}),o.groups[n]=i}),o}static _buildNavigationMesh(e,t){return e=r.mergeVertices(e,t),this._buildPolygonsFromGeometry(e)}static _spreadGroupId(e){let t=new Set([e]);for(;t.size>0;){const r=t;t=new Set,r.forEach(r=>{r.group=e.group,r.neighbours.forEach(e=>{void 0===e.group&&t.add(e)})})}}static _buildPolygonGroups(e){const t=[];return e.polygons.forEach(e=>{void 0!==e.group?t[e.group].push(e):(e.group=t.length,this._spreadGroupId(e),t.push([e]))}),t}static _buildPolygonNeighbours(e,t){const r=new Set,n=t[e.vertexIds[1]],s=t[e.vertexIds[2]];return t[e.vertexIds[0]].forEach(t=>{t!==e&&(n.includes(t)||s.includes(t))&&r.add(t)}),n.forEach(t=>{t!==e&&s.includes(t)&&r.add(t)}),r}static _buildPolygonsFromGeometry(e){const r=[],n=[],s=e.attributes.position,o=e.index,i=[];for(let e=0;e<s.count;e++)n.push((new t.Vector3).fromBufferAttribute(s,e)),i[e]=[];for(let t=0;t<e.index.count;t+=3){const e=o.getX(t),n=o.getX(t+1),s=o.getX(t+2),c={vertexIds:[e,n,s],neighbours:null};r.push(c),i[e].push(c),i[n].push(c),i[s].push(c)}return r.forEach(e=>{e.neighbours=this._buildPolygonNeighbours(e,i)}),{polygons:r,vertices:n}}static _getSharedVerticesInOrder(e,t){const r=e.vertexIds,n=r[0],s=r[1],o=r[2],i=t.vertexIds,c=i.includes(n),h=i.includes(s),a=i.includes(o);return c&&h&&a?Array.from(r):c&&h?[n,s]:h&&a?[s,o]:c&&a?[o,n]:(console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."),[])}}class i{constructor(){this.portals=[]}push(e,t){void 0===t&&(t=e),this.portals.push({left:e,right:t})}stringPull(){const e=this.portals,t=[];let n,s,o,i=0,c=0,h=0;n=e[0].left,s=e[0].left,o=e[0].right,t.push(n);for(let a=1;a<e.length;a++){const l=e[a].left,u=e[a].right;if(r.triarea2(n,o,u)<=0){if(!(r.vequal(n,o)||r.triarea2(n,s,u)>0)){t.push(s),n=s,i=c,s=n,o=n,c=i,h=i,a=i;continue}o=u,h=a}if(r.triarea2(n,s,l)>=0){if(!(r.vequal(n,s)||r.triarea2(n,o,l)<0)){t.push(o),n=o,i=h,s=n,o=n,c=i,h=i,a=i;continue}s=l,c=a}t.push([l,u])}0!==t.length&&r.vequal(t[t.length-1],e[e.length-1].left)||t.push(e[e.length-1].left);let a=t[0],l=t[t.length-1];for(let e=0;e<t.length;e++){const r=t[e];r instanceof Array?r.push(a):a=r}for(let e=t.length-1;e>=0;e--){const r=t[e];r instanceof Array?r.push(l):l=r}for(let e=0;e<t.length;e++){const r=t[e];if(r instanceof Array){const[n,s,o,i]=r,c=n,h=o,a=s.clone().sub(n.clone()),l=i.clone().sub(o.clone()),u=(new THREE.Vector3).crossVectors(a,l),p=(new THREE.Vector3).crossVectors(l.clone(),u.clone()),d=h.clone().sub(c.clone()).dot(p),g=a.dot(p);if(Math.abs(g)<.001||o.distanceTo(i)<.01)t.splice(e,1,null);else{const r=c.clone().add(a.clone().multiplyScalar(d/g));t.splice(e,1,r)}}}return this.path=t.filter(e=>!!e).reduce((e,t)=>r.vequal(e[e.length-1],t)?e:[...e,t],[t[0]]),t}}class c{constructor(){this.zones={}}static createZone(e,t=1e-4){return o.buildZone(e,t)}setZoneData(e,t){this.zones[e]=t}getRandomNode(e,n,s,o){if(!this.zones[e])return new t.Vector3;s=s||null,o=o||0;const i=[];return this.zones[e].groups[n].forEach(e=>{s&&o?r.distanceToSquared(s,e.centroid)<o*o&&i.push(e.centroid):i.push(e.centroid)}),r.sample(i)||new t.Vector3}getClosestNode(e,t,n,s=!1){const o=this.zones[t].vertices;let i=null,c=Infinity;return this.zones[t].groups[n].forEach(t=>{const n=r.distanceToSquared(t.centroid,e);n<c&&(!s||r.isVectorInPolygon(e,t,o))&&(i=t,c=n)}),i}findPath(e,r,n,o){const c=this.zones[n].groups[o],h=this.zones[n].vertices,a=this.getClosestNode(e,n,o,!0),l=this.getClosestNode(r,n,o,!0);if(!a||!l)return null;const u=s.search(c,a,l,h),p=function(e,t){for(var r=0;r<e.neighbours.length;r++)if(e.neighbours[r]===t.id)return e.portals[r]},d=new i;d.push(e);for(let e=0;e<u.length;e++){const t=u[e+1];if(t){const r=p(u[e],t);d.push(h[r[0]],h[r[1]])}}d.push(r),d.stringPull();const g=d.path.map(e=>new t.Vector3(e.x,e.y,e.z));return g.shift(),g}}c.prototype.getGroup=function(){const e=new t.Plane;return function(t,n,s=!1){if(!this.zones[t])return null;let o=null,i=Math.pow(150,2);const c=this.zones[t];for(let t=0;t<c.groups.length;t++){const h=c.groups[t];for(const a of h){if(s&&(e.setFromCoplanarPoints(c.vertices[a.vertexIds[0]],c.vertices[a.vertexIds[1]],c.vertices[a.vertexIds[2]]),Math.abs(e.distanceToPoint(n))<.01)&&r.isPointInPoly([c.vertices[a.vertexIds[0]],c.vertices[a.vertexIds[1]],c.vertices[a.vertexIds[2]]],n))return t;const h=r.distanceToSquared(a.centroid,n);h<i&&(o=t,i=h)}}return o}}(),c.prototype.clampStep=function(){const e=new t.Vector3,r=new t.Plane,n=new t.Triangle,s=new t.Vector3;let o,i,c=new t.Vector3;return function(t,h,a,l,u,p){const d=this.zones[l].vertices,g=this.zones[l].groups[u],f=[a],v={};v[a.id]=0,o=void 0,c.set(0,0,0),i=Infinity,r.setFromCoplanarPoints(d[a.vertexIds[0]],d[a.vertexIds[1]],d[a.vertexIds[2]]),r.projectPoint(h,e),s.copy(e);for(let t=f.pop();t;t=f.pop()){n.set(d[t.vertexIds[0]],d[t.vertexIds[1]],d[t.vertexIds[2]]),n.closestPointToPoint(s,e),e.distanceToSquared(s)<i&&(o=t,c.copy(e),i=e.distanceToSquared(s));const r=v[t.id];if(!(r>2))for(let e=0;e<t.neighbours.length;e++){const n=g[t.neighbours[e]];n.id in v||(f.push(n),v[n.id]=r+1)}}return p.copy(c),o}}(),e.Pathfinding=c,e.PathfindingHelper=class extends t.Object3D{constructor(){super(),this._playerMarker=new t.Mesh(new t.SphereGeometry(.25,32,32),new t.MeshBasicMaterial({color:15631215})),this._targetMarker=new t.Mesh(new t.BoxGeometry(.3,.3,.3),new t.MeshBasicMaterial({color:14469912})),this._nodeMarker=new t.Mesh(new t.BoxGeometry(.1,.8,.1),new t.MeshBasicMaterial({color:4417387})),this._stepMarker=new t.Mesh(new t.BoxGeometry(.1,1,.1),new t.MeshBasicMaterial({color:14472114})),this._pathMarker=new t.Object3D,this._pathLineMaterial=new t.LineBasicMaterial({color:41903,linewidth:2}),this._pathPointMaterial=new t.MeshBasicMaterial({color:41903}),this._pathPointGeometry=new t.SphereGeometry(.08),this._markers=[this._playerMarker,this._targetMarker,this._nodeMarker,this._stepMarker,this._pathMarker],this._markers.forEach(e=>{e.visible=!1,this.add(e)})}setPath(e){for(;this._pathMarker.children.length;)this._pathMarker.children[0].visible=!1,this._pathMarker.remove(this._pathMarker.children[0]);e=[this._playerMarker.position].concat(e);const r=new t.BufferGeometry;r.setAttribute("position",new t.BufferAttribute(new Float32Array(3*e.length),3));for(let t=0;t<e.length;t++)r.attributes.position.setXYZ(t,e[t].x,e[t].y+.2,e[t].z);this._pathMarker.add(new t.Line(r,this._pathLineMaterial));for(let r=0;r<e.length-1;r++){const n=new t.Mesh(this._pathPointGeometry,this._pathPointMaterial);n.position.copy(e[r]),n.position.y+=.2,this._pathMarker.add(n)}return this._pathMarker.visible=!0,this}setPlayerPosition(e){return this._playerMarker.position.copy(e),this._playerMarker.visible=!0,this}setTargetPosition(e){return this._targetMarker.position.copy(e),this._targetMarker.visible=!0,this}setNodePosition(e){return this._nodeMarker.position.copy(e),this._nodeMarker.visible=!0,this}setStepPosition(e){return this._stepMarker.position.copy(e),this._stepMarker.visible=!0,this}reset(){for(;this._pathMarker.children.length;)this._pathMarker.children[0].visible=!1,this._pathMarker.remove(this._pathMarker.children[0]);return this._markers.forEach(e=>{e.visible=!1}),this}}});
//# sourceMappingURL=three-pathfinding.umd.js.map
