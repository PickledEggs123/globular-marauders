!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e||self).threePathfinding={},e.THREE)}(this,function(e,t){class n{static roundNumber(e,t){return e}static sample(e){return e[Math.floor(Math.random()*e.length)]}static distanceToSquared(e,t){var n=e.x-t.x,r=e.y-t.y,s=e.z-t.z;return n*n+r*r+s*s}static isPointInPoly(e,t){const n=[];for(let r=0;r<e.length;r++){const s=e[r],o=e[(r+1)%e.length],i=(new THREE.Vector3).crossVectors(s,o).clone().dot(t.clone());n.push(i)}return n.every(e=>e>=0)||n.every(e=>e<=0)}static isVectorInPolygon(e,t,n){var r=1e5,s=-1e5,o=[];return t.vertexIds.forEach(e=>{r=Math.min(n[e].length(),r),s=Math.max(n[e].length(),s),o.push(n[e])}),!!(e.length()<s+.5&&e.length()>r-.5&&this.isPointInPoly(o,e))}static triarea2(e,t,n){var r=t.x-e.x,s=t.y-e.y,o=t.z-e.z,i=n.x-e.x,c=n.y-e.y,h=n.z-e.z,a=(new THREE.Vector3).set(r,s,o).normalize(),l=(new THREE.Vector3).set(i,c,h).normalize(),u=a.clone().normalize(),d=e.clone().normalize(),p=(new THREE.Vector3).crossVectors(u,d),g=(new THREE.Matrix4).makeBasis(p,u,d).invert();a=a.applyMatrix4(g),l=l.applyMatrix4(g);let f=(s=a.y)*(h=l.z)+(o=a.z)*(i=l.x)+(r=a.x)*(c=l.y)-r*h-s*i-o*c;return isNaN(f)?0:(a.dot(l)<0&&(f+=Math.sign(f)),f)}static vequal(e,t){return this.distanceToSquared(e,t)<1e-5}static mergeVertices(e,n=1e-4){n=Math.max(n,Number.EPSILON);for(var r={},s=e.getIndex(),o=e.getAttribute("position"),i=s?s.count:o.count,c=0,h=[],a=[],l=Math.log10(1/n),u=Math.pow(10,l),d=0;d<i;d++){var p=s?s.getX(d):d,g="";g+=~~(o.getX(p)*u)+",",g+=~~(o.getY(p)*u)+",",(g+=~~(o.getZ(p)*u)+",")in r?h.push(r[g]):(a.push(o.getX(p)),a.push(o.getY(p)),a.push(o.getZ(p)),r[g]=c,h.push(c),c++)}const f=new t.BufferAttribute(new Float32Array(a),o.itemSize,o.normalized),v=new t.BufferGeometry;return v.setAttribute("position",f),v.setIndex(new t.BufferAttribute(new Uint32Array(h),1)),v}}class r{constructor(e){this.content=[],this.scoreFunction=e}push(e){this.content.push(e),this.sinkDown(this.content.length-1)}pop(){const e=this.content[0],t=this.content.pop();return this.content.length>0&&(this.content[0]=t,this.bubbleUp(0)),e}remove(e){const t=this.content.indexOf(e),n=this.content.pop();t!==this.content.length-1&&(this.content[t]=n,this.scoreFunction(n)<this.scoreFunction(e)?this.sinkDown(t):this.bubbleUp(t))}size(){return this.content.length}rescoreElement(e){this.sinkDown(this.content.indexOf(e))}sinkDown(e){const t=this.content[e];for(;e>0;){const n=(e+1>>1)-1,r=this.content[n];if(!(this.scoreFunction(t)<this.scoreFunction(r)))break;this.content[n]=t,this.content[e]=r,e=n}}bubbleUp(e){const t=this.content.length,n=this.content[e],r=this.scoreFunction(n);for(;;){const s=e+1<<1,o=s-1;let i,c=null;if(o<t&&(i=this.scoreFunction(this.content[o]),i<r&&(c=o)),s<t&&this.scoreFunction(this.content[s])<(null===c?r:i)&&(c=s),null===c)break;this.content[e]=this.content[c],this.content[c]=n,e=c}}}class s{static init(e){for(let t=0;t<e.length;t++){const n=e[t];n.f=0,n.g=0,n.h=0,n.cost=1,n.visited=!1,n.closed=!1,n.parent=null}}static cleanUp(e){for(let t=0;t<e.length;t++){const n=e[t];delete n.f,delete n.g,delete n.h,delete n.cost,delete n.visited,delete n.closed,delete n.parent}}static heap(){return new r(function(e){return e.f})}static search(e,t,n,r){this.init(e);const s=this.heap();for(s.push(t);s.size()>0;){const t=s.pop();if(t===n){let e=t;const n=[];for(;e.parent;)n.push(e),e=e.parent;return this.cleanUp(n),n.reverse()}t.closed=!0;const o=this.neighbours(e,t);for(let e=0,i=o.length;e<i;e++){const i=o[e];if(i.closed)continue;const c=t.g+i.cost,h=i.visited;if(!h||c<i.g){if(i.visited=!0,i.parent=t,!i.centroid||!n.centroid)throw new Error("Unexpected state");i.h=i.h||this.heuristic(i,n.centroid,t.centroid,r),i.g=c,i.f=i.g+i.h,h?s.rescoreElement(i):s.push(i)}}}return[]}static heuristic(e,t,r,s){e.centroid.clone().sub(t.clone()),r.clone().sub(t.clone());const o=e.vertexIds.map(e=>s[e].clone()).map((e,t,n)=>[e,n[(t+1)%n.length]]),i=r.clone().normalize().cross(t.clone().normalize()),c=o.map(([e,t])=>{const n=e.clone().normalize().cross(t.clone().normalize()).clone().cross(i.clone()),r=n.distanceTo(e)<n.clone().negate().distanceTo(e)?n.clone():n.clone().negate(),s=e.clone().normalize(),o=t.clone().normalize();return(new THREE.Quaternion).setFromUnitVectors(s,r).multiply((new THREE.Quaternion).setFromUnitVectors(r,o)).angleTo((new THREE.Quaternion).setFromUnitVectors(s,o))<1e-4}).some(e=>e);return Math.sqrt(n.distanceToSquared(e.centroid,t))+(c?0:1e3)}static neighbours(e,t){const n=[];for(let r=0;r<t.neighbours.length;r++)n.push(e[t.neighbours[r]]);return n}}class o{static buildZone(e,r){const s=this._buildNavigationMesh(e,r),o={};s.vertices.forEach(e=>{e.x=n.roundNumber(e.x,2),e.y=n.roundNumber(e.y,2),e.z=n.roundNumber(e.z,2)}),o.vertices=s.vertices;const i=this._buildPolygonGroups(s);return o.groups=new Array(i.length),i.forEach((e,r)=>{const s=new Map;e.forEach((e,t)=>{s.set(e,t)});const i=new Array(e.length);e.forEach((e,r)=>{const c=[];e.neighbours.forEach(e=>c.push(s.get(e)));const h=[];e.neighbours.forEach(t=>h.push(this._getSharedVerticesInOrder(e,t)));const a=new t.Vector3(0,0,0);a.add(o.vertices[e.vertexIds[0]]),a.add(o.vertices[e.vertexIds[1]]),a.add(o.vertices[e.vertexIds[2]]),a.divideScalar(3),a.x=n.roundNumber(a.x,2),a.y=n.roundNumber(a.y,2),a.z=n.roundNumber(a.z,2),i[r]={id:r,neighbours:c,vertexIds:e.vertexIds,centroid:a,portals:h}}),o.groups[r]=i}),o}static _buildNavigationMesh(e,t){return e=n.mergeVertices(e,t),this._buildPolygonsFromGeometry(e)}static _spreadGroupId(e){let t=new Set([e]);for(;t.size>0;){const n=t;t=new Set,n.forEach(n=>{n.group=e.group,n.neighbours.forEach(e=>{void 0===e.group&&t.add(e)})})}}static _buildPolygonGroups(e){const t=[];return e.polygons.forEach(e=>{void 0!==e.group?t[e.group].push(e):(e.group=t.length,this._spreadGroupId(e),t.push([e]))}),t}static _buildPolygonNeighbours(e,t){const n=new Set,r=t[e.vertexIds[1]],s=t[e.vertexIds[2]];return t[e.vertexIds[0]].forEach(t=>{t!==e&&(r.includes(t)||s.includes(t))&&n.add(t)}),r.forEach(t=>{t!==e&&s.includes(t)&&n.add(t)}),n}static _buildPolygonsFromGeometry(e){const n=[],r=[],s=e.attributes.position,o=e.index,i=[];for(let e=0;e<s.count;e++)r.push((new t.Vector3).fromBufferAttribute(s,e)),i[e]=[];for(let t=0;t<e.index.count;t+=3){const e=o.getX(t),r=o.getX(t+1),s=o.getX(t+2),c={vertexIds:[e,r,s],neighbours:null};n.push(c),i[e].push(c),i[r].push(c),i[s].push(c)}return n.forEach(e=>{e.neighbours=this._buildPolygonNeighbours(e,i)}),{polygons:n,vertices:r}}static _getSharedVerticesInOrder(e,t){const n=e.vertexIds,r=n[0],s=n[1],o=n[2],i=t.vertexIds,c=i.includes(r),h=i.includes(s),a=i.includes(o);return c&&h&&a?Array.from(n):c&&h?[r,s]:h&&a?[s,o]:c&&a?[o,r]:(console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."),[])}}class i{constructor(){this.portals=[]}push(e,t){void 0===t&&(t=e),this.portals.push({left:e,right:t})}stringPull(){const e=this.portals,t=[];let r,s,o,i=0,c=0,h=0;r=e[0].left,s=e[0].left,o=e[0].right,t.push(r);for(let a=1;a<e.length;a++){const l=e[a].left,u=e[a].right;if(n.triarea2(r,o,u)<=0){if(!(n.vequal(r,o)||n.triarea2(r,s,u)>0)){t.push(s),r=s,i=c,s=r,o=r,c=i,h=i,a=i;continue}o=u,h=a}if(n.triarea2(r,s,l)>=0){if(!(n.vequal(r,s)||n.triarea2(r,o,l)<0)){t.push(o),r=o,i=h,s=r,o=r,c=i,h=i,a=i;continue}s=l,c=a}t.push([l,u])}0!==t.length&&n.vequal(t[t.length-1],e[e.length-1].left)||t.push(e[e.length-1].left);let a=t[0],l=t[t.length-1];for(let e=0;e<t.length;e++){const n=t[e];n instanceof Array?n.push(a):a=n}for(let e=t.length-1;e>=0;e--){const n=t[e];n instanceof Array?n.push(l):l=n}for(let e=0;e<t.length;e++){const n=t[e];if(n instanceof Array){const[r,s,o,i]=n,c=r,h=o,a=s.clone().sub(r.clone()),l=i.clone().sub(o.clone()),u=(new THREE.Vector3).crossVectors(a,l),d=(new THREE.Vector3).crossVectors(l.clone(),u.clone()),p=h.clone().sub(c.clone()).dot(d),g=a.dot(d);if(Math.abs(g)<.001||o.distanceTo(i)<.01)t.splice(e,1,null);else{const n=c.clone().add(a.clone().multiplyScalar(p/g));t.splice(e,1,n)}}}return this.path=t.filter(e=>!!e).reduce((e,t)=>n.vequal(e[e.length-1],t)?e:[...e,t],[t[0]]),t}}class c{constructor(){this.zones={}}static createZone(e,t=1e-4){return o.buildZone(e,t)}setZoneData(e,t){this.zones[e]=t}getRandomNode(e,r,s,o){if(!this.zones[e])return new t.Vector3;s=s||null,o=o||0;const i=[];return this.zones[e].groups[r].forEach(e=>{s&&o?n.distanceToSquared(s,e.centroid)<o*o&&i.push(e.centroid):i.push(e.centroid)}),n.sample(i)||new t.Vector3}getClosestNode(e,t,r,s=!1){const o=this.zones[t].vertices;let i=null,c=Infinity;return this.zones[t].groups[r].forEach(t=>{const r=n.distanceToSquared(t.centroid,e);r<c&&(!s||n.isVectorInPolygon(e,t,o))&&(i=t,c=r)}),i}findPath(e,n,r,o){const c=this.zones[r].groups[o],h=this.zones[r].vertices,a=this.getClosestNode(e,r,o,!0),l=this.getClosestNode(n,r,o,!0);if(!a||!l)return null;const u=s.search(c,a,l,h),d=function(e,t){for(var n=0;n<e.neighbours.length;n++)if(e.neighbours[n]===t.id)return e.portals[n]},p=new i;p.push(e);for(let e=0;e<u.length;e++){const t=u[e+1];if(t){const n=d(u[e],t);p.push(h[n[0]],h[n[1]])}}p.push(n),p.stringPull();const g=p.path.map(e=>new t.Vector3(e.x,e.y,e.z));return g.shift(),g}}c.prototype.getGroup=function(){const e=new t.Plane;return function(t,r,s=!1){if(!this.zones[t])return null;let o=null,i=Math.pow(150,2);const c=this.zones[t];for(let t=0;t<c.groups.length;t++){const h=c.groups[t];for(const a of h){if(s&&(e.setFromCoplanarPoints(c.vertices[a.vertexIds[0]],c.vertices[a.vertexIds[1]],c.vertices[a.vertexIds[2]]),Math.abs(e.distanceToPoint(r))<.01)&&n.isPointInPoly([c.vertices[a.vertexIds[0]],c.vertices[a.vertexIds[1]],c.vertices[a.vertexIds[2]]],r))return t;const h=n.distanceToSquared(a.centroid,r);h<i&&(o=t,i=h)}}return o}}(),c.prototype.clampStep=function(){const e=new t.Vector3,n=new t.Plane,r=new t.Triangle,s=new t.Vector3;let o,i,c=new t.Vector3;return function(t,h,a,l,u,d){const p=this.zones[l].vertices,g=this.zones[l].groups[u],f=[a],v={};v[a.id]=0,o=void 0,c.set(0,0,0),i=Infinity,n.setFromCoplanarPoints(p[a.vertexIds[0]],p[a.vertexIds[1]],p[a.vertexIds[2]]),n.projectPoint(h,e),s.copy(e);for(let t=f.pop();t;t=f.pop()){r.set(p[t.vertexIds[0]],p[t.vertexIds[1]],p[t.vertexIds[2]]),r.closestPointToPoint(s,e),e.distanceToSquared(s)<i&&(o=t,c.copy(e),i=e.distanceToSquared(s));const n=v[t.id];if(!(n>2))for(let e=0;e<t.neighbours.length;e++){const r=g[t.neighbours[e]];r.id in v||(f.push(r),v[r.id]=n+1)}}return d.copy(c),o}}(),e.Pathfinding=c,e.PathfindingHelper=class extends t.Object3D{constructor(){super(),this._playerMarker=new t.Mesh(new t.SphereGeometry(.25,32,32),new t.MeshBasicMaterial({color:15631215})),this._targetMarker=new t.Mesh(new t.BoxGeometry(.3,.3,.3),new t.MeshBasicMaterial({color:14469912})),this._nodeMarker=new t.Mesh(new t.BoxGeometry(.1,.8,.1),new t.MeshBasicMaterial({color:4417387})),this._stepMarker=new t.Mesh(new t.BoxGeometry(.1,1,.1),new t.MeshBasicMaterial({color:14472114})),this._pathMarker=new t.Object3D,this._pathLineMaterial=new t.LineBasicMaterial({color:41903,linewidth:2}),this._pathPointMaterial=new t.MeshBasicMaterial({color:41903}),this._pathPointGeometry=new t.SphereGeometry(.08),this._markers=[this._playerMarker,this._targetMarker,this._nodeMarker,this._stepMarker,this._pathMarker],this._markers.forEach(e=>{e.visible=!1,this.add(e)})}setPath(e){for(;this._pathMarker.children.length;)this._pathMarker.children[0].visible=!1,this._pathMarker.remove(this._pathMarker.children[0]);e=[this._playerMarker.position].concat(e);const n=new t.BufferGeometry;n.setAttribute("position",new t.BufferAttribute(new Float32Array(3*e.length),3));for(let t=0;t<e.length;t++)n.attributes.position.setXYZ(t,e[t].x,e[t].y+.2,e[t].z);this._pathMarker.add(new t.Line(n,this._pathLineMaterial));for(let n=0;n<e.length-1;n++){const r=new t.Mesh(this._pathPointGeometry,this._pathPointMaterial);r.position.copy(e[n]),r.position.y+=.2,this._pathMarker.add(r)}return this._pathMarker.visible=!0,this}setPlayerPosition(e){return this._playerMarker.position.copy(e),this._playerMarker.visible=!0,this}setTargetPosition(e){return this._targetMarker.position.copy(e),this._targetMarker.visible=!0,this}setNodePosition(e){return this._nodeMarker.position.copy(e),this._nodeMarker.visible=!0,this}setStepPosition(e){return this._stepMarker.position.copy(e),this._stepMarker.visible=!0,this}reset(){for(;this._pathMarker.children.length;)this._pathMarker.children[0].visible=!1,this._pathMarker.remove(this._pathMarker.children[0]);return this._markers.forEach(e=>{e.visible=!1}),this}}});
//# sourceMappingURL=three-pathfinding.umd.js.map
