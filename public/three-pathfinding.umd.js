!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e||self).threePathfinding={},e.THREE)}(this,function(e,t){class r{static roundNumber(e,t){return e}static sample(e){return e[Math.floor(Math.random()*e.length)]}static distanceToSquared(e,t){var r=e.x-t.x,s=e.y-t.y,n=e.z-t.z;return r*r+s*s+n*n}static isPointInPoly(e,t){const r=[];for(let s=0;s<e.length;s++){const n=e[s],o=e[(s+1)%e.length],i=(new THREE.Vector3).crossVectors(n,o).clone().dot(t.clone());r.push(i)}return r.every(e=>e>=0)||r.every(e=>e<=0)}static isVectorInPolygon(e,t,r){var s=1e5,n=-1e5,o=[];return t.vertexIds.forEach(e=>{s=Math.min(r[e].length(),s),n=Math.max(r[e].length(),n),o.push(r[e])}),!!(e.length()<n+.5&&e.length()>s-.5&&this.isPointInPoly(o,e))}static triarea2(e,t,r){var s=t.x-e.x,n=t.y-e.y,o=t.z-e.z,i=r.x-e.x,c=r.y-e.y,h=r.z-e.z,a=(new THREE.Vector3).set(s,n,o).normalize(),l=(new THREE.Vector3).set(i,c,h).normalize(),u=a.clone().normalize(),d=e.clone().normalize(),p=(new THREE.Vector3).crossVectors(u,d),g=(new THREE.Matrix4).makeBasis(p,u,d).invert();a=a.applyMatrix4(g),l=l.applyMatrix4(g);let f=(n=a.y)*(h=l.z)+(o=a.z)*(i=l.x)+(s=a.x)*(c=l.y)-s*h-n*i-o*c;return isNaN(f)?0:(a.dot(l)<0&&(f+=Math.sign(f)),f)}static vequal(e,t){return this.distanceToSquared(e,t)<1e-5}static mergeVertices(e,r=1e-4){r=Math.max(r,Number.EPSILON);for(var s={},n=e.getIndex(),o=e.getAttribute("position"),i=n?n.count:o.count,c=0,h=[],a=[],l=Math.log10(1/r),u=Math.pow(10,l),d=0;d<i;d++){var p=n?n.getX(d):d,g="";g+=~~(o.getX(p)*u)+",",g+=~~(o.getY(p)*u)+",",(g+=~~(o.getZ(p)*u)+",")in s?h.push(s[g]):(a.push(o.getX(p)),a.push(o.getY(p)),a.push(o.getZ(p)),s[g]=c,h.push(c),c++)}const f=new t.BufferAttribute(new Float32Array(a),o.itemSize,o.normalized),v=new t.BufferGeometry;return v.setAttribute("position",f),v.setIndex(h),v}}class s{constructor(e){this.content=[],this.scoreFunction=e}push(e){this.content.push(e),this.sinkDown(this.content.length-1)}pop(){const e=this.content[0],t=this.content.pop();return this.content.length>0&&(this.content[0]=t,this.bubbleUp(0)),e}remove(e){const t=this.content.indexOf(e),r=this.content.pop();t!==this.content.length-1&&(this.content[t]=r,this.scoreFunction(r)<this.scoreFunction(e)?this.sinkDown(t):this.bubbleUp(t))}size(){return this.content.length}rescoreElement(e){this.sinkDown(this.content.indexOf(e))}sinkDown(e){const t=this.content[e];for(;e>0;){const r=(e+1>>1)-1,s=this.content[r];if(!(this.scoreFunction(t)<this.scoreFunction(s)))break;this.content[r]=t,this.content[e]=s,e=r}}bubbleUp(e){const t=this.content.length,r=this.content[e],s=this.scoreFunction(r);for(;;){const n=e+1<<1,o=n-1;let i,c=null;if(o<t&&(i=this.scoreFunction(this.content[o]),i<s&&(c=o)),n<t&&this.scoreFunction(this.content[n])<(null===c?s:i)&&(c=n),null===c)break;this.content[e]=this.content[c],this.content[c]=r,e=c}}}class n{static init(e){for(let t=0;t<e.length;t++){const r=e[t];r.f=0,r.g=0,r.h=0,r.cost=1,r.visited=!1,r.closed=!1,r.parent=null}}static cleanUp(e){for(let t=0;t<e.length;t++){const r=e[t];delete r.f,delete r.g,delete r.h,delete r.cost,delete r.visited,delete r.closed,delete r.parent}}static heap(){return new s(function(e){return e.f})}static search(e,t,r){this.init(e);const s=this.heap();for(s.push(t);s.size()>0;){const t=s.pop();if(t===r){let e=t;const r=[];for(;e.parent;)r.push(e),e=e.parent;return this.cleanUp(r),r.reverse()}t.closed=!0;const n=this.neighbours(e,t);for(let e=0,o=n.length;e<o;e++){const o=n[e];if(o.closed)continue;const i=t.g+o.cost,c=o.visited;if(!c||i<o.g){if(o.visited=!0,o.parent=t,!o.centroid||!r.centroid)throw new Error("Unexpected state");o.h=o.h||this.heuristic(o.centroid,r.centroid,t.centroid),o.g=i,o.f=o.g+o.h,c?s.rescoreElement(o):s.push(o)}}}return[]}static heuristic(e,t,s){const n=e.clone().sub(t.clone()),o=s.clone().sub(t.clone()),i=n.clone().normalize().dot(o.clone().normalize());return.1*Math.sqrt(r.distanceToSquared(e,t))+(1-i)}static neighbours(e,t){const r=[];for(let s=0;s<t.neighbours.length;s++)r.push(e[t.neighbours[s]]);return r}}class o{static buildZone(e,s){const n=this._buildNavigationMesh(e,s),o={};n.vertices.forEach(e=>{e.x=r.roundNumber(e.x,2),e.y=r.roundNumber(e.y,2),e.z=r.roundNumber(e.z,2)}),o.vertices=n.vertices;const i=this._buildPolygonGroups(n);return o.groups=new Array(i.length),i.forEach((e,s)=>{const n=new Map;e.forEach((e,t)=>{n.set(e,t)});const i=new Array(e.length);e.forEach((e,s)=>{const c=[];e.neighbours.forEach(e=>c.push(n.get(e)));const h=[];e.neighbours.forEach(t=>h.push(this._getSharedVerticesInOrder(e,t)));const a=new t.Vector3(0,0,0);a.add(o.vertices[e.vertexIds[0]]),a.add(o.vertices[e.vertexIds[1]]),a.add(o.vertices[e.vertexIds[2]]),a.divideScalar(3),a.x=r.roundNumber(a.x,2),a.y=r.roundNumber(a.y,2),a.z=r.roundNumber(a.z,2),i[s]={id:s,neighbours:c,vertexIds:e.vertexIds,centroid:a,portals:h}}),o.groups[s]=i}),o}static _buildNavigationMesh(e,t){return e=r.mergeVertices(e,t),this._buildPolygonsFromGeometry(e)}static _spreadGroupId(e){let t=new Set([e]);for(;t.size>0;){const r=t;t=new Set,r.forEach(r=>{r.group=e.group,r.neighbours.forEach(e=>{void 0===e.group&&t.add(e)})})}}static _buildPolygonGroups(e){const t=[];return e.polygons.forEach(e=>{void 0!==e.group?t[e.group].push(e):(e.group=t.length,this._spreadGroupId(e),t.push([e]))}),t}static _buildPolygonNeighbours(e,t){const r=new Set,s=t[e.vertexIds[1]],n=t[e.vertexIds[2]];return t[e.vertexIds[0]].forEach(t=>{t!==e&&(s.includes(t)||n.includes(t))&&r.add(t)}),s.forEach(t=>{t!==e&&n.includes(t)&&r.add(t)}),r}static _buildPolygonsFromGeometry(e){const r=[],s=[],n=e.attributes.position,o=e.index,i=[];for(let e=0;e<n.count;e++)s.push((new t.Vector3).fromBufferAttribute(n,e)),i[e]=[];for(let t=0;t<e.index.count;t+=3){const e=o.getX(t),s=o.getX(t+1),n=o.getX(t+2),c={vertexIds:[e,s,n],neighbours:null};r.push(c),i[e].push(c),i[s].push(c),i[n].push(c)}return r.forEach(e=>{e.neighbours=this._buildPolygonNeighbours(e,i)}),{polygons:r,vertices:s}}static _getSharedVerticesInOrder(e,t){const r=e.vertexIds,s=r[0],n=r[1],o=r[2],i=t.vertexIds,c=i.includes(s),h=i.includes(n),a=i.includes(o);return c&&h&&a?Array.from(r):c&&h?[s,n]:h&&a?[n,o]:c&&a?[o,s]:(console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."),[])}}class i{constructor(){this.portals=[]}push(e,t){void 0===t&&(t=e),this.portals.push({left:e,right:t})}stringPull(){const e=this.portals,t=[];let s,n,o,i=0,c=0,h=0;s=e[0].left,n=e[0].left,o=e[0].right,t.push(s);for(let a=1;a<e.length;a++){const l=e[a].left,u=e[a].right;if(r.triarea2(s,o,u)<=0){if(!(r.vequal(s,o)||r.triarea2(s,n,u)>0)){t.push(n),s=n,i=c,n=s,o=s,c=i,h=i,a=i;continue}o=u,h=a}if(r.triarea2(s,n,l)>=0){if(!(r.vequal(s,n)||r.triarea2(s,o,l)<0)){t.push(o),s=o,i=h,n=s,o=s,c=i,h=i,a=i;continue}n=l,c=a}t.push([l,u])}0!==t.length&&r.vequal(t[t.length-1],e[e.length-1].left)||t.push(e[e.length-1].left);let a=t[0],l=t[t.length-1];for(let e=0;e<t.length;e++){const r=t[e];r instanceof Array?r.push(a):a=r}for(let e=t.length-1;e>=0;e--){const r=t[e];r instanceof Array?r.push(l):l=r}for(let e=0;e<t.length;e++){const r=t[e];if(r instanceof Array){const[s,n,o,i]=r,c=s,h=o,a=n.clone().sub(s.clone()),l=i.clone().sub(o.clone()),u=(new THREE.Vector3).crossVectors(a,l),d=(new THREE.Vector3).crossVectors(l.clone(),u.clone()),p=h.clone().sub(c.clone()).dot(d),g=a.dot(d);if(Math.abs(g)<.001||o.distanceTo(i)<.01)t.splice(e,1,null);else{const r=c.clone().add(a.clone().multiplyScalar(p/g));t.splice(e,1,r)}}}return this.path=t.filter(e=>!!e).reduce((e,t)=>r.vequal(e[e.length-1],t)?e:[...e,t],[t[0]]),t}}class c{constructor(){this.zones={}}static createZone(e,t=1e-4){return o.buildZone(e,t)}setZoneData(e,t){this.zones[e]=t}getRandomNode(e,s,n,o){if(!this.zones[e])return new t.Vector3;n=n||null,o=o||0;const i=[];return this.zones[e].groups[s].forEach(e=>{n&&o?r.distanceToSquared(n,e.centroid)<o*o&&i.push(e.centroid):i.push(e.centroid)}),r.sample(i)||new t.Vector3}getClosestNode(e,t,s,n=!1){const o=this.zones[t].vertices;let i=null,c=Infinity;return this.zones[t].groups[s].forEach(t=>{const s=r.distanceToSquared(t.centroid,e);s<c&&(!n||r.isVectorInPolygon(e,t,o))&&(i=t,c=s)}),i}findPath(e,r,s,o){const c=this.zones[s].groups[o],h=this.zones[s].vertices,a=this.getClosestNode(e,s,o,!0),l=this.getClosestNode(r,s,o,!0);if(!a||!l)return null;const u=n.search(c,a,l),d=function(e,t){for(var r=0;r<e.neighbours.length;r++)if(e.neighbours[r]===t.id)return e.portals[r]},p=new i;p.push(e);for(let e=0;e<u.length;e++){const t=u[e+1];if(t){const r=d(u[e],t);p.push(h[r[0]],h[r[1]])}}p.push(r),p.stringPull();const g=p.path.map(e=>new t.Vector3(e.x,e.y,e.z));return g.shift(),g}}c.prototype.getGroup=function(){const e=new t.Plane;return function(t,s,n=!1){if(!this.zones[t])return null;let o=null,i=Math.pow(150,2);const c=this.zones[t];for(let t=0;t<c.groups.length;t++){const h=c.groups[t];for(const a of h){if(n&&(e.setFromCoplanarPoints(c.vertices[a.vertexIds[0]],c.vertices[a.vertexIds[1]],c.vertices[a.vertexIds[2]]),Math.abs(e.distanceToPoint(s))<.01)&&r.isPointInPoly([c.vertices[a.vertexIds[0]],c.vertices[a.vertexIds[1]],c.vertices[a.vertexIds[2]]],s))return t;const h=r.distanceToSquared(a.centroid,s);h<i&&(o=t,i=h)}}return o}}(),c.prototype.clampStep=function(){const e=new t.Vector3,r=new t.Plane,s=new t.Triangle,n=new t.Vector3;let o,i,c=new t.Vector3;return function(t,h,a,l,u,d){const p=this.zones[l].vertices,g=this.zones[l].groups[u],f=[a],v={};v[a.id]=0,o=void 0,c.set(0,0,0),i=Infinity,r.setFromCoplanarPoints(p[a.vertexIds[0]],p[a.vertexIds[1]],p[a.vertexIds[2]]),r.projectPoint(h,e),n.copy(e);for(let t=f.pop();t;t=f.pop()){s.set(p[t.vertexIds[0]],p[t.vertexIds[1]],p[t.vertexIds[2]]),s.closestPointToPoint(n,e),e.distanceToSquared(n)<i&&(o=t,c.copy(e),i=e.distanceToSquared(n));const r=v[t.id];if(!(r>2))for(let e=0;e<t.neighbours.length;e++){const s=g[t.neighbours[e]];s.id in v||(f.push(s),v[s.id]=r+1)}}return d.copy(c),o}}(),e.Pathfinding=c,e.PathfindingHelper=class extends t.Object3D{constructor(){super(),this._playerMarker=new t.Mesh(new t.SphereGeometry(.25,32,32),new t.MeshBasicMaterial({color:15631215})),this._targetMarker=new t.Mesh(new t.BoxGeometry(.3,.3,.3),new t.MeshBasicMaterial({color:14469912})),this._nodeMarker=new t.Mesh(new t.BoxGeometry(.1,.8,.1),new t.MeshBasicMaterial({color:4417387})),this._stepMarker=new t.Mesh(new t.BoxGeometry(.1,1,.1),new t.MeshBasicMaterial({color:14472114})),this._pathMarker=new t.Object3D,this._pathLineMaterial=new t.LineBasicMaterial({color:41903,linewidth:2}),this._pathPointMaterial=new t.MeshBasicMaterial({color:41903}),this._pathPointGeometry=new t.SphereGeometry(.08),this._markers=[this._playerMarker,this._targetMarker,this._nodeMarker,this._stepMarker,this._pathMarker],this._markers.forEach(e=>{e.visible=!1,this.add(e)})}setPath(e){for(;this._pathMarker.children.length;)this._pathMarker.children[0].visible=!1,this._pathMarker.remove(this._pathMarker.children[0]);e=[this._playerMarker.position].concat(e);const r=new t.BufferGeometry;r.setAttribute("position",new t.BufferAttribute(new Float32Array(3*e.length),3));for(let t=0;t<e.length;t++)r.attributes.position.setXYZ(t,e[t].x,e[t].y+.2,e[t].z);this._pathMarker.add(new t.Line(r,this._pathLineMaterial));for(let r=0;r<e.length-1;r++){const s=new t.Mesh(this._pathPointGeometry,this._pathPointMaterial);s.position.copy(e[r]),s.position.y+=.2,this._pathMarker.add(s)}return this._pathMarker.visible=!0,this}setPlayerPosition(e){return this._playerMarker.position.copy(e),this._playerMarker.visible=!0,this}setTargetPosition(e){return this._targetMarker.position.copy(e),this._targetMarker.visible=!0,this}setNodePosition(e){return this._nodeMarker.position.copy(e),this._nodeMarker.visible=!0,this}setStepPosition(e){return this._stepMarker.position.copy(e),this._stepMarker.visible=!0,this}reset(){for(;this._pathMarker.children.length;)this._pathMarker.children[0].visible=!1,this._pathMarker.remove(this._pathMarker.children[0]);return this._markers.forEach(e=>{e.visible=!1}),this}}});
//# sourceMappingURL=three-pathfinding.umd.js.map
