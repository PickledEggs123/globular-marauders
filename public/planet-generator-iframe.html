<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Planet Generator</title>
    <script src="aframe-v1.5.0.js"></script>
    <script src="aframe-physics-system.js"></script>
    <script src="aframe-extras.min.js"></script>
    <script src="three-pathfinding.umd.js"></script>
    <script src="three-to-cannon.umd.js"></script>
    <script type="application/javascript">
        const PLANET_SIZE = 100;

        AFRAME.registerComponent('globe-lod', {
            schema: {
                default: "",
            },
            tick: function () {
                const object3D = this.el.object3D;
                // @ts-ignore
                const pos = object3D.getWorldPosition(new THREE.Vector3());

                const cameraEl = document.querySelector("#camera-rig");
                // @ts-ignore
                const cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());

                const distance = pos.distanceTo(cameraPos);

                const data = this.data.split("|");
                if (distance >= 20) {
                    this.el.setAttribute("gltf-model", data[2]);
                } else if (distance < 20) {
                    this.el.setAttribute("gltf-model", data[1]);
                } else if (distance < 10) {
                    this.el.setAttribute("gltf-model", data[0]);
                }
            }
        });

        AFRAME.registerComponent('globe-gravity', {
            schema: {},
            tick: function () {
                const object3D = this.el.object3D;
                // @ts-ignore
                const trueUpDistance = object3D.getWorldPosition(new THREE.Vector3());
                // @ts-ignore
                const trueUp = trueUpDistance.clone().normalize();
                // @ts-ignore
                const currentUp = new THREE.Vector3(0, 1, 0).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                // @ts-ignore
                const currentForward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));;
                // @ts-ignore
                const currentRight = new THREE.Vector3(1, 0, 0).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                const diffUp = trueUp.clone().sub(currentUp.clone());

                // apply gravity force
                // @ts-ignore
                const gravityForce = this.el.body.mass * 10;
                // @ts-ignore
                this.el.body.applyForce(new CANNON.Vec3(-trueUp.x, -trueUp.y, -trueUp.z).scale(gravityForce), new CANNON.Vec3(0, 0, 0));

                // apply drag
                // @ts-ignore
                this.el.body.applyForce(this.el.body.velocity.clone().scale(-25), new CANNON.Vec3(0, 0, 0));

                // apply sideways tilt force
                // @ts-ignore
                const sidewaysTilt = this.el.body.velocity.clone().scale(100).dot(currentRight.clone());
                const tiltForce = new CANNON.Vec3(currentRight.x, currentRight.y, currentRight.z).scale(sidewaysTilt);
                const tiltPoint = new CANNON.Vec3(currentUp.x, currentUp.y, currentUp.z);
                // @ts-ignore
                this.el.body.applyForce(tiltForce.clone(), tiltPoint.clone());
                // @ts-ignore
                this.el.body.applyForce(tiltForce.clone().scale(-1), tiltPoint.clone().scale(-1));

                // apply up right force
                // @ts-ignore
                const springForce = 300;
                const rotateForce = new CANNON.Vec3(diffUp.x, diffUp.y, diffUp.z).scale(springForce);
                const rotatePoint = new CANNON.Vec3(currentUp.x, currentUp.y, currentUp.z);
                // @ts-ignore
                const dragForce = this.el.body.angularVelocity.clone().cross(rotatePoint.clone()).scale(100);
                // @ts-ignore
                this.el.body.applyForce(rotateForce.clone().vsub(dragForce), rotatePoint.clone());
                // @ts-ignore
                this.el.body.applyForce(rotateForce.clone().vsub(dragForce).scale(-1), rotatePoint.clone().scale(-1));

                // apply horizontal drag
                const horizontalRotatePoint = new CANNON.Vec3(currentForward.x, currentForward.y, currentForward.z);
                // @ts-ignore
                const horizontalDragForce = this.el.body.angularVelocity.clone().cross(horizontalRotatePoint.clone()).scale(100);
                // @ts-ignore
                this.el.body.applyForce(horizontalDragForce.clone().scale(-1), horizontalRotatePoint.clone());
                // @ts-ignore
                this.el.body.applyForce(horizontalDragForce.clone(), horizontalRotatePoint.clone().scale(-1));

                if (trueUpDistance.length() < PLANET_SIZE + 1) {
                    const trueUpMagnitude = -(trueUpDistance.length() - PLANET_SIZE - 1);
                    const trueUpForce = new CANNON.Vec3(trueUp.x, trueUp.y, trueUp.z).scale(trueUpMagnitude * 1000);
                    // @ts-ignore
                    this.el.body.applyForce(trueUpForce, new CANNON.Vec3(0, 0, 0));
                }
            }
        });

        AFRAME.registerComponent('globe-trimesh', {
            schema: {},
            init: function () {
                this.el.addEventListener('model-loaded', () => {
                    const obj = this.el.getObject3D('mesh');
                    const result = threeToCannon.getShapeParameters(obj, { type: threeToCannon.ShapeType.MESH });
                    // @ts-ignore
                    const body = (this.el.components['static-body'].body);
                    body.shapes.splice(0, body.shapes.length);
                    body.shapeOffsets.splice(0, body.shapeOffsets.length)
                    body.shapeOrientations.splice(0, body.shapeOrientations.length)
                    if (result !== null) {
                        const {
                            offset,
                            orientation,
                            params: {
                                // @ts-ignore
                                vertices,
                                // @ts-ignore
                                indices,
                            },
                        } = result;
                        const shape = new CANNON.Trimesh(vertices, indices);
                        // @ts-ignore
                        this.el.components['static-body'].addShape(shape, offset, orientation);
                    }
                });
            }
        });

        AFRAME.registerComponent('look-at-box', {
            schema: {
                type: "string",
                default: "#box",
            },
            tick: function () {
                // get elements
                // @ts-ignore
                const box = Array.from(document.querySelectorAll(`${this.data}`)).map(el => el.object3D);
                // @ts-ignore
                const boxPos = Array.from(document.querySelectorAll(`${this.data}-position`)).map(el => el.object3D);
                if (!box || !boxPos) {
                    return;
                }

                // get position
                // @ts-ignore
                const boxWorldPos = new THREE.Vector3();
                // @ts-ignore
                box.forEach(b => boxWorldPos.add(b.getWorldPosition(new THREE.Vector3())));
                boxWorldPos.divideScalar(box.length);
                // @ts-ignore
                const boxPosWorldPos = new THREE.Vector3();
                // @ts-ignore
                boxPos.forEach(b => boxPosWorldPos.add(b.getWorldPosition(new THREE.Vector3())));
                boxPosWorldPos.divideScalar(boxPos.length);

                // get info
                // @ts-ignore
                const upVector = boxPosWorldPos.clone().sub(new THREE.Vector3(0, 0, 0)).normalize();
                const object3D = this.el.object3D;
                // @ts-ignore
                const objectWorldPos = object3D.getWorldPosition(new THREE.Vector3());
                // @ts-ignore
                const height = boxPosWorldPos.clone().sub(new THREE.Vector3(0, 0, 0)).length();

                // update info
                // @ts-ignore
                const quaternion = new THREE.Quaternion().setFromUnitVectors(objectWorldPos.clone().normalize(), boxPosWorldPos.clone().normalize());
                // @ts-ignore
                const slerp = new THREE.Quaternion().slerp(quaternion, 0.03);
                // @ts-ignore
                const finalPosition = objectWorldPos.clone().normalize().multiplyScalar(height + 5).applyQuaternion(slerp);

                // update camera
                object3D.position.set(finalPosition.x, finalPosition.y, finalPosition.z);
                const camera = this.el.sceneEl.camera;
                // @ts-ignore
                camera.up = upVector;
                camera.lookAt(boxWorldPos);
            }
        });

        const KEYCODE_TO_CODE = {
            '38': 'ArrowUp',
            '37': 'ArrowLeft',
            '40': 'ArrowDown',
            '39': 'ArrowRight',
            '87': 'KeyW',
            '65': 'KeyA',
            '83': 'KeyS',
            '68': 'KeyD'
        };
        // @ts-ignore
        const bind = AFRAME.utils.bind;
        // @ts-ignore
        const shouldCaptureKeyEvent = AFRAME.utils.shouldCaptureKeyEvent;
        const KEYS = [
            'KeyW', 'KeyA', 'KeyS', 'KeyD',
            'ArrowUp', 'ArrowLeft', 'ArrowRight', 'ArrowDown'
        ];

        AFRAME.registerComponent('globe-keyboard-controls', {
            schema: {
                acceleration: {default: 100},
                enabled: {default: true},
                fly: {default: false},
            },

            init: function () {
                // To keep track of the pressed keys.
                // @ts-ignore
                this.keys = {};
                // @ts-ignore
                this.velocity = new THREE.Vector3();
                // @ts-ignore
                this.rotation = new THREE.Vector3();

                // Bind methods and add event listeners.
                this.onBlur = bind(this.onBlur, this);
                this.onContextMenu = bind(this.onContextMenu, this);
                this.onFocus = bind(this.onFocus, this);
                this.onKeyDown = bind(this.onKeyDown, this);
                this.onKeyUp = bind(this.onKeyUp, this);
                this.onVisibilityChange = bind(this.onVisibilityChange, this);
                this.attachVisibilityEventListeners();
            },

            tick: function (time, delta) {
                var el = this.el;
                // @ts-ignore
                const body = this.el.body;

                // Update velocity.
                delta = delta / 1000;
                this.updateVelocity(delta);

                // Get movement vector and translate position.
                // @ts-ignore
                body.applyForce(this.getMovementVector(delta).clone(), new CANNON.Vec3(0, 0, 0));

                // @ts-ignore
                if (this.rotation.clone().y) {
                    // apply rotation force
                    // @ts-ignore
                    body.applyLocalForce(new CANNON.Vec3(this.rotation.clone().y, 0, 0), new CANNON.Vec3(0, 0, 1));
                    // @ts-ignore
                    body.applyLocalForce(new CANNON.Vec3(-this.rotation.clone().y, 0, 0), new CANNON.Vec3(0, 0, -1));
                }
            },

            remove: function () {
                this.removeKeyEventListeners();
                this.removeVisibilityEventListeners();
            },

            play: function () {
                this.attachKeyEventListeners();
            },

            pause: function () {
                // @ts-ignore
                this.keys = {};
                this.removeKeyEventListeners();
            },

            updateVelocity: function (delta) {
                var acceleration;
                var data = this.data;
                // @ts-ignore
                var keys = this.keys;
                // @ts-ignore
                var velocity = this.velocity;
                // @ts-ignore
                var rotation = this.rotation;

                if (!data.enabled) { return; }

                // Update velocity using keys pressed.
                acceleration = data.acceleration;
                velocity.set(0, 0, 0);
                rotation.set(0, 0, 0);
                if (keys.KeyA || keys.ArrowLeft) { rotation.y = acceleration; }
                if (keys.KeyD || keys.ArrowRight) { rotation.y = -acceleration; }
                if (keys.KeyW || keys.ArrowUp) { velocity.z = -acceleration; }
                if (keys.KeyS || keys.ArrowDown) { velocity.z = acceleration; }

                // @ts-ignore
                const bodyWorldVelocity = this.el.body.velocity.clone();
                // @ts-ignore
                const bodyWorldQuat = this.el.body.quaternion.clone().inverse();
                // @ts-ignore
                const bodyVelocity = new THREE.Vector3(bodyWorldVelocity.x, bodyWorldVelocity.y, bodyWorldVelocity.z).applyQuaternion(new THREE.Quaternion(bodyWorldQuat.x, bodyWorldQuat.y, bodyWorldQuat.z, bodyWorldQuat.w));
                // @ts-ignore
                velocity.sub(new THREE.Vector3(bodyVelocity.x, bodyVelocity.y, bodyVelocity.z).multiplyScalar(1));
            },

            getMovementVector: (function () {
                // @ts-ignore
                var directionVector = new THREE.Vector3(0, 0, 0);

                return function (delta) {
                    // @ts-ignore
                    var velocity = this.velocity;
                    // @ts-ignore
                    var rotation = this.el.object3D.getWorldQuaternion(new THREE.Quaternion());

                    // @ts-ignore
                    directionVector.copy(velocity);

                    // Transform direction relative to heading.
                    // @ts-ignore
                    directionVector.applyQuaternion(rotation);
                    return directionVector;
                };
            })(),

            attachVisibilityEventListeners: function () {
                window.oncontextmenu = this.onContextMenu;
                window.addEventListener('blur', this.onBlur);
                window.addEventListener('focus', this.onFocus);
                document.addEventListener('visibilitychange', this.onVisibilityChange);
            },

            removeVisibilityEventListeners: function () {
                window.removeEventListener('blur', this.onBlur);
                window.removeEventListener('focus', this.onFocus);
                document.removeEventListener('visibilitychange', this.onVisibilityChange);
            },

            attachKeyEventListeners: function () {
                window.addEventListener('keydown', this.onKeyDown);
                window.addEventListener('keyup', this.onKeyUp);
            },

            removeKeyEventListeners: function () {
                window.removeEventListener('keydown', this.onKeyDown);
                window.removeEventListener('keyup', this.onKeyUp);
            },

            onContextMenu: function () {
                // @ts-ignore
                var keys = Object.keys(this.keys);
                for (var i = 0; i < keys.length; i++) {
                    // @ts-ignore
                    delete this.keys[keys[i]];
                }
            },

            onBlur: function () {
                this.pause();
            },

            onFocus: function () {
                this.play();
            },

            onVisibilityChange: function () {
                if (document.hidden) {
                    this.onBlur();
                } else {
                    this.onFocus();
                }
            },

            onKeyDown: function (event) {
                var code;
                if (!shouldCaptureKeyEvent(event)) { return; }
                code = event.code || KEYCODE_TO_CODE[event.keyCode];
                // @ts-ignore
                if (KEYS.indexOf(code) !== -1) { this.keys[code] = true; }
            },

            onKeyUp: function (event) {
                var code;
                code = event.code || KEYCODE_TO_CODE[event.keyCode];
                // @ts-ignore
                delete this.keys[code];
            }
        });

        const pathfinder = new threePathfinding.Pathfinding();
        const oceanPathfinder = new threePathfinding.Pathfinding();
        const ZONE = 'level';

        /**
         * nav
         *
         * Pathfinding system, using PatrolJS.
         */
        AFRAME.registerSystem('globe-nav', {
            navMesh: null,
            agents: new Set(),
            init: function () {
                this.navMesh = null;
                this.agents = new Set();
            },

            /**
             * @param {THREE.Geometry} geometry
             */
            setNavMeshGeometry: function (geometry) {
                // @ts-ignore
                this.navMesh = new THREE.Mesh(geometry);
                pathfinder.setZoneData(ZONE, threePathfinding.Pathfinding.createZone(geometry));
                Array.from(this.agents).forEach((agent) => agent.updateNavLocation());
            },

            /**
             * @return {THREE.Mesh}
             */
            getNavMesh: function () {
                return this.navMesh;
            },

            /**
             * @param {NavAgent} ctrl
             */
            addAgent: function (ctrl) {
                this.agents.add(ctrl);
            },

            /**
             * @param {NavAgent} ctrl
             */
            removeAgent: function (ctrl) {
                this.agents.delete(ctrl);
            },

            /**
             * @param  {THREE.Vector3} start
             * @param  {THREE.Vector3} end
             * @param  {number} groupID
             * @return {Array<THREE.Vector3>}
             */
            getPath: function (start, end, groupID) {
                return this.navMesh
                    ? groupID === null ? [] : pathfinder.findPath(start, end, ZONE, groupID)
                    : null;
            },

            /**
             * @param {THREE.Vector3} position
             * @return {number}
             */
            getGroup: function (position) {
                return this.navMesh
                    ? pathfinder.getGroup(ZONE, position)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} position
             * @param  {number} groupID
             * @return {Node}
             */
            getNode: function (position, groupID) {
                return this.navMesh
                    ? pathfinder.getClosestNode(position, ZONE, groupID, true)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} start Starting position.
             * @param  {THREE.Vector3} end Desired ending position.
             * @param  {number} groupID
             * @param  {Node} node
             * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.
             * @return {Node} Current node, after step is taken.
             */
            clampStep: function (start, end, groupID, node, endTarget) {
                if (!this.navMesh) {
                    endTarget.copy(end);
                    return null;
                } else if (!node) {
                    endTarget.copy(end);
                    return this.getNode(end, groupID);
                }
                return pathfinder.clampStep(start, end, node, ZONE, groupID, endTarget);
            }
        });

        AFRAME.registerComponent('globe-nav-mesh', {
            schema: {
                nodeName: {type: 'string'}
            },
            hasLoadedNavMesh: false,
            nodeName: "",
            init: function () {
                this.system = this.el.sceneEl.systems['globe-nav'];
                this.hasLoadedNavMesh = false;
                this.nodeName = this.data.nodeName;
                this.el.addEventListener('object3dset', this.loadNavMesh.bind(this));
            },

            play: function () {
                if (!this.hasLoadedNavMesh) this.loadNavMesh();
            },

            loadNavMesh: function () {
                var self = this;
                const object = this.el.getObject3D('mesh');
                const scene = this.el.sceneEl.object3D;

                if (!object) return;

                let navMesh;
                object.traverse((node) => {
                    if (node.isMesh &&
                        (!self.nodeName || node.name === self.nodeName)) navMesh = node;
                });

                if (!navMesh) return;

                // @ts-ignore
                const navMeshGeometry = navMesh.geometry.clone();
                // @ts-ignore
                navMesh.updateWorldMatrix(true, false);
                // @ts-ignore
                navMeshGeometry.applyMatrix4(navMesh.matrixWorld);
                // @ts-ignore
                this.system.setNavMeshGeometry(navMeshGeometry);
                this.hasLoadedNavMesh = true;
            }
        });

        AFRAME.registerComponent('globe-nav-agent', {
            schema: {
                destination: {type: 'vec3'},
                active: {default: false},
                speed: {default: 2}
            },
            system: null,
            group: null,
            path: [],
            raycaster: null,
            init: function () {
                this.system = this.el.sceneEl.systems['globe-nav'];
                this.system.addAgent(this);
                this.group = null;
                this.path = [];
                // @ts-ignore
                this.raycaster = new THREE.Raycaster();
            },
            remove: function () {
                this.system.removeAgent(this);
            },
            update: function () {
                this.path.length = 0;
            },
            updateNavLocation: function () {
                this.group = null;
                this.path = [];
            },
            tick: (function () {
                // @ts-ignore
                const vDest = new THREE.Vector3();
                // @ts-ignore
                const vDelta = new THREE.Vector3();
                // @ts-ignore
                const vNext = new THREE.Vector3();

                return function (t, dt) {
                    const el = this.el;
                    const data = this.data;
                    const raycaster = this.raycaster;
                    const speed = data.speed * dt / 1000;

                    if (!data.active) return;

                    // Use PatrolJS pathfinding system to get shortest path to target.
                    if (!this.path.length) {
                        const position = this.el.object3D.position;
                        this.group = this.group || this.system.getGroup(position);
                        this.path = this.system.getPath(position, vDest.copy(data.destination), this.group) || [];
                        el.emit('navigation-start');
                    }

                    // If no path is found, exit.
                    if (!this.path.length) {
                        console.warn('[nav] Unable to find path to %o.', data.destination);
                        this.el.setAttribute("globe-nav-agent", "active: false;");
                        el.emit('navigation-end');
                        el.object3D.position.copy(vDest);
                        console.log(el.object3D.position);
                        this.group = null;
                        return;
                    }

                    // Current segment is a vector from current position to next waypoint.
                    const vCurrent = el.object3D.position;
                    const vWaypoint = this.path[0];
                    vDelta.subVectors(vWaypoint, vCurrent);

                    const distance = vDelta.length();
                    let gazeTarget;

                    if (distance < speed) {
                        // If <1 step from current waypoint, discard it and move toward next.
                        this.path.shift();

                        // After discarding the last waypoint, exit pathfinding.
                        if (!this.path.length) {
                            this.el.setAttribute("globe-nav-agent", "active: false;");
                            el.emit('navigation-end');
                            return;
                        }

                        vNext.copy(vCurrent);
                        gazeTarget = this.path[0];
                    } else {
                        // If still far away from next waypoint, find next position for
                        // the current frame.
                        vNext.copy(vDelta.setLength(speed)).add(vCurrent);
                        gazeTarget = vWaypoint;
                    }

                    // Look at the next waypoint.
                    // gazeTarget.y = vCurrent.y;
                    el.object3D.up = new THREE.Vector3(vCurrent.x, vCurrent.y, vCurrent.z).normalize();
                    el.object3D.lookAt(gazeTarget);

                    // Raycast against the nav mesh, to keep the agent moving along the
                    // ground, not traveling in a straight line from higher to lower waypoints.
                    raycaster.ray.origin.copy(vNext.clone().normalize().multiplyScalar(101.5));
                    raycaster.ray.direction = vNext.clone().normalize().negate();
                    const intersections = raycaster.intersectObject(this.system.getNavMesh());

                    if (!intersections.length) {
                        // Raycasting failed. Step toward the waypoint and hope for the best.
                        vCurrent.copy(vNext);
                    } else {
                        // Re-project next position onto nav mesh.
                        vDelta.subVectors(intersections[0].point, vCurrent);
                        vCurrent.add(vDelta.setLength(speed));
                    }

                };
            }())
        });

        /**
         * nav
         *
         * Pathfinding system, using PatrolJS.
         */
        AFRAME.registerSystem('globe-ocean-nav', {
            navMesh: null,
            agents: new Set(),
            init: function () {
                this.navMesh = null;
                this.agents = new Set();
            },

            /**
             * @param {THREE.Geometry} geometry
             */
            setNavMeshGeometry: function (geometry) {
                // @ts-ignore
                this.navMesh = new THREE.Mesh(geometry);
                oceanPathfinder.setZoneData(ZONE, threePathfinding.Pathfinding.createZone(geometry));
                Array.from(this.agents).forEach((agent) => agent.updateNavLocation());
            },

            /**
             * @return {THREE.Mesh}
             */
            getNavMesh: function () {
                return this.navMesh;
            },

            /**
             * @param {NavAgent} ctrl
             */
            addAgent: function (ctrl) {
                this.agents.add(ctrl);
            },

            /**
             * @param {NavAgent} ctrl
             */
            removeAgent: function (ctrl) {
                this.agents.delete(ctrl);
            },

            /**
             * @param  {THREE.Vector3} start
             * @param  {THREE.Vector3} end
             * @param  {number} groupID
             * @return {Array<THREE.Vector3>}
             */
            getPath: function (start, end, groupID) {
                return this.navMesh
                    ? groupID === null ? [] : oceanPathfinder.findPath(start, end, ZONE, groupID)
                    : null;
            },

            /**
             * @param {THREE.Vector3} position
             * @return {number}
             */
            getGroup: function (position) {
                return this.navMesh
                    ? oceanPathfinder.getGroup(ZONE, position)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} position
             * @param  {number} groupID
             * @return {Node}
             */
            getNode: function (position, groupID) {
                return this.navMesh
                    ? oceanPathfinder.getClosestNode(position, ZONE, groupID, true)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} start Starting position.
             * @param  {THREE.Vector3} end Desired ending position.
             * @param  {number} groupID
             * @param  {Node} node
             * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.
             * @return {Node} Current node, after step is taken.
             */
            clampStep: function (start, end, groupID, node, endTarget) {
                if (!this.navMesh) {
                    endTarget.copy(end);
                    return null;
                } else if (!node) {
                    endTarget.copy(end);
                    return this.getNode(end, groupID);
                }
                return oceanPathfinder.clampStep(start, end, node, ZONE, groupID, endTarget);
            }
        });

        AFRAME.registerComponent('globe-ocean-nav-mesh', {
            schema: {
                nodeName: {type: 'string'}
            },
            hasLoadedNavMesh: false,
            nodeName: "",
            init: function () {
                this.system = this.el.sceneEl.systems['globe-ocean-nav'];
                this.hasLoadedNavMesh = false;
                this.nodeName = this.data.nodeName;
                this.el.addEventListener('object3dset', this.loadNavMesh.bind(this));
            },

            play: function () {
                if (!this.hasLoadedNavMesh) this.loadNavMesh();
            },

            loadNavMesh: function () {
                var self = this;
                const object = this.el.getObject3D('mesh');
                const scene = this.el.sceneEl.object3D;

                if (!object) return;

                let navMesh;
                object.traverse((node) => {
                    if (node.isMesh &&
                        (!self.nodeName || node.name === self.nodeName)) navMesh = node;
                });

                if (!navMesh) return;

                // @ts-ignore
                const navMeshGeometry = navMesh.geometry.clone();
                // @ts-ignore
                navMesh.updateWorldMatrix(true, false);
                // @ts-ignore
                navMeshGeometry.applyMatrix4(navMesh.matrixWorld);
                // @ts-ignore
                this.system.setNavMeshGeometry(navMeshGeometry);
                this.hasLoadedNavMesh = true;
            }
        });

        AFRAME.registerComponent('globe-ocean-nav-agent', {
            schema: {
                destination: {type: 'vec3'},
                active: {default: false},
                speed: {default: 2}
            },
            system: null,
            group: null,
            path: [],
            raycaster: null,
            init: function () {
                this.system = this.el.sceneEl.systems['globe-ocean-nav'];
                this.system.addAgent(this);
                this.group = null;
                this.path = [];
                // @ts-ignore
                this.raycaster = new THREE.Raycaster();
            },
            remove: function () {
                this.system.removeAgent(this);
            },
            update: function () {
                this.path.length = 0;
            },
            updateNavLocation: function () {
                this.group = null;
                this.path = [];
            },
            tick: (function () {
                // @ts-ignore
                const vDest = new THREE.Vector3();
                // @ts-ignore
                const vDelta = new THREE.Vector3();
                // @ts-ignore
                const vNext = new THREE.Vector3();

                return function (t, dt) {
                    const el = this.el;
                    const data = this.data;
                    const raycaster = this.raycaster;
                    const speed = data.speed * dt / 1000;

                    if (!data.active) return;

                    // Use PatrolJS pathfinding system to get shortest path to target.
                    if (!this.path.length) {
                        const position = this.el.object3D.position;
                        this.group = this.group || this.system.getGroup(position);
                        this.path = this.system.getPath(position, vDest.copy(data.destination), this.group) || [];
                        el.emit('navigation-start');
                    }

                    // If no path is found, exit.
                    if (!this.path.length) {
                        console.warn('[nav] Unable to find path to %o.', data.destination);
                        this.el.setAttribute("globe-ocean-nav-agent", "active: false;");
                        el.emit('navigation-end');
                        el.object3D.position.copy(vDest);
                        console.log(el.object3D.position);
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyW"});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                        this.group = null;
                        return;
                    }

                    // Current segment is a vector from current position to next waypoint.
                    const vCurrent = new THREE.Vector3().copy(el.components['dynamic-body'].body.position);
                    const vWaypoint = this.path[0];
                    vDelta.subVectors(vWaypoint, vCurrent);

                    const distance = vDelta.length();
                    let gazeTarget;

                    if (distance < 4) {
                        // If <1 step from current waypoint, discard it and move toward next.
                        this.path.shift();

                        // After discarding the last waypoint, exit pathfinding.
                        if (!this.path.length) {
                            this.el.setAttribute("globe-ocean-nav-agent", "active: false;");
                            el.emit('navigation-end');
                            el.components['globe-keyboard-controls'].onKeyUp({code: "KeyW"});
                            el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                            el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                            return;
                        }

                        vNext.copy(vCurrent);
                        gazeTarget = this.path[0];
                    } else {
                        // If still far away from next waypoint, find next position for
                        // the current frame.
                        vNext.copy(vDelta.setLength(speed)).add(vCurrent);
                        gazeTarget = vWaypoint;
                    }

                    // Look at the next waypoint.
                    // gazeTarget.y = vCurrent.y;
                    // |  x  y  z |
                    // | ax ay az |
                    // | bx by bz |
                    const getDeterminant = () => {
                        const a = vCurrent.clone().normalize();
                        const v1 = new THREE.Vector3(0, 0, -1).applyQuaternion(new THREE.Quaternion().copy(el.components['dynamic-body'].body.quaternion));
                        const v2 = gazeTarget.clone().sub(vCurrent.clone()).normalize();

                        // make two vectors for determinant
                        let ax = v1.x;
                        let ay = v1.y;
                        let az = v1.z;
                        let bx = v2.x;
                        let by = v2.y;
                        let bz = v2.z;

                        // make basis matrix for sphere
                        let aVec = new THREE.Vector3().set(ax, ay, az);
                        let bVec = new THREE.Vector3().set(bx, by, az);
                        const basisY = a.clone().normalize();
                        const basisZ = aVec.clone().normalize();
                        const basisX = new THREE.Vector3().crossVectors(basisY, basisZ);
                        const basis = new THREE.Matrix4().makeBasis(basisX, basisY, basisZ).invert();

                        // apply basis matrix
                        aVec = aVec.applyMatrix4(basis);
                        bVec = bVec.applyMatrix4(basis);
                        ax = aVec.x;
                        ay = aVec.y;
                        az = aVec.z;
                        bx = bVec.x;
                        by = bVec.y;
                        bz = bVec.z;

                        const dot = v1.dot(v2);
                        const det = ax * by + ay * bz + az * bx - ay * bx - az * by - ax * bz;
                        if (dot < -0.75) {
                            return -1;
                        } else if (dot < 0) {
                            return Math.sign(det);
                        } else {
                            return det;
                        }
                    };
                    const det = getDeterminant();
                    if (det < 0) {
                        if (Math.random() * 0.5 < Math.abs(det)) {
                            el.components['globe-keyboard-controls'].onKeyDown({code: "KeyD"});
                            el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                        } else {
                            el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                            el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                        }
                    } else if (det > 0) {
                        if (Math.random() * 0.33 < Math.abs(det)) {
                            el.components['globe-keyboard-controls'].onKeyDown({code: "KeyA"});
                            el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                        } else {
                            el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                            el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                        }
                    } else {
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                    }

                    if (Math.abs(det) < 0.1) {
                        el.components['globe-keyboard-controls'].onKeyDown({code: "KeyW"});
                    } else {
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyW"});
                    }
                };
            }())
        });

        AFRAME.registerComponent('go-on-land', {
            init: function () {
                this.system = this.el.sceneEl.systems['globe-nav'];
                // @ts-ignore
                this.el.addEventListener('click', (e) => {
                    const destination1 = e.detail.intersection.point.clone();
                    setTimeout(() => {
                        const npcs = document.querySelectorAll('.npc');
                        if (npcs.length === 0) {
                            for (let i = 0; i < 10; i++) {
                                addNpc(i);
                            }
                        }
                    }, 0);
                    setTimeout(() => {
                        const npcEls = document.querySelectorAll('.npc');
                        npcEls.forEach(npcEl => {
                            // @ts-ignore
                            npcEl.setAttribute("globe-nav-agent", `active: false; destination: ${destination1.x} ${destination1.y} ${destination1.z}; speed: 2;`);
                        });
                    }, 500);
                    setTimeout(() => {
                        const npcEls = document.querySelectorAll('.npc');
                        const cameraEl = document.querySelector("#camera-rig");
                        cameraEl.setAttribute("look-at-box", ".npc");
                        npcEls.forEach(npcEl => {
                            // @ts-ignore
                            const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3).add(new THREE.Vector3().random()), destination1.clone().negate());
                            // @ts-ignore
                            const intersections = raycaster.intersectObject(this.system.getNavMesh());
                            if (intersections[0]) {
                                const destination2 = intersections[0].point.clone();
                                // @ts-ignore
                                npcEl.setAttribute("globe-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2;`);
                            }
                        });
                    }, 1000);
                });
            }
        });

        AFRAME.registerComponent('go-to-sea', {
            init: function () {
                this.el.addEventListener('click', function (e) {
                    const destination1 = e.detail.intersection.point.clone();
                    setTimeout(() => {
                        const cameraEl = document.querySelector("#camera-rig");
                        cameraEl.setAttribute("look-at-box", "#box");
                    }, 0);
                    setTimeout(() => {
                        const npcs = document.querySelectorAll('.npc');
                        if (npcs.length !== 0) {
                            removeNpc();
                        }
                    }, 1000);
                    setTimeout(() => {
                        const shipEls = document.querySelectorAll('#box');
                        shipEls.forEach(shipEl => {
                            // @ts-ignore
                            shipEl.setAttribute("globe-ocean-nav-agent", `active: false; destination: ${destination1.x} ${destination1.y} ${destination1.z}; speed: 2;`);
                        });
                    }, 500);
                    setTimeout(() => {
                        const shipEls = document.querySelectorAll('#box');
                        shipEls.forEach(shipEl => {
                            // @ts-ignore
                            shipEl.setAttribute("globe-ocean-nav-agent", `active: true; destination: ${destination1.x} ${destination1.y} ${destination1.z}; speed: 2;`);
                        });
                    }, 1000);
                });
            }
        });
        AFRAME.registerComponent('terrain-tile', {
            init: function () {
            }
        });

        function addNpc(i) {
            const rootNpc = document.createElement("a-entity");
            rootNpc.setAttribute("class", "npc");
            rootNpc.setAttribute("globe-nav-agent", "");
            rootNpc.setAttribute("position", "0 150 0");

            if (characterModels.has("WARRIOR")) {
                const str = characterModels.get("WARRIOR");
                const modelNpc = document.createElement("a-entity");
                modelNpc.setAttribute("gltf-model", str);
                modelNpc.setAttribute("scale", "1 1 1");
                modelNpc.setAttribute("position", "0 0 0");
                modelNpc.setAttribute("rotation", "0 0 0");
                rootNpc.appendChild(modelNpc);
            } else {
                const modelNpc = document.createElement("a-sphere");
                modelNpc.setAttribute("scale", "0.1 0.1 0.1");
                modelNpc.setAttribute("position", "0 0 0");
                rootNpc.appendChild(modelNpc);
            }

            const positionNpc = document.createElement("a-entity");
            positionNpc.setAttribute("class", "npc-position");
            positionNpc.setAttribute("position", "0 0 -5");
            rootNpc.appendChild(positionNpc);

            const scene = document.querySelector("a-scene");
            scene.appendChild(rootNpc);
        }

        function removeNpc() {
            const scene = document.querySelector("a-scene");
            const arr = Array.from(document.querySelectorAll(".npc"));
            arr.forEach(a => scene.removeChild(a));
        }

        function addTerrain(item) {
            const [str, collidable, navmesh, ocean] = JSON.parse(item);
            const rootTerrain = document.createElement("a-entity");
            rootTerrain.setAttribute("gltf-model", str);
            rootTerrain.setAttribute("position", "0 0 0");
            rootTerrain.setAttribute("terrain-tile", "");
            if (ocean) {
                rootTerrain.setAttribute("go-to-sea", "");
                rootTerrain.setAttribute("globe-ocean-nav-mesh", "");
            } else if (navmesh) {
                rootTerrain.setAttribute("globe-nav-mesh", "");
            } else if (collidable) {
                rootTerrain.setAttribute("static-body", "shape: none;");
                rootTerrain.setAttribute("globe-trimesh", "");
                rootTerrain.setAttribute("go-on-land", "");
            } else {
                rootTerrain.setAttribute("static-body", "shape: none;");
                rootTerrain.setAttribute("globe-trimesh", "");
            }

            const scene = document.querySelector("a-scene");
            scene.appendChild(rootTerrain);
        }

        function clearTerrain() {
            const scene = document.querySelector("a-scene");
            const arr = Array.from(document.querySelectorAll("[terrain-tile]"));
            arr.forEach(a => scene.removeChild(a));
        }

        var characterModels = new Map();
        function addCharacterModel(item) {
            const {
                data: str, type
            } = JSON.parse(item);

            characterModels.set(type, str);
        }

        function addPort(item) {
            const {
                data: str, point, lookAt
            } = JSON.parse(item);
            const rootPort = document.createElement("a-entity");
            rootPort.setAttribute("position", `${point[0]} ${point[1]} ${point[2]}`);
            rootPort.setAttribute("terrain-tile", "");

            const rootModel = document.createElement("a-entity");
            rootModel.setAttribute("gltf-model", str);
            rootModel.setAttribute("scale", "0.1 0.1 0.1");
            rootModel.setAttribute("rotation", "90 0 0");
            rootModel.setAttribute("position", "1.35 -1.1 -0.5");
            rootPort.appendChild(rootModel);

            const scene = document.querySelector("a-scene");
            scene.appendChild(rootPort);

            rootPort.object3D.up = new THREE.Vector3(point[0], point[1], point[2]).normalize();
            rootPort.object3D.lookAt(new THREE.Vector3(lookAt[0], lookAt[1], lookAt[2]));
        }

        function addHouse(item) {
            const {
                type, point, lookAt
            } = JSON.parse(item);

            const rootHouse = document.createElement("a-entity");
            rootHouse.setAttribute("position", `${point[0]} ${point[1]} ${point[2]}`);
            rootHouse.setAttribute("terrain-tile", "");

            const rootModel = document.createElement("a-entity");
            rootModel.setAttribute("globe-lod", characterModels.get(type));
            rootModel.setAttribute("scale", "1 1 1");
            rootModel.setAttribute("rotation", "90 0 0");
            rootModel.setAttribute("position", "0 0 0");
            rootHouse.appendChild(rootModel);

            const scene = document.querySelector("a-scene");
            scene.appendChild(rootHouse);

            rootHouse.object3D.up = new THREE.Vector3(point[0], point[1], point[2]).normalize();
            rootHouse.object3D.lookAt(new THREE.Vector3(lookAt[0], lookAt[1], lookAt[2]));
        }

        function addShip(item) {
            if (!!document.querySelector("#box")) {
                return;
            }

            const {
                data: str, point
            } = JSON.parse(item);

            const rootShip = document.createElement("a-entity");
            rootShip.setAttribute("id", "box");
            rootShip.setAttribute("dynamic-body", "shape: sphere; sphereRadius: 1; mass: 100");
            rootShip.setAttribute("globe-gravity", "");
            rootShip.setAttribute("globe-keyboard-controls", "enabled: true; fly: true");
            rootShip.setAttribute("position", `${point[0]} ${point[1]} ${point[2]}`);

            const rootModel = document.createElement("a-entity");
            rootModel.setAttribute("gltf-model", str);
            rootModel.setAttribute("go-to-sea", "");
            rootModel.setAttribute("scale", "0.1 0.1 0.1");
            rootModel.setAttribute("rotation", "0 -90 0");
            rootShip.appendChild(rootModel);

            const rootPosition = document.createElement("a-entity");
            rootPosition.setAttribute("id", "box-position");
            rootPosition.setAttribute("position", "0 0 5");
            rootShip.appendChild(rootPosition);

            const scene = document.querySelector("a-scene");
            scene.appendChild(rootShip);
            const cameraEl = document.querySelector("#camera-rig");
            cameraEl.setAttribute("look-at-box", "#box");
        }
    </script>
    <style>
        a-scene {
            width: 256px;
            height: 256px;
        }
    </style>
</head>
<body>
    <a-scene physics="driver: local; gravity: 0 0 0;" globe-nav globe-ocean-nav embedded cursor="rayOrigin:mouse" id="scene">
        <a-entity light="type: ambient; color: #CCC"></a-entity>
        <a-entity light="type: directional; color: #EEE; intensity: 0.5" position="0 1 0"></a-entity>
        <a-entity light="type: directional; color: #EEE; intensity: 0.5" position="0 -1 0"></a-entity>
        <a-entity id="camera-rig" position="0 105 5">
            <a-camera wasd-controls-enabled="false" look-controls-enabled="false" position="0 1.6 0"></a-camera>
        </a-entity>
    </a-scene>
</body>
</html>