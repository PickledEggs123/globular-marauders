<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Planet Generator</title>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <!-- Import ThreeJS 0.164.0 and our Octree lib-->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.0/examples/jsm/"
            }
        }
    </script>
    <script src="/aframe-v1.6.0.min.js"></script>
    <script src="/aframe-physics-system.js"></script>
    <script src="/aframe-extras.min.js"></script>
    <script src="/aframe-physics-extras.min.js"></script>
    <script src="/three-pathfinding.umd.js"></script>
    <script src="/three-to-cannon.umd.js"></script>
    <script src="/aframe-fps-counter-component.min.js"></script>
    <script src="/aframe-look-at-billboard-component.js"></script>
    <script src="/instanced-mesh.min.js"></script>
    <script src="/networked-aframe.js"></script>
    <script src="/three-bvh.umd.cjs"></script>
    <script src="/aframe-html.js"></script>
    <script src="/Tone.js"></script>
    <script type="application/javascript">
        class MusicPlayer {
            synth = null;
            synthPart = null;

            start() {
                // already playing do nothing
                if (this.synthPart)
                    return;

                this.startTone().catch(err => {
                    console.log("FAILED TO START MUSIC", err);
                });
            }

            stop() {
                if (this.synthPart) {
                    this.synthPart.stop();
                    this.synthPart.dispose();
                    this.synthPart = null;
                }
                Tone.Transport.stop();
            }

            static firstMelody = [
                // stanza 1
                "C3",
                ["C3", "C3"],
                null,
                ["G3", "A#3"],
                null,
                ["A3", "G3"],
                null,
                null,

                // stanza 3
                "A#3",
                ["A#3", "A3"],
                null,
                ["F3", "G3"],
                null,
                ["C2", "C2"],
                null,
                null,

                // stanza 2
                "C3",
                ["C3", "C3"],
                null,
                ["G3", "A#3"],
                null,
                ["A3", "G3"],
                null,
                null,

                // stanza 4
                "A#3",
                ["A#3", "A3"],
                null,
                ["F3", "G3"],
                null,
                ["C2", "C2"],
                null,
                null,
                "END"
            ];
            static secondMelody = [
                // stanza 1
                "C3",
                "D3",
                "Eb3",
                null,

                // stanza 2
                "Eb3",
                null,
                "D3",
                null,

                // stanza 3
                "Eb3",
                "D3",
                "C3",
                null,

                // stanza 4
                "A2",
                null,
                "A#2",
                null,

                // stanza 1
                "C3",
                "D3",
                "Eb3",
                null,

                // stanza 2
                "Eb3",
                null,
                "D3",
                null,

                // stanza 3
                "Eb3",
                "D3",
                "C3",
                null,

                // stanza 4
                "A2",
                null,
                "A#2",
                null,
                "END"
            ];
            static thirdMelody = [
                // stanza 1
                "C3",
                "G2",
                "A2",
                "A#2",
                "A2",
                "G2",

                // stanza 2
                "C3",
                "G2",
                "A2",
                "A#2",
                "A2",
                "G2",

                // stanza 3
                "C3",
                "G2",
                "A2",
                "A#2",
                "A2",
                "G2",

                // stanza 4
                "A2",
                "G2",
                "F2",
                "G2",
                "C2",
                "C2",
                "END"
            ];
            static forthMelody = [
                // stanza 1
                "C3",
                null,
                "G3",
                "G3",
                null,
                null,

                // stanza 2
                "F3",
                null,
                "Eb3",
                "C3",
                null,
                null,

                // stanza 3
                "D3",
                null,
                "Eb3",
                "D3",
                null,
                null,

                // stanza 4
                "C3",
                null,
                "B2",
                "C3",
                null,
                null,
                "END"
            ];

            melodyMap = [{
                id: "main",
                next: "main2",
                notes: MusicPlayer.firstMelody
            }, {
                id: "main2",
                next: "main3",
                notes: MusicPlayer.secondMelody
            }, {
                id: "main3",
                next: "main4",
                notes: MusicPlayer.thirdMelody
            }, {
                id: "main4",
                next: "main5",
                notes: MusicPlayer.thirdMelody
            }, {
                id: "main5",
                next: "main6",
                notes: MusicPlayer.secondMelody
            }, {
                id: "main6",
                next: "main7",
                notes: MusicPlayer.forthMelody
            }, {
                id: "main7",
                next: "main",
                notes: MusicPlayer.forthMelody
            }];
            currentMelody = "main7";

            getNextMelody() {
                const melodyNode = this.melodyMap.find(m => m.id === this.currentMelody);
                if (melodyNode) {
                    const nextMelodyNode = this.melodyMap.find(m => m.id === melodyNode.next);
                    if (nextMelodyNode) {
                        this.currentMelody = nextMelodyNode.id;
                        return nextMelodyNode.notes;
                    }
                }
                const firstMelodyNode = this.melodyMap[0];
                if (firstMelodyNode) {
                    this.currentMelody = firstMelodyNode.id;
                    return firstMelodyNode.notes;
                }
                throw new Error("Could not find melody node to play next sound");
            }

            /**
             * Handle the playing of music and the transition between melodies.
             * @param time
             * @param note
             */
            handleToneSequenceCallback = (time, note) => {
                if (note === "END") {
                    this.setupMelody(this.getNextMelody());
                    if (this.synthPart) {
                        this.synthPart.start(Tone.Transport.seconds);
                    }
                    return;
                }
                if (this.synth && note) {
                    this.synth.triggerAttackRelease(note, "10hz", time);
                }
            };

            setupMelody(notes) {
                // clean up old synth parts
                if (this.synthPart) {
                    this.synthPart.stop();
                    this.synthPart.dispose();
                    this.synthPart = null;
                }
                this.synthPart = new Tone.Sequence(
                    this.handleToneSequenceCallback,
                    notes,
                    "4n"
                );
                this.synthPart.loop = false;
            }

            async startTone() {
                await Tone.start();

                this.synth = new Tone.PolySynth(Tone.Synth).toDestination();

                // first melody
                this.setupMelody(this.getNextMelody());
                if (this.synthPart) {
                    this.synthPart.start(Tone.Transport.seconds);
                }
                Tone.Transport.start();
            }
        }
        window.musicPlayer = new MusicPlayer();

        const PLANET_SIZE = 100;

        // Add the extension functions
        THREE.BufferGeometry.prototype.computeBoundsTree = MeshBVHLib.computeBoundsTree;
        THREE.BufferGeometry.prototype.disposeBoundsTree = MeshBVHLib.disposeBoundsTree;
        THREE.Mesh.prototype.raycast = MeshBVHLib.acceleratedRaycast;

        THREE.BatchedMesh.prototype.computeBoundsTree = MeshBVHLib.computeBatchedBoundsTree;
        THREE.BatchedMesh.prototype.disposeBoundsTree = MeshBVHLib.disposeBatchedBoundsTree;
        THREE.BatchedMesh.prototype.raycast = MeshBVHLib.acceleratedRaycast;

        const buildBoundsTree = (e) => {
            const meshes = [];
            e.detail.model.traverse((x) => {
                if (x.isMesh) {
                    meshes.push(x);
                }
            });
            meshes.forEach((m) => m.geometry.computeBoundsTree());
        };

        function debounce(function_, wait = 100, options = {}) {
            if (typeof function_ !== 'function') {
                throw new TypeError(`Expected the first parameter to be a function, got \`${typeof function_}\`.`);
            }

            if (wait < 0) {
                throw new RangeError('`wait` must not be negative.');
            }

            // TODO: Deprecate the boolean parameter at some point.
            const {immediate} = typeof options === 'boolean' ? {immediate: options} : options;

            let storedContext;
            let storedArguments;
            let timeoutId;
            let timestamp;
            let result;

            function run() {
                const callContext = storedContext;
                const callArguments = storedArguments;
                storedContext = undefined;
                storedArguments = undefined;
                result = function_.apply(callContext, callArguments);
                return result;
            }

            function later() {
                const last = Date.now() - timestamp;

                if (last < wait && last >= 0) {
                    timeoutId = setTimeout(later, wait - last);
                } else {
                    timeoutId = undefined;

                    if (!immediate) {
                        result = run();
                    }
                }
            }

            const debounced = function (...arguments_) {
                if (storedContext && this !== storedContext) {
                    throw new Error('Debounced method called with different contexts.');
                }

                storedContext = this; // eslint-disable-line unicorn/no-this-assignment
                storedArguments = arguments_;
                timestamp = Date.now();

                const callNow = immediate && !timeoutId;

                if (!timeoutId) {
                    timeoutId = setTimeout(later, wait);
                }

                if (callNow) {
                    result = run();
                }

                return result;
            };

            debounced.clear = () => {
                if (!timeoutId) {
                    return;
                }

                clearTimeout(timeoutId);
                timeoutId = undefined;
            };

            debounced.flush = () => {
                if (!timeoutId) {
                    return;
                }

                debounced.trigger();
            };

            debounced.trigger = () => {
                result = run();

                debounced.clear();
            };

            return debounced;
        }

        /**
         * Throttle execution of a function. Especially useful for rate limiting
         * execution of handlers on events like resize and scroll.
         *
         * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)
         *                                            are most useful.
         * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,
         *                                            as-is, to `callback` when the throttled-function is executed.
         * @param {object} [options] -              An object to configure options.
         * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds
         *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed
         *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for
         *                                            `delay` milliseconds, the internal counter is reset).
         * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback
         *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that
         *                                            callback will never executed if both noLeading = true and noTrailing = true.
         * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is
         *                                            false (at end), schedule `callback` to execute after `delay` ms.
         *
         * @returns {Function} A new, throttled, function.
         */
        const throttle = function (delay, callback, options) {
            const {
                noTrailing = false,
                noLeading = false,
                debounceMode = undefined
            } = options || {};
            /*
             * After wrapper has stopped being called, this timeout ensures that
             * `callback` is executed at the proper times in `throttle` and `end`
             * debounce modes.
             */
            let timeoutID;
            let cancelled = false;

            // Keep track of the last time `callback` was executed.
            let lastExec = 0;

            // Function to clear existing timeout
            function clearExistingTimeout() {
                if (timeoutID) {
                    clearTimeout(timeoutID);
                }
            }

            // Function to cancel next exec
            function cancel(options) {
                const { upcomingOnly = false } = options || {};
                clearExistingTimeout();
                cancelled = !upcomingOnly;
            }

            /*
             * The `wrapper` function encapsulates all of the throttling / debouncing
             * functionality and when executed will limit the rate at which `callback`
             * is executed.
             */
            function wrapper(...arguments_) {
                let self = this;
                let elapsed = Date.now() - lastExec;

                if (cancelled) {
                    return;
                }

                // Execute `callback` and update the `lastExec` timestamp.
                function exec() {
                    lastExec = Date.now();
                    callback.apply(self, arguments_);
                }

                /*
                 * If `debounceMode` is true (at begin) this is used to clear the flag
                 * to allow future `callback` executions.
                 */
                function clear() {
                    timeoutID = undefined;
                }

                if (!noLeading && debounceMode && !timeoutID) {
                    /*
                     * Since `wrapper` is being called for the first time and
                     * `debounceMode` is true (at begin), execute `callback`
                     * and noLeading != true.
                     */
                    exec();
                }

                clearExistingTimeout();

                if (debounceMode === undefined && elapsed > delay) {
                    if (noLeading) {
                        /*
                         * In throttle mode with noLeading, if `delay` time has
                         * been exceeded, update `lastExec` and schedule `callback`
                         * to execute after `delay` ms.
                         */
                        lastExec = Date.now();
                        if (!noTrailing) {
                            timeoutID = setTimeout(debounceMode ? clear : exec, delay);
                        }
                    } else {
                        /*
                         * In throttle mode without noLeading, if `delay` time has been exceeded, execute
                         * `callback`.
                         */
                        exec();
                    }
                } else if (noTrailing !== true) {
                    /*
                     * In trailing throttle mode, since `delay` time has not been
                     * exceeded, schedule `callback` to execute `delay` ms after most
                     * recent execution.
                     *
                     * If `debounceMode` is true (at begin), schedule `clear` to execute
                     * after `delay` ms.
                     *
                     * If `debounceMode` is false (at end), schedule `callback` to
                     * execute after `delay` ms.
                     */
                    timeoutID = setTimeout(
                        debounceMode ? clear : exec,
                        debounceMode === undefined ? delay - elapsed : delay
                    );
                }
            }

            wrapper.cancel = cancel;

            // Return the wrapper function.
            return wrapper;
        }

        AFRAME.registerComponent('globe-lod', {
            schema: {
                default: "",
            },
            counter: 60,
            update: function () {
                const data = this.data.split("|");

                const lod0 = this.el.querySelector(".lod0");
                const lod1 = this.el.querySelector(".lod1");
                const lod2 = this.el.querySelector(".lod2");
                if (!lod0 || !lod1 || !lod2) {
                    return;
                }
                lod0.setAttribute("gltf-model", data[0]);
                lod1.setAttribute("gltf-model", data[1]);
                lod2.setAttribute("gltf-model", data[2]);
                lod0.addEventListener("model-loaded", buildBoundsTree);
                lod1.addEventListener("model-loaded", buildBoundsTree);
                lod2.addEventListener("model-loaded", buildBoundsTree);
            },
            tick: function () {
                if (this.counter > 0) {
                    this.counter -= 1;
                    return;
                }
                this.counter = 60;

                const object3D = this.el.object3D;
                const pos = object3D.getWorldPosition(new THREE.Vector3());

                const cameraEl = document.querySelector("#camera-rig");
                const cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());

                const distance = pos.distanceTo(cameraPos);

                const lod0 = this.el.querySelector(".lod0");
                const lod1 = this.el.querySelector(".lod1");
                const lod2 = this.el.querySelector(".lod2");
                if (!lod0 || !lod1 || !lod2) {
                    return;
                }
                if (distance >= 40) {
                    lod0.setAttribute("visible", "false");
                    lod1.setAttribute("visible", "false");
                    lod2.setAttribute("visible", "false");
                } else if (distance >= 20) {
                    lod0.setAttribute("visible", "false");
                    lod1.setAttribute("visible", "false");
                    lod2.setAttribute("visible", "true");
                } else if (distance >= 10) {
                    lod0.setAttribute("visible", "false");
                    lod1.setAttribute("visible", "true");
                    lod2.setAttribute("visible", "false");
                } else if (distance >= 0) {
                    lod0.setAttribute("visible", "true");
                    lod1.setAttribute("visible", "false");
                    lod2.setAttribute("visible", "false");
                }

                // auto update clickable
                const className = "clickable";
                if (distance >= 40 && this.el.classList.contains(className)) {
                    this.el.classList.remove(className);
                } else if (!(distance >= 40) && !this.el.classList.contains(className)) {
                    this.el.classList.add(className);
                }
            }
        });

        AFRAME.registerComponent('globe-gravity', {
            schema: {
                ship: {type: 'boolean', default: false},
                buoyancy: {type: 'boolean', default: true},
            },
            tick: function () {
                const object3D = this.el.object3D;
                const trueUpDistance = object3D.getWorldPosition(new THREE.Vector3());
                const trueUp = trueUpDistance.clone().normalize();
                const currentUp = new THREE.Vector3(0, 1, 0).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                const currentForward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));;
                const currentRight = new THREE.Vector3(1, 0, 0).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                const diffUp = trueUp.clone().sub(currentUp.clone());

                // apply gravity force
                const gravityForce = this.el.body.mass * 10;
                this.el.body.applyForce(new CANNON.Vec3(-trueUp.x, -trueUp.y, -trueUp.z).scale(gravityForce), new CANNON.Vec3(0, 0, 0));

                // apply drag
                this.el.body.applyForce(this.el.body.velocity.clone().scale(-25), new CANNON.Vec3(0, 0, 0));

                if (this.data.ship) {
                    if (this.data.buoyancy) {
                        // apply sideways tilt force
                        const sidewaysTilt = this.el.body.velocity.clone().scale(100).dot(currentRight.clone());
                        const tiltForce = new CANNON.Vec3(currentRight.x, currentRight.y, currentRight.z).scale(sidewaysTilt);
                        const tiltPoint = new CANNON.Vec3(currentUp.x, currentUp.y, currentUp.z);
                        this.el.body.applyForce(tiltForce.clone(), tiltPoint.clone());
                        this.el.body.applyForce(tiltForce.clone().scale(-1), tiltPoint.clone().scale(-1));

                        // apply up right force
                        const springForce = 300;
                        const rotateForce = new CANNON.Vec3(diffUp.x, diffUp.y, diffUp.z).scale(springForce);
                        const rotatePoint = new CANNON.Vec3(currentUp.x, currentUp.y, currentUp.z);
                        const dragForce = this.el.body.angularVelocity.clone().cross(rotatePoint.clone()).scale(100);
                        this.el.body.applyForce(rotateForce.clone().vsub(dragForce), rotatePoint.clone());
                        this.el.body.applyForce(rotateForce.clone().vsub(dragForce).scale(-1), rotatePoint.clone().scale(-1));

                        // apply horizontal drag
                        const horizontalRotatePoint = new CANNON.Vec3(currentForward.x, currentForward.y, currentForward.z);
                        const horizontalDragForce = this.el.body.angularVelocity.clone().cross(horizontalRotatePoint.clone()).scale(100);
                        this.el.body.applyForce(horizontalDragForce.clone().scale(-1), horizontalRotatePoint.clone());
                        this.el.body.applyForce(horizontalDragForce.clone(), horizontalRotatePoint.clone().scale(-1));
                    }

                    if (trueUpDistance.length() < PLANET_SIZE + 1) {
                        const trueUpMagnitude = -(trueUpDistance.length() - PLANET_SIZE - 1);
                        const trueUpForce = new CANNON.Vec3(trueUp.x, trueUp.y, trueUp.z).scale(trueUpMagnitude * (this.data.buoyancy ? 1000 : 10));
                        this.el.body.applyForce(trueUpForce, new CANNON.Vec3(0, 0, 0));
                    }
                }
            }
        });

        AFRAME.registerComponent('globe-trimesh', {
            schema: {},
            init: function () {
                this.el.addEventListener('model-loaded', () => {
                    const obj = this.el.getObject3D('mesh');
                    const result = threeToCannon.getShapeParameters(obj, { type: threeToCannon.ShapeType.MESH });
                    const body = (this.el.components['static-body'].body);
                    body.shapes.splice(0, body.shapes.length);
                    body.shapeOffsets.splice(0, body.shapeOffsets.length)
                    body.shapeOrientations.splice(0, body.shapeOrientations.length)
                    if (result !== null) {
                        const {
                            offset,
                            orientation,
                            params: {
                                vertices,
                                indices,
                            },
                        } = result;
                        const shape = new CANNON.Trimesh(vertices, indices);
                        this.el.components['static-body'].addShape(shape, offset, orientation);
                    }
                });
            }
        });

        AFRAME.registerComponent('cursor-updater', {
            dependencies: ['cursor', 'raycaster'],
            schema: {},
            init: function () {
                this.clientX = 0;
                this.clientY = 0;
                this.handleMouseMove = this.handleMouseMove.bind(this);
                this.el.sceneEl.addEventListener("mousemove", this.handleMouseMove);
            },
            remove: function () {
                this.el.sceneEl.removeEventListener("mousemove", this.handleMouseMove);
            },
            handleMouseMove: function (evt) {
                if (evt.detail.synthetic) {
                    return;
                }
                this.clientX = evt.clientX;
                this.clientY = evt.clientY;
            },
            tick: function () {
                this.el.components['cursor'].onMouseMove(new MouseEvent("mousemove", {
                    clientX: this.clientX,
                    clientY: this.clientY,
                    bubbles: true,
                    cancelable: true,
                    detail: {
                        synthetic: true
                    }
                }));
                this.el.components['raycaster'].checkIntersections();
            },
        });

        AFRAME.registerComponent('look-at-box', {
            schema: {
                type: "string",
                default: ".ship-1:first-of-type",
            },
            init: function () {
                this.dtSumTickSize = 5000;
                this.dtSum = this.dtSumTickSize;
                this.heightDiff = 5;
                this.heightDiffLerp = 5;
            },
            tick: function (t, dt) {
                // get elements
                let [dataItem, dataPostfix] = this.data.split(":");
                let otherClassName = "";
                if (dataPostfix) {
                    [dataPostfix, otherClassName] = dataPostfix.split(" ", 2);
                    dataPostfix = `:${dataPostfix}`;
                    if (otherClassName) {
                        otherClassName = ` ${otherClassName}`;
                    } else {
                        otherClassName = "";
                    }
                }
                const boxSelector = `${dataItem}${otherClassName}`;
                const boxPosSelector = `${dataItem}${otherClassName}-position`;
                const box = Array.from(document.querySelectorAll(boxSelector)).map(el => el.object3D);
                const boxPos = Array.from(document.querySelectorAll(boxPosSelector)).map(el => el.object3D);
                if (!box.length || !boxPos.length) {
                    return;
                }
                if (dataPostfix) {
                    box.splice(1, box.length - 1);
                    boxPos.splice(1, boxPos.length - 1);
                }

                // get position
                const boxWorldPos = new THREE.Vector3();
                box.forEach(b => boxWorldPos.add(b.getWorldPosition(new THREE.Vector3())));
                boxWorldPos.divideScalar(box.length);
                const boxPosWorldPos = new THREE.Vector3();
                boxPos.forEach(b => boxPosWorldPos.add(b.getWorldPosition(new THREE.Vector3())));
                boxPosWorldPos.divideScalar(boxPos.length);
                if (!boxPos.length) {
                    return;
                }

                // get info
                const upVector = boxPosWorldPos.clone().sub(new THREE.Vector3(0, 0, 0)).normalize();
                const object3D = this.el.object3D;
                const objectWorldPos = object3D.getWorldPosition(new THREE.Vector3());
                const height = boxPosWorldPos.clone().sub(new THREE.Vector3(0, 0, 0)).length();

                // update info
                const quaternion = new THREE.Quaternion().setFromUnitVectors(objectWorldPos.clone().normalize(), boxPosWorldPos.clone().normalize());
                const slerp = new THREE.Quaternion().slerp(quaternion, 0.03);
                let destination1 = objectWorldPos.clone().normalize().multiplyScalar(height + 5).applyQuaternion(slerp);

                // compute raycast towards ground
                let finalPosition;
                if (this.dtSum + dt > this.dtSumTickSize) {
                    const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), destination1.clone().negate());
                    const intersections = raycaster.intersectObjects(Array.from(document.querySelectorAll(".clickable")).map(el => el.object3D));
                    if (intersections[0]) {
                        destination1 = intersections[0].point.clone();
                    }
                    finalPosition = destination1.clone().add(destination1.clone().normalize().multiplyScalar(5));
                    this.heightDiff = new THREE.Vector3().distanceTo(finalPosition) - (height + 5);
                    this.heightDiffLerp = 0.1 * this.heightDiff + 0.9 * this.heightDiffLerp;
                    this.dtSum = 0;
                } else {
                    if (this.heightDiff > this.heightDiffLerp) {
                        this.heightDiffLerp = 0.03 * this.heightDiff + 0.97 * this.heightDiffLerp;
                    } else {
                        this.heightDiffLerp = 0.005 * this.heightDiff + 0.995 * this.heightDiffLerp;
                    }
                    finalPosition = objectWorldPos.clone().normalize().multiplyScalar(this.heightDiffLerp + height + 5).applyQuaternion(slerp);
                    this.dtSum += dt;
                }

                // update camera
                const cameraLookControlsEl = document.querySelector('[globe-look-controls]');
                object3D.position.set(finalPosition.x, finalPosition.y, finalPosition.z);
                if (this.el.sceneEl?.renderer?.xr?.isPresenting || cameraLookControlsEl.components['globe-look-controls']?.magicWindowControls?.enabled) {
                    object3D.up = upVector;
                    object3D.lookAt(boxWorldPos.clone().add(upVector.clone().add(upVector.clone().multiplyScalar(5))));
                } else {
                    const camera = this.el.sceneEl.camera;
                    camera.up = upVector;
                    camera.lookAt(boxWorldPos);
                }
            }
        });

        AFRAME.registerComponent('globe-look-controls', {
            dependencies: ['position', 'rotation'],

            schema: {
                enabled: {default: true},
                magicWindowTrackingEnabled: {default: true},
                pointerLockEnabled: {default: false},
                reverseMouseDrag: {default: false},
                reverseTouchDrag: {default: false},
                touchEnabled: {default: true},
                mouseEnabled: {default: true}
            },

            init: function () {
                this.deltaYaw = 0;
                this.previousHMDPosition = new THREE.Vector3();
                this.hmdQuaternion = new THREE.Quaternion();
                this.magicWindowAbsoluteQuaternion = new THREE.Quaternion();
                this.magicWindowDeltaQuaternion = new THREE.Quaternion();
                this.position = new THREE.Vector3();
                this.magicWindowObject = new THREE.Object3D();
                this.rotation = {};
                this.deltaRotation = {};
                this.savedPose = null;
                this.pointerLocked = false;
                this.setupMouseControls();
                this.bindMethods();
                this.previousMouseEvent = {};

                this.setupMagicWindowControls();

                // To save / restore camera pose
                this.savedPose = {
                    position: new THREE.Vector3(),
                    rotation: new THREE.Euler()
                };

                // Call enter VR handler if the scene has entered VR before the event listeners attached.
                if (this.el.sceneEl.is('vr-mode') || this.el.sceneEl.is('ar-mode')) { this.onEnterVR(); }
            },

            setupMagicWindowControls: function () {
                var magicWindowControls;
                var data = this.data;

                // Only on mobile devices and only enabled if DeviceOrientation permission has been granted.
                if (AFRAME.utils.device.isMobile() || AFRAME.utils.device.isMobileDeviceRequestingDesktopSite()) {
                    magicWindowControls = this.magicWindowControls = new THREE.DeviceOrientationControls(this.magicWindowObject);
                    if (typeof DeviceOrientationEvent !== 'undefined' && DeviceOrientationEvent.requestPermission) {
                        magicWindowControls.enabled = false;
                        if (this.el.sceneEl.components['device-orientation-permission-ui'].permissionGranted) {
                            magicWindowControls.enabled = data.magicWindowTrackingEnabled;
                        } else {
                            this.el.sceneEl.addEventListener('deviceorientationpermissiongranted', function () {
                                magicWindowControls.enabled = data.magicWindowTrackingEnabled;
                            });
                        }
                    }
                }
            },

            update: function (oldData) {
                var data = this.data;

                // Disable grab cursor classes if no longer enabled.
                if (data.enabled !== oldData.enabled) {
                    this.updateGrabCursor(data.enabled);
                }

                // Reset magic window eulers if tracking is disabled.
                if (oldData && !data.magicWindowTrackingEnabled && oldData.magicWindowTrackingEnabled) {
                    this.magicWindowAbsoluteQuaternion.set(0, 0, 0, 1);
                    this.magicWindowDeltaQuaternion.set(0, 0, 0, 1);
                }

                // Pass on magic window tracking setting to magicWindowControls.
                if (this.magicWindowControls) {
                    this.magicWindowControls.enabled = data.magicWindowTrackingEnabled;
                }

                if (oldData && !data.pointerLockEnabled !== oldData.pointerLockEnabled) {
                    this.removeEventListeners();
                    this.addEventListeners();
                    if (this.pointerLocked) { this.exitPointerLock(); }
                }
            },

            tick: function (t) {
                var data = this.data;
                if (!data.enabled) { return; }
                this.updateOrientation();
            },

            play: function () {
                this.addEventListeners();
            },

            pause: function () {
                this.removeEventListeners();
                if (this.pointerLocked) { this.exitPointerLock(); }
            },

            remove: function () {
                this.removeEventListeners();
                if (this.pointerLocked) { this.exitPointerLock(); }
            },

            bindMethods: function () {
                this.onMouseDown = bind(this.onMouseDown, this);
                this.onMouseMove = bind(this.onMouseMove, this);
                this.onMouseUp = bind(this.onMouseUp, this);
                this.onTouchStart = bind(this.onTouchStart, this);
                this.onTouchMove = bind(this.onTouchMove, this);
                this.onTouchEnd = bind(this.onTouchEnd, this);
                this.onEnterVR = bind(this.onEnterVR, this);
                this.onExitVR = bind(this.onExitVR, this);
                this.onPointerLockChange = bind(this.onPointerLockChange, this);
                this.onPointerLockError = bind(this.onPointerLockError, this);
            },

            /**
             * Set up states and Object3Ds needed to store rotation data.
             */
            setupMouseControls: function () {
                this.mouseDown = false;
                this.pitchObject = new THREE.Object3D();
                this.yawObject = new THREE.Object3D();
                this.yawObject.position.y = 10;
                this.yawObject.add(this.pitchObject);
            },

            /**
             * Add mouse and touch event listeners to canvas.
             */
            addEventListeners: function () {
                var sceneEl = this.el.sceneEl;
                var canvasEl = sceneEl.canvas;

                // Wait for canvas to load.
                if (!canvasEl) {
                    sceneEl.addEventListener('render-target-loaded', bind(this.addEventListeners, this));
                    return;
                }

                // Mouse events.
                canvasEl.addEventListener('mousedown', this.onMouseDown, false);
                window.addEventListener('mousemove', this.onMouseMove, false);
                window.addEventListener('mouseup', this.onMouseUp, false);

                // Touch events.
                canvasEl.addEventListener('touchstart', this.onTouchStart);
                window.addEventListener('touchmove', this.onTouchMove);
                window.addEventListener('touchend', this.onTouchEnd);

                // sceneEl events.
                sceneEl.addEventListener('enter-vr', this.onEnterVR);
                sceneEl.addEventListener('exit-vr', this.onExitVR);

                // Pointer Lock events.
                if (this.data.pointerLockEnabled) {
                    document.addEventListener('pointerlockchange', this.onPointerLockChange, false);
                    document.addEventListener('mozpointerlockchange', this.onPointerLockChange, false);
                    document.addEventListener('pointerlockerror', this.onPointerLockError, false);
                }
            },

            /**
             * Remove mouse and touch event listeners from canvas.
             */
            removeEventListeners: function () {
                var sceneEl = this.el.sceneEl;
                var canvasEl = sceneEl && sceneEl.canvas;

                if (!canvasEl) { return; }

                // Mouse events.
                canvasEl.removeEventListener('mousedown', this.onMouseDown);
                window.removeEventListener('mousemove', this.onMouseMove);
                window.removeEventListener('mouseup', this.onMouseUp);

                // Touch events.
                canvasEl.removeEventListener('touchstart', this.onTouchStart);
                window.removeEventListener('touchmove', this.onTouchMove);
                window.removeEventListener('touchend', this.onTouchEnd);

                // sceneEl events.
                sceneEl.removeEventListener('enter-vr', this.onEnterVR);
                sceneEl.removeEventListener('exit-vr', this.onExitVR);

                // Pointer Lock events.
                document.removeEventListener('pointerlockchange', this.onPointerLockChange, false);
                document.removeEventListener('mozpointerlockchange', this.onPointerLockChange, false);
                document.removeEventListener('pointerlockerror', this.onPointerLockError, false);
            },

            /**
             * Update orientation for mobile, mouse drag, and headset.
             * Mouse-drag only enabled if HMD is not active.
             */
            updateOrientation: function () {
                var object3D = this.el.object3D;
                var pitchObject = this.pitchObject;
                var yawObject = this.yawObject;
                var sceneEl = this.el.sceneEl;

                // In VR or AR mode, THREE is in charge of updating the camera pose.
                if ((sceneEl.is('vr-mode') || sceneEl.is('ar-mode')) && sceneEl.checkHeadsetConnected()) {
                    // With WebXR THREE applies headset pose to the object3D internally.
                    return;
                }

                this.updateMagicWindowOrientation();

                // On mobile, do camera rotation with touch events and sensors.
                object3D.quaternion.copy(this.magicWindowAbsoluteQuaternion);
            },

            updateMagicWindowOrientation: function () {
                var magicWindowAbsoluteQuaternion = this.magicWindowAbsoluteQuaternion;
                var magicWindowDeltaQuaternion = this.magicWindowDeltaQuaternion;
                // Calculate magic window HMD quaternion.
                if (this.magicWindowControls && this.magicWindowControls.enabled) {
                    this.magicWindowControls.update();
                    const magicQuaternion = this.magicWindowObject.quaternion.clone().multiply(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 0, 1)));
                    magicQuaternion.x *= -1;
                    magicQuaternion.z *= -1;
                    magicWindowAbsoluteQuaternion.copy(magicQuaternion);
                }
            },

            /**
             * Translate mouse drag into rotation.
             *
             * Dragging up and down rotates the camera around the X-axis (yaw).
             * Dragging left and right rotates the camera around the Y-axis (pitch).
             */
            onMouseMove: function (evt) {
                var direction;
                var movementX;
                var movementY;
                var pitchObject = this.pitchObject;
                var previousMouseEvent = this.previousMouseEvent;
                var yawObject = this.yawObject;

                // Not dragging or not enabled.
                if (!this.data.enabled || (!this.mouseDown && !this.pointerLocked)) { return; }

                // Calculate delta.
                if (this.pointerLocked) {
                    movementX = evt.movementX || evt.mozMovementX || 0;
                    movementY = evt.movementY || evt.mozMovementY || 0;
                } else {
                    movementX = evt.screenX - previousMouseEvent.screenX;
                    movementY = evt.screenY - previousMouseEvent.screenY;
                }
                this.previousMouseEvent.screenX = evt.screenX;
                this.previousMouseEvent.screenY = evt.screenY;

                // Calculate rotation.
                direction = this.data.reverseMouseDrag ? 1 : -1;
                yawObject.rotation.y += movementX * 0.002 * direction;
                pitchObject.rotation.x += movementY * 0.002 * direction;
                pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));
            },

            /**
             * Register mouse down to detect mouse drag.
             */
            onMouseDown: function (evt) {
                var sceneEl = this.el.sceneEl;
                if (!this.data.enabled || !this.data.mouseEnabled || ((sceneEl.is('vr-mode') || sceneEl.is('ar-mode')) && sceneEl.checkHeadsetConnected())) { return; }
                // Handle only primary button.
                if (evt.button !== 0) { return; }

                var canvasEl = sceneEl && sceneEl.canvas;

                this.mouseDown = true;
                this.previousMouseEvent.screenX = evt.screenX;
                this.previousMouseEvent.screenY = evt.screenY;
                this.showGrabbingCursor();

                if (this.data.pointerLockEnabled && !this.pointerLocked) {
                    if (canvasEl.requestPointerLock) {
                        canvasEl.requestPointerLock();
                    } else if (canvasEl.mozRequestPointerLock) {
                        canvasEl.mozRequestPointerLock();
                    }
                }
            },

            /**
             * Shows grabbing cursor on scene
             */
            showGrabbingCursor: function () {
                this.el.sceneEl.canvas.style.cursor = 'grabbing';
            },

            /**
             * Hides grabbing cursor on scene
             */
            hideGrabbingCursor: function () {
                this.el.sceneEl.canvas.style.cursor = '';
            },

            /**
             * Register mouse up to detect release of mouse drag.
             */
            onMouseUp: function () {
                this.mouseDown = false;
                this.hideGrabbingCursor();
            },

            /**
             * Register touch down to detect touch drag.
             */
            onTouchStart: function (evt) {
                if (evt.touches.length !== 1 ||
                    !this.data.touchEnabled ||
                    this.el.sceneEl.is('vr-mode') ||
                    this.el.sceneEl.is('ar-mode')) { return; }
                this.touchStart = {
                    x: evt.touches[0].pageX,
                    y: evt.touches[0].pageY
                };
                this.touchStarted = true;
            },

            /**
             * Translate touch move to Y-axis rotation.
             */
            onTouchMove: function (evt) {
                var direction;
                var canvas = this.el.sceneEl.canvas;
                var deltaY;
                var yawObject = this.yawObject;

                if (!this.touchStarted || !this.data.touchEnabled) { return; }

                deltaY = 2 * Math.PI * (evt.touches[0].pageX - this.touchStart.x) / canvas.clientWidth;

                direction = this.data.reverseTouchDrag ? 1 : -1;
                // Limit touch orientaion to to yaw (y axis).
                yawObject.rotation.y -= deltaY * 0.5 * direction;
                this.touchStart = {
                    x: evt.touches[0].pageX,
                    y: evt.touches[0].pageY
                };
            },

            /**
             * Register touch end to detect release of touch drag.
             */
            onTouchEnd: function () {
                this.touchStarted = false;
            },

            /**
             * Save pose.
             */
            onEnterVR: function () {
                var sceneEl = this.el.sceneEl;
                if (!sceneEl.checkHeadsetConnected()) { return; }
                this.saveCameraPose();
                this.el.object3D.position.set(0, 0, 0);
                this.el.object3D.rotation.set(0, 0, 0);
                if (sceneEl.hasWebXR) {
                    this.el.object3D.matrixAutoUpdate = false;
                    this.el.object3D.updateMatrix();
                }
            },

            /**
             * Restore the pose.
             */
            onExitVR: function () {
                if (!this.el.sceneEl.checkHeadsetConnected()) { return; }
                this.restoreCameraPose();
                this.previousHMDPosition.set(0, 0, 0);
                this.el.object3D.matrixAutoUpdate = true;
            },

            /**
             * Update Pointer Lock state.
             */
            onPointerLockChange: function () {
                this.pointerLocked = !!(document.pointerLockElement || document.mozPointerLockElement);
            },

            /**
             * Recover from Pointer Lock error.
             */
            onPointerLockError: function () {
                this.pointerLocked = false;
            },

            // Exits pointer-locked mode.
            exitPointerLock: function () {
                document.exitPointerLock();
                this.pointerLocked = false;
            },

            /**
             * Toggle the feature of showing/hiding the grab cursor.
             */
            updateGrabCursor: function (enabled) {
                var sceneEl = this.el.sceneEl;

                function enableGrabCursor () { sceneEl.canvas.classList.add('a-grab-cursor'); }
                function disableGrabCursor () { sceneEl.canvas.classList.remove('a-grab-cursor'); }

                if (!sceneEl.canvas) {
                    if (enabled) {
                        sceneEl.addEventListener('render-target-loaded', enableGrabCursor);
                    } else {
                        sceneEl.addEventListener('render-target-loaded', disableGrabCursor);
                    }
                    return;
                }

                if (enabled) {
                    enableGrabCursor();
                    return;
                }
                disableGrabCursor();
            },

            /**
             * Save camera pose before entering VR to restore later if exiting.
             */
            saveCameraPose: function () {
                var el = this.el;

                this.savedPose.position.copy(el.object3D.position);
                this.savedPose.rotation.copy(el.object3D.rotation);
                this.hasSavedPose = true;
            },

            /**
             * Reset camera pose to before entering VR.
             */
            restoreCameraPose: function () {
                var el = this.el;
                var savedPose = this.savedPose;

                if (!this.hasSavedPose) { return; }

                // Reset camera orientation.
                el.object3D.position.copy(savedPose.position);
                el.object3D.rotation.copy(savedPose.rotation);
                this.hasSavedPose = false;
            }
        });

        const unitMap = new Map([
            ["ship-1", "raider-1"],
            ["ship-2", "raider-2"],
            ["ship-3", "raider-3"],
            ["raider-1", "raider-1"],
            ["raider-2", "raider-2"],
            ["raider-3", "raider-3"],
        ]);
        const inverseUnitMap = new Map([
            ["ship-1", "ship-1"],
            ["ship-2", "ship-2"],
            ["ship-3", "ship-3"],
            ["raider-1", "ship-1"],
            ["raider-2", "ship-2"],
            ["raider-3", "ship-3"],
        ]);

        const KEYCODE_TO_CODE = {
            '38': 'ArrowUp',
            '37': 'ArrowLeft',
            '40': 'ArrowDown',
            '39': 'ArrowRight',
            '87': 'KeyW',
            '65': 'KeyA',
            '83': 'KeyS',
            '68': 'KeyD',
            '81': 'KeyQ',
            '69': 'KeyE',
            '70': 'KeyF',
        };
        const bind = AFRAME.utils.bind;
        const shouldCaptureKeyEvent = AFRAME.utils.shouldCaptureKeyEvent;
        const KEYS = [
            'KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyQ', 'KeyE', 'KeyF',
            'ArrowUp', 'ArrowLeft', 'ArrowRight', 'ArrowDown',
        ];

        AFRAME.registerComponent('globe-keyboard-controls', {
            schema: {
                acceleration: {default: 100},
                enabled: {default: true},
                fly: {default: false},
            },

            init: function () {
                // To keep track of the pressed keys.
                this.keys = {};
                this.mainKeys = {};
                this.velocity = new THREE.Vector3();
                this.rotation = new THREE.Vector3();

                // Bind methods and add event listeners.
                this.onBlur = bind(this.onBlur, this);
                this.onContextMenu = bind(this.onContextMenu, this);
                this.onFocus = bind(this.onFocus, this);
                this.onKeyDown = bind(this.onKeyDown, this);
                this.onKeyUp = bind(this.onKeyUp, this);
                this.onVisibilityChange = bind(this.onVisibilityChange, this);
                this.attachVisibilityEventListeners();
                this.throttle = throttle(250, function () {
                    const destination1 = this.el.object3D.position.clone();
                    setTimeout(() => {
                        const scene = document.querySelector("a-scene");
                        const shipEls = Array.from(document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`));
                        shipEls.slice(1).forEach(shipEl => {
                            shipEl.setAttribute("globe-ocean-nav-agent", `active: false; destination: ${destination1.x} ${destination1.y} ${destination1.z}; speed: 2;`);
                        });
                    }, 125);
                    setTimeout(() => {
                        const scene = document.querySelector("a-scene");
                        const shipEls = Array.from(document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`));
                        shipEls.slice(1).forEach(shipEl => {
                            shipEl.setAttribute("globe-ocean-nav-agent", `active: true; destination: ${destination1.x} ${destination1.y} ${destination1.z}; speed: 2;`);
                        });
                    }, 250);
                });
            },

            tick: function (time, delta) {
                const body = this.el.body;

                // Update velocity.
                delta = delta / 1000;
                this.updateVelocity(delta);

                // Get movement vector and translate position.
                body.applyForce(this.getMovementVector(delta).clone(), new CANNON.Vec3(0, 0, 0));

                if (this.rotation.clone().y) {
                    // apply rotation force
                    body.applyLocalForce(new CANNON.Vec3(this.rotation.clone().y, 0, 0), new CANNON.Vec3(0, 0, 1));
                    body.applyLocalForce(new CANNON.Vec3(-this.rotation.clone().y, 0, 0), new CANNON.Vec3(0, 0, -1));
                }

                if (Object.keys(this.mainKeys).length) {
                    this.throttle();
                }
            },

            remove: function () {
                this.removeKeyEventListeners();
                this.removeVisibilityEventListeners();
            },

            play: function () {
                this.attachKeyEventListeners();
            },

            pause: function () {
                this.keys = {};
                this.removeKeyEventListeners();
            },

            updateVelocity: function (delta) {
                var acceleration;
                var data = this.data;
                var keys = this.keys;
                var velocity = this.velocity;
                var rotation = this.rotation;

                if (!data.enabled) { return; }

                // Update velocity using keys pressed.
                acceleration = data.acceleration;
                velocity.set(0, 0, 0);
                rotation.set(0, 0, 0);
                if (keys.KeyA || keys.ArrowLeft) { rotation.y = acceleration; }
                if (keys.KeyD || keys.ArrowRight) { rotation.y = -acceleration; }
                if (keys.KeyW || keys.ArrowUp) { velocity.z = -acceleration; }
                if (keys.KeyS || keys.ArrowDown) { velocity.z = acceleration; }

                const bodyWorldVelocity = this.el.body.velocity.clone();
                const bodyWorldQuat = this.el.body.quaternion.clone().inverse();
                const bodyVelocity = new THREE.Vector3(bodyWorldVelocity.x, bodyWorldVelocity.y, bodyWorldVelocity.z).applyQuaternion(new THREE.Quaternion(bodyWorldQuat.x, bodyWorldQuat.y, bodyWorldQuat.z, bodyWorldQuat.w));
                velocity.sub(new THREE.Vector3(bodyVelocity.x, bodyVelocity.y, bodyVelocity.z).multiplyScalar(1));
            },

            getMovementVector: (function () {
                var directionVector = new THREE.Vector3(0, 0, 0);

                return function (delta) {
                    var velocity = this.velocity;
                    var rotation = this.el.object3D.getWorldQuaternion(new THREE.Quaternion());

                    directionVector.copy(velocity);

                    // Transform direction relative to heading.
                    directionVector.applyQuaternion(rotation);
                    return directionVector;
                };
            })(),

            attachVisibilityEventListeners: function () {
                window.oncontextmenu = this.onContextMenu;
                window.addEventListener('blur', this.onBlur);
                window.addEventListener('focus', this.onFocus);
                document.addEventListener('visibilitychange', this.onVisibilityChange);
            },

            removeVisibilityEventListeners: function () {
                window.removeEventListener('blur', this.onBlur);
                window.removeEventListener('focus', this.onFocus);
                document.removeEventListener('visibilitychange', this.onVisibilityChange);
            },

            attachKeyEventListeners: function () {
                window.addEventListener('keydown', this.onKeyDown);
                window.addEventListener('keyup', this.onKeyUp);
            },

            removeKeyEventListeners: function () {
                window.removeEventListener('keydown', this.onKeyDown);
                window.removeEventListener('keyup', this.onKeyUp);
            },

            onContextMenu: function () {
                var keys = Object.keys(this.keys);
                for (var i = 0; i < keys.length; i++) {
                    delete this.keys[keys[i]];
                }
            },

            onBlur: function () {
                this.pause();
            },

            onFocus: function () {
                this.play();
            },

            onVisibilityChange: function () {
                if (document.hidden) {
                    this.onBlur();
                } else {
                    this.onFocus();
                }
            },

            onKeyDown: function (event) {
                var el = this.el;

                var code;
                if (!shouldCaptureKeyEvent(event)) { return; }
                code = event.code || KEYCODE_TO_CODE[event.keyCode];

                if (code === "KeyE") {
                    const leftCannonFire = document.querySelector("#left-cannon-fire");
                    leftCannonFire.components["select-cannon-side"].innerSelectCannonSide();
                }
                if (code === "KeyQ") {
                    const rightCannonFire = document.querySelector("#right-cannon-fire");
                    rightCannonFire.components["select-cannon-side"].innerSelectCannonSide();
                }
                if (code === "KeyF") {
                    const noneCannonFire = document.querySelector("#none-cannon-fire");
                    noneCannonFire.components["select-cannon-side"].innerSelectCannonSide();
                }

                const scene = document.querySelector("a-scene");
                const ships = Array.from(scene.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`));
                if (el === ships[0]) {
                    if (!event.synthetic) {
                        if (KEYS.indexOf(code) !== -1) { this.mainKeys[code] = true; }
                    }
                } else {
                    if (!event.synthetic) {
                        for (const key in this.keys) {
                            this.keys[key] = false;
                        }
                        return;
                    }
                }

                if (KEYS.indexOf(code) !== -1) { this.keys[code] = true; }
            },

            onKeyUp: function (event) {
                var el = this.el;

                var code;
                if (!shouldCaptureKeyEvent(event)) { return; }
                code = event.code || KEYCODE_TO_CODE[event.keyCode];

                const scene = document.querySelector("a-scene");
                const ships = Array.from(scene.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`));
                if (el === ships[0]) {
                    if (!event.synthetic) {
                        delete this.mainKeys[code];
                    }
                } else {
                    if (!event.synthetic) {
                        for (const key in this.keys) {
                            this.keys[key] = false;
                        }
                        return;
                    }
                }
                delete this.keys[code];
            }
        });

        const pathfinder = new threePathfinding.Pathfinding();
        const oceanPathfinder = new threePathfinding.Pathfinding();
        const ZONE = 'level';

        /**
         * nav
         *
         * Pathfinding system, using PatrolJS.
         */
        AFRAME.registerSystem('globe-nav', {
            navMesh: null,
            agents: new Set(),
            init: function () {
                this.navMesh = null;
                this.agents = new Set();
            },

            /**
             * @param {THREE.Geometry} geometry
             */
            setNavMeshGeometry: function (geometry) {
                this.navMesh = new THREE.Mesh(geometry);
                pathfinder.setZoneData(ZONE, threePathfinding.Pathfinding.createZone(geometry));
                Array.from(this.agents).forEach((agent) => agent.updateNavLocation());
            },

            /**
             * @return {THREE.Mesh}
             */
            getNavMesh: function () {
                return this.navMesh;
            },

            /**
             * @param {NavAgent} ctrl
             */
            addAgent: function (ctrl) {
                this.agents.add(ctrl);
            },

            /**
             * @param {NavAgent} ctrl
             */
            removeAgent: function (ctrl) {
                this.agents.delete(ctrl);
            },

            /**
             * @param  {THREE.Vector3} start
             * @param  {THREE.Vector3} end
             * @param  {number} groupID
             * @return {Array<THREE.Vector3>}
             */
            getPath: function (start, end, groupID) {
                return this.navMesh
                    ? groupID === null ? [] : pathfinder.findPath(start, end, ZONE, groupID)
                    : null;
            },

            /**
             * @param {THREE.Vector3} position
             * @return {number}
             */
            getGroup: function (position) {
                return this.navMesh
                    ? pathfinder.getGroup(ZONE, position)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} position
             * @param  {number} groupID
             * @return {Node}
             */
            getNode: function (position, groupID) {
                return this.navMesh
                    ? pathfinder.getClosestNode(position, ZONE, groupID, true)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} start Starting position.
             * @param  {THREE.Vector3} end Desired ending position.
             * @param  {number} groupID
             * @param  {Node} node
             * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.
             * @return {Node} Current node, after step is taken.
             */
            clampStep: function (start, end, groupID, node, endTarget) {
                if (!this.navMesh) {
                    endTarget.copy(end);
                    return null;
                } else if (!node) {
                    endTarget.copy(end);
                    return this.getNode(end, groupID);
                }
                return pathfinder.clampStep(start, end, node, ZONE, groupID, endTarget);
            }
        });

        AFRAME.registerComponent('globe-nav-mesh', {
            schema: {
                nodeName: {type: 'string'}
            },
            hasLoadedNavMesh: false,
            nodeName: "",
            init: function () {
                this.system = this.el.sceneEl.systems['globe-nav'];
                this.hasLoadedNavMesh = false;
                this.nodeName = this.data.nodeName;
                this.el.addEventListener('object3dset', this.loadNavMesh.bind(this));
            },

            play: function () {
                if (!this.hasLoadedNavMesh) this.loadNavMesh();
            },

            loadNavMesh: function () {
                var self = this;
                const object = this.el.getObject3D('mesh');
                const scene = this.el.sceneEl.object3D;

                if (!object) return;

                let navMesh;
                object.traverse((node) => {
                    if (node.isMesh &&
                        (!self.nodeName || node.name === self.nodeName)) navMesh = node;
                });

                if (!navMesh) return;

                const navMeshGeometry = navMesh.geometry.clone();
                navMesh.updateWorldMatrix(true, false);
                navMeshGeometry.applyMatrix4(navMesh.matrixWorld);
                this.system.setNavMeshGeometry(navMeshGeometry);
                this.hasLoadedNavMesh = true;
                this.el.setAttribute("visible", "false");
            }
        });

        AFRAME.registerComponent('globe-nav-agent', {
            schema: {
                destination: {type: 'vec3'},
                active: {default: false},
                speed: {default: 2}
            },
            system: null,
            group: null,
            path: [],
            init: function () {
                this.system = this.el.sceneEl.systems['globe-nav'];
                this.system.addAgent(this);
                this.group = null;
                this.path = [];
                this.material = new THREE.LineBasicMaterial({ color: 0xffffff });
                this.geometry = new THREE.BufferGeometry().setFromPoints([]);
                this.line = new THREE.Line(this.geometry, this.material);
                this.debugId = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
            },
            remove: function () {
                const scene = document.querySelector("a-scene");
                this.system.removeAgent(this);
                const el = this.el;
                if (el.classList.contains(`${scene.components['coin-purse'].activeUnit}`)) {
                    if (this.el.sceneEl.object3DMap[`line-debug-${this.debugId}`]) {
                        this.el.sceneEl.removeObject3D(`line-debug-${this.debugId}`);
                    }
                }
            },
            update: function () {
                this.path.length = 0;
            },
            updateNavLocation: function () {
                this.group = null;
                this.path = [];
            },
            tick: function (t, dt) {
                const vDest = new THREE.Vector3();
                const vDelta = new THREE.Vector3();
                const vNext = new THREE.Vector3();

                const el = this.el;
                const data = this.data;
                const speed = data.speed * dt / 1000;

                if (!data.active) return;

                const object3D = this.el.object3D;
                const pos = object3D.getWorldPosition(new THREE.Vector3());

                const cameraEl = document.querySelector("#camera-rig");
                const cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());

                const cameraDistance = pos.distanceTo(cameraPos);
                object3D.visible = cameraDistance < 20;

                // Use PatrolJS pathfinding system to get the shortest path to target.
                if (!this.path.length) {
                    const position = this.el.object3D.position;
                    this.group = this.group || this.system.getGroup(position);
                    this.path = this.system.getPath(position, vDest.copy(data.destination), this.group) || [];
                    el.emit('navigation-start');
                }

                const scene = document.querySelector("a-scene");
                if (el.classList.contains(`${scene.components['coin-purse'].activeUnit}`)) {
                    if (this.el.sceneEl.object3DMap[`line-debug-${this.debugId}`]) {
                        this.el.sceneEl.removeObject3D(`line-debug-${this.debugId}`);
                    }
                    this.geometry.setFromPoints([this.el.object3D.position, ...this.path].map(x => new THREE.Vector3().addVectors(x, x.clone().normalize())));
                    this.geometry.computeBoundingSphere();
                    this.line = new THREE.Line(this.geometry, this.material);
                    this.el.sceneEl.setObject3D(`line-debug-${this.debugId}`, this.line);
                }

                // If no path is found, exit.
                if (!this.path.length) {
                    // console.warn('[nav] Unable to find path to %o.', data.destination);
                    this.el.setAttribute("globe-nav-agent", "active: false;");
                    el.emit('navigation-end');
                    el.emit('navigation-group-change');
                    el.object3D.position.copy(vDest);
                    this.group = null;
                    el.emit('navigation-group-changed');
                    return;
                }

                // Current segment is a vector from current position to next waypoint.
                const vCurrent = el.object3D.position;
                const vWaypoint = this.path[0];
                vDelta.subVectors(vWaypoint, vCurrent);

                const distance = vDelta.length();
                let gazeTarget;

                if (distance <= speed) {
                    // If <1 step from current waypoint, discard it and move toward next.
                    this.path.shift();

                    // After discarding the last waypoint, exit pathfinding.
                    if (!this.path.length) {
                        this.el.setAttribute("globe-nav-agent", "active: false;");
                        el.emit('navigation-end');
                        return;
                    }

                    vNext.copy(vCurrent);
                    gazeTarget = this.path[0];
                } else {
                    // If still far away from next waypoint, find next position for
                    // the current frame.
                    vNext.copy(vDelta.setLength(speed)).add(vCurrent);
                    gazeTarget = vWaypoint;
                }

                // Look at the next waypoint.
                // gazeTarget.y = vCurrent.y;
                el.object3D.up = new THREE.Vector3().copy(vCurrent).normalize();
                el.object3D.lookAt(gazeTarget);

                vCurrent.copy(vNext);
            },
        });

        /**
         * nav
         *
         * Pathfinding system, using PatrolJS.
         */
        AFRAME.registerSystem('globe-ocean-nav', {
            navMesh: null,
            agents: new Set(),
            init: function () {
                this.navMesh = null;
                this.agents = new Set();
            },

            /**
             * @param {THREE.Geometry} geometry
             */
            setNavMeshGeometry: function (geometry) {
                this.navMesh = new THREE.Mesh(geometry);
                oceanPathfinder.setZoneData(ZONE, threePathfinding.Pathfinding.createZone(geometry));
                Array.from(this.agents).forEach((agent) => agent.updateNavLocation());
            },

            /**
             * @return {THREE.Mesh}
             */
            getNavMesh: function () {
                return this.navMesh;
            },

            /**
             * @param {NavAgent} ctrl
             */
            addAgent: function (ctrl) {
                this.agents.add(ctrl);
            },

            /**
             * @param {NavAgent} ctrl
             */
            removeAgent: function (ctrl) {
                this.agents.delete(ctrl);
            },

            /**
             * @param  {THREE.Vector3} start
             * @param  {THREE.Vector3} end
             * @param  {number} groupID
             * @return {Array<THREE.Vector3>}
             */
            getPath: function (start, end, groupID) {
                return this.navMesh
                    ? groupID === null ? [] : oceanPathfinder.findPath(start, end, ZONE, groupID)
                    : null;
            },

            /**
             * @param {THREE.Vector3} position
             * @return {number}
             */
            getGroup: function (position) {
                return this.navMesh
                    ? oceanPathfinder.getGroup(ZONE, position)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} position
             * @param  {number} groupID
             * @return {Node}
             */
            getNode: function (position, groupID) {
                return this.navMesh
                    ? oceanPathfinder.getClosestNode(position, ZONE, groupID, true)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} start Starting position.
             * @param  {THREE.Vector3} end Desired ending position.
             * @param  {number} groupID
             * @param  {Node} node
             * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.
             * @return {Node} Current node, after step is taken.
             */
            clampStep: function (start, end, groupID, node, endTarget) {
                if (!this.navMesh) {
                    endTarget.copy(end);
                    return null;
                } else if (!node) {
                    endTarget.copy(end);
                    return this.getNode(end, groupID);
                }
                return oceanPathfinder.clampStep(start, end, node, ZONE, groupID, endTarget);
            }
        });

        AFRAME.registerComponent('globe-ocean-nav-mesh', {
            schema: {
                nodeName: {type: 'string'}
            },
            hasLoadedNavMesh: false,
            nodeName: "",
            init: function () {
                this.system = this.el.sceneEl.systems['globe-ocean-nav'];
                this.hasLoadedNavMesh = false;
                this.nodeName = this.data.nodeName;
                this.el.addEventListener('object3dset', this.loadNavMesh.bind(this));
            },

            play: function () {
                if (!this.hasLoadedNavMesh) this.loadNavMesh();
            },

            loadNavMesh: function () {
                var self = this;
                const object = this.el.getObject3D('mesh');
                const scene = this.el.sceneEl.object3D;

                if (!object) return;

                let navMesh;
                object.traverse((node) => {
                    if (node.isMesh &&
                        (!self.nodeName || node.name === self.nodeName)) navMesh = node;
                });

                if (!navMesh) return;

                const navMeshGeometry = navMesh.geometry.clone();
                navMesh.updateWorldMatrix(true, false);
                navMeshGeometry.applyMatrix4(navMesh.matrixWorld);
                this.system.setNavMeshGeometry(navMeshGeometry);
                this.hasLoadedNavMesh = true;
                this.el.setAttribute("visible", "false");
            }
        });

        AFRAME.registerComponent('globe-ocean-nav-agent', {
            schema: {
                destination: {type: 'vec3'},
                active: {default: false},
                speed: {default: 2}
            },
            system: null,
            group: null,
            path: [],
            init: function () {
                this.system = this.el.sceneEl.systems['globe-ocean-nav'];
                this.system.addAgent(this);
                this.group = null;
                this.path = [];
            },
            remove: function () {
                this.system.removeAgent(this);
            },
            update: function () {
                this.path.length = 0;
            },
            updateNavLocation: function () {
                this.group = null;
                this.path = [];
            },
            tick: function (t, dt) {
                const vDest = new THREE.Vector3();
                const vDelta = new THREE.Vector3();
                const vNext = new THREE.Vector3();

                const el = this.el;
                const data = this.data;
                const speed = data.speed * dt / 1000;

                if (!data.active) return;

                // Use PatrolJS pathfinding system to get the shortest path to target.
                if (!this.path.length) {
                    const position = this.el.object3D.position;
                    this.group = this.group || this.system.getGroup(position);
                    this.path = this.system.getPath(position, vDest.copy(data.destination), this.group) || [];
                    el.emit('navigation-start');
                }

                // If no path is found, exit.
                if (!this.path.length) {
                    // console.warn('[nav] Unable to find path to %o.', data.destination);
                    this.el.setAttribute("globe-ocean-nav-agent", "active: false;");
                    el.emit('navigation-end');
                    el.object3D.position.copy(vDest);
                    console.log(el.object3D.position);
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyW"});
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                    this.group = null;
                    return;
                }

                // Current segment is a vector from current position to next waypoint.
                const vCurrent = new THREE.Vector3().copy(el.components['dynamic-body'].body.position);
                const vWaypoint = this.path[0];
                vDelta.subVectors(vWaypoint, vCurrent);

                const distance = vDelta.length();
                let gazeTarget;

                if (distance < 4) {
                    // If <1 step from current waypoint, discard it and move toward next.
                    this.path.shift();

                    // After discarding the last waypoint, exit pathfinding.
                    if (!this.path.length) {
                        this.el.setAttribute("globe-ocean-nav-agent", "active: false;");
                        el.emit('navigation-end');
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyW"});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                        return;
                    }

                    vNext.copy(vCurrent);
                    gazeTarget = this.path[0];
                } else {
                    // If still far away from next waypoint, find next position for
                    // the current frame.
                    vNext.copy(vDelta.setLength(speed)).add(vCurrent);
                    gazeTarget = vWaypoint;
                }

                // Look at the next waypoint.
                // gazeTarget.y = vCurrent.y;
                // |  x  y  z |
                // | ax ay az |
                // | bx by bz |
                const getDeterminant = () => {
                    const a = vCurrent.clone().normalize();
                    const v1 = new THREE.Vector3(0, 0, -1).applyQuaternion(new THREE.Quaternion().copy(el.components['dynamic-body'].body.quaternion));
                    const v2 = gazeTarget.clone().sub(vCurrent.clone()).normalize();

                    // make two vectors for determinant
                    let ax = v1.x;
                    let ay = v1.y;
                    let az = v1.z;
                    let bx = v2.x;
                    let by = v2.y;
                    let bz = v2.z;

                    // make basis matrix for sphere
                    let aVec = new THREE.Vector3().set(ax, ay, az).normalize();
                    let bVec = new THREE.Vector3().set(bx, by, bz).normalize();
                    const basisY = aVec.clone().normalize();
                    const basisZ = a.clone().normalize();
                    const basisX = new THREE.Vector3().crossVectors(basisY, basisZ);
                    const basis = new THREE.Matrix4().makeBasis(basisX, basisY, basisZ).invert();

                    // apply basis matrix
                    aVec = aVec.applyMatrix4(basis);
                    bVec = bVec.applyMatrix4(basis);
                    ax = aVec.x;
                    ay = aVec.y;
                    az = aVec.z;
                    bx = bVec.x;
                    by = bVec.y;
                    bz = bVec.z;

                    let det = ax * by + ay * bz + az * bx - ay * bx - az * by - ax * bz;
                    if (isNaN(det)) {
                        return 0;
                    }
                    if (aVec.dot(bVec) < 0) {
                        det += Math.sign(det);
                    }
                    return det;
                };
                const det = getDeterminant();
                if (det < 0) {
                    if (Math.random() * 0.5 < Math.abs(det)) {
                        el.components['globe-keyboard-controls'].onKeyDown({code: "KeyD", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA", synthetic: true});
                    } else {
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD", synthetic: true});
                    }
                } else if (det > 0) {
                    if (Math.random() * 0.33 < Math.abs(det)) {
                        el.components['globe-keyboard-controls'].onKeyDown({code: "KeyA", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD", synthetic: true});
                    } else {
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA", synthetic: true});
                    }
                } else {
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA", synthetic: true});
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD", synthetic: true});
                }

                if (Math.abs(det) < 0.1) {
                    el.components['globe-keyboard-controls'].onKeyDown({code: "KeyW", synthetic: true});
                } else {
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyW", synthetic: true});
                }
            },
        });

        AFRAME.registerComponent('go-on-land', {
            init: function () {
                this.system = this.el.sceneEl.systems['globe-nav'];
                this.el.addEventListener('click', (e) => {
                    const destination1 = e.detail.intersection.point.clone();

                    const scene = document.querySelector("a-scene");
                    scene.components['coin-purse'].setUnit(unitMap.get(scene.components['coin-purse'].activeUnit));
                    const checkBox = document.querySelector(`#unit-selection-${scene.components['coin-purse'].activeUnit}`);
                    checkBox.click();

                    setTimeout(() => {
                        const scene = document.querySelector("a-scene");
                        const npcs = document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`);
                        if (npcs.length === 0) {
                            const raiderAmount = scene.components['coin-purse'].getRaiderAmount();
                            for (let i = 0; i < raiderAmount; i++) {
                                addNpc(i);
                            }
                        }
                    }, 0);
                    setTimeout(() => {
                        const scene = document.querySelector("a-scene");
                        const npcEls = document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`);
                        npcEls.forEach(npcEl => {
                            npcEl.setAttribute("globe-nav-agent", `active: false; destination: ${destination1.x} ${destination1.y} ${destination1.z}; speed: 2;`);
                        });
                    }, 500);
                    setTimeout(() => {
                        const scene = document.querySelector("a-scene");
                        const npcEls = document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`);
                        const cameraEl = document.querySelector("#camera-rig");
                        cameraEl.setAttribute("look-at-box", `.${scene.components['coin-purse'].getUnit()}`);
                        npcEls.forEach(npcEl => {
                            const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3).add(new THREE.Vector3().random()), destination1.clone().negate());
                            const intersections = raycaster.intersectObject(this.system.getNavMesh());
                            if (intersections[0]) {
                                const destination2 = intersections[0].point.clone();
                                npcEl.setAttribute("globe-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2;`);
                            }
                        });
                    }, 750);
                    setTimeout(() => {
                        const scene = document.querySelector("a-scene");
                        const npcEls = document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`);
                        const cameraEl = document.querySelector("#camera-rig");
                        cameraEl.setAttribute("look-at-box", `.${scene.components['coin-purse'].getUnit()}`);
                        npcEls.forEach(npcEl => {
                            const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3).add(new THREE.Vector3().random()), destination1.clone().negate());
                            const intersections = raycaster.intersectObject(this.system.getNavMesh());
                            if (intersections[0]) {
                                const destination2 = intersections[0].point.clone();
                                npcEl.setAttribute("globe-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2;`);
                            }
                        });
                    }, 1000);
                });
            }
        });

        AFRAME.registerComponent('raze-target', {
            schema: {},
            init: function () {
                this.el.addEventListener("click", () => {
                    this.el.emit("raze");
                });
            },
        });

        AFRAME.registerComponent('go-to-sea', {
            init: function () {
                this.el.addEventListener('click', function (e) {
                    const destination1 = e.detail.intersection.point.clone();

                    const scene = document.querySelector("a-scene");
                    scene.components['coin-purse'].setUnit(inverseUnitMap.get(scene.components['coin-purse'].activeUnit));
                    const checkBox = document.querySelector(`#unit-selection-${scene.components['coin-purse'].activeUnit}`);
                    checkBox.click();

                    setTimeout(() => {
                        const scene = document.querySelector("a-scene");
                        const cameraEl = document.querySelector("#camera-rig");
                        cameraEl.setAttribute("look-at-box", `.${scene.components['coin-purse'].getUnit()}`);
                    }, 0);
                    setTimeout(() => {
                        const scene = document.querySelector("a-scene");
                        const npcs = document.querySelectorAll(`.${unitMap.get(scene.components['coin-purse'].activeUnit)}`);
                        if (npcs.length !== 0) {
                            removeNpc();
                        }
                    }, 1000);
                    setTimeout(() => {
                        const scene = document.querySelector("a-scene");
                        const shipEls = document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`);
                        shipEls.forEach(shipEl => {
                            shipEl.setAttribute("globe-ocean-nav-agent", `active: false; destination: ${destination1.x} ${destination1.y} ${destination1.z}; speed: 2;`);
                        });
                    }, 500);
                    setTimeout(() => {
                        const scene = document.querySelector("a-scene");
                        const shipEls = document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`);
                        shipEls.forEach(shipEl => {
                            shipEl.setAttribute("globe-ocean-nav-agent", `active: true; destination: ${destination1.x} ${destination1.y} ${destination1.z}; speed: 2;`);
                        });
                    }, 1000);
                });
            }
        });
        AFRAME.registerComponent('terrain-tile', {
            schema: {
                type: "string",
                default: ""
            },
            init: function () {
            },
            tick: function () {
                if (!this.data) {
                    return;
                }

                const cameraEl = document.querySelector("#camera-rig");
                let cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());
                cameraPos = cameraPos.normalize();
                let tilePos = new THREE.Vector3();
                tilePos = tilePos.set.apply(tilePos, this.data.split(" "));
                tilePos = tilePos.normalize();

                const cos45 = Math.acos(Math.PI / 4);
                if (cameraPos.dot(tilePos) > cos45) {
                    this.el.setAttribute("visible", "true");
                } else {
                    this.el.setAttribute("visible", "false");
                }

                // auto update clickable
                const className = "clickable";
                if (cameraPos.dot(tilePos) > cos45 && !this.el.classList.contains(className)) {
                    this.el.classList.add(className);
                } else if (!(cameraPos.dot(tilePos) > cos45) && this.el.classList.contains(className)) {
                    this.el.classList.remove(className);
                }
            }
        });

        AFRAME.registerSystem('building', {
            schema: {},
            init: function () {
                this.islandBuildings = new Map();
                this.buildings = [];
                this.updateBuildings = debounce(this.innerUpdateBuildings.bind(this), 1000);
            },
            innerUpdateBuildings: function () {
                this.buildings.forEach(el => {
                    const building = el.components['building'];
                    const group = this.el.sceneEl.systems['globe-nav'].getGroup(el.components['position'].data);
                    const arr = this.islandBuildings.get(group);
                    if (arr) {
                        building.locateNearestBuilding(arr);
                    }
                });
            },
            registerMe: function (el) {
                if (this.el.sceneEl.systems['globe-nav'].navMesh) {
                    const group = this.el.sceneEl.systems['globe-nav'].getGroup(el.components['position'].data);
                    if (this.islandBuildings.has(group)) {
                        this.islandBuildings.get(group).push(el);
                    } else {
                        this.islandBuildings.set(group, [el]);
                    }
                    this.buildings.push(el);
                    this.updateBuildings();
                } else {
                    setTimeout(this.registerMe.bind(this, el), 100);
                }
            },
            unregisterMe: function (el) {
                const group = this.el.sceneEl.systems['globe-nav'].getGroup(el.components['position'].data);
                if (this.islandBuildings.has(group)) {
                    const arr = this.islandBuildings.get(group);
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
                {
                    const arr = this.buildings;
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
            },
        });

        AFRAME.registerComponent('building', {
            schema: {
                type: "string",
                default: "house",
            },
            init: function () {
                this.system.registerMe(this.el);
                const tempType = this.data?.toString()?.toLowerCase() ?? "";
                let buildingTypes;
                switch (tempType) {
                    case "port": {
                        buildingTypes = [
                            "port"
                        ];
                        break;
                    }
                    case "temple": {
                        buildingTypes = [
                            "temple"
                        ];
                        break;
                    }
                    default: {
                        buildingTypes = [
                            "house",
                            "house",
                            "tavern",
                            "workshop",
                        ];
                    }
                }
                this.buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                if (this.buildingType === "house") {
                    const numNpcs = Math.floor(Math.random() * 4) + 1;
                    for (let i = 0; i < numNpcs; i++) {
                        this.el.setAttribute(`npc-spawner__${i}`, "");
                    }
                }
            },
            locateNearestBuilding: function (islandBuildings) {
                const buildingTypes = new Map();
                for (const el of islandBuildings) {
                    const building = el.components['building'];
                    const buildingType = building.buildingType;
                    if (buildingTypes.has(buildingType)) {
                        const arr = buildingTypes.get(buildingType);
                        arr.push(el);
                    } else {
                        const arr = [el];
                        buildingTypes.set(buildingType, arr);
                    }
                }

                this.nearestBuildingType = new Map();
                for (const [buildingType, els] of buildingTypes.entries()) {
                    const nearestBuilding = els.reduce((el, v) => {
                        if (!el) {
                            return v;
                        }

                        const start = new THREE.Vector3().set(this.el.components['position'].data);
                        const endNew = new THREE.Vector3().set(v.components['position'].data);
                        const endOld = new THREE.Vector3().set(el.components['position'].data);
                        const distanceNew = start.distanceTo(endNew);
                        const distanceOld = start.distanceTo(endOld);
                        if (distanceNew < distanceOld) {
                            return v;
                        }
                        return el;
                    }, undefined);
                    if (nearestBuilding) {
                        this.nearestBuildingType.set(buildingType, nearestBuilding);
                    }
                }
                this.el.emit("found-nearest-building");
            },
            remove: function () {
                this.system.unregisterMe(this.el);
            },
        });

        window.spawnNpcsFlag = false;
        AFRAME.registerComponent('npc-spawner', {
            schema: {},
            multiple: true,
            init: function () {
                if (this.el.id) {
                    this.elId = this.el.id;
                } else {
                    this.elId = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
                    this.el.setAttribute("id", this.elId);
                }
                this.currentNpcId = null;
                this.initFiniteStateMachine();
                this.innerInitFiniteStateMachine = this.initFiniteStateMachine.bind(this)
                this.innerTransition = this.transition.bind(this);
                this.innerHandleDead = this.handleDead.bind(this);
                this.el.addEventListener('found-nearest-building', this.innerInitFiniteStateMachine);
                this.el.addEventListener('transition', this.innerTransition);
                this.el.addEventListener('dead', this.innerHandleDead);
            },
            initFiniteStateMachine: function () {
                const building = this.el.components['building'];
                if (!building.nearestBuildingType || this.isReady) {
                    return;
                }
                this.isHome = true;
                this.otherBuildings = new Map();
                for (const [key, value] of building.nearestBuildingType.entries()) {
                    this.otherBuildings.set(key, value);
                }
                if (this.otherBuildings.has('home')) {
                    this.otherBuildings.delete('home');
                }
                this.isReady = true;
                setTimeout(() => {
                    this.transition();
                }, 10_000);
            },
            transition: function (evt) {
                const npcId = evt?.detail ?? null;
                if (!this.isReady) {
                    setTimeout(() => {
                        this.innerTransition(evt);
                    }, 10_000);
                    return;
                }
                if (!window.spawnNpcsFlag) {
                    setTimeout(() => {
                        this.innerTransition(evt);
                    }, 10_000);
                    return;
                }
                if (npcId && npcId !== this.currentNpcId) {
                    return;
                }
                if (this.isHome) {
                    const arr = Array.from(this.otherBuildings.values());
                    this.otherBuilding = arr[Math.floor(Math.random() * arr.length)];
                    if (this.otherBuilding) {
                        this.isHome = false;
                        if (this.currentNpcId) {
                            updateWalkingNpc(this.elId, this.otherBuilding);
                        } else {
                            this.currentNpcId = addWalkingNpc(this.elId, this.el, this.otherBuilding);
                        }
                    }
                } else {
                    this.isHome = true;
                    if (this.currentNpcId) {
                        updateWalkingNpc(this.elId, this.el);
                    } else {
                        this.currentNpcId = addWalkingNpc(this.elId, this.otherBuilding, this.el);
                    }
                    this.otherBuilding = undefined;
                }
            },
            handleDead: function (evt) {
                const npcId = evt?.detail ?? null;
                if (!this.isReady) {
                    setTimeout(() => {
                        this.innerHandleDead(evt);
                    }, 10_000);
                    return;
                }
                if (npcId && npcId !== this.currentNpcId) {
                    return;
                }
                if (npcId && npcId === this.currentNpcId) {
                    this.el.removeAttribute(`npc-spawner__${this.id}`);
                }
            },
            remove: function () {
                this.el.removeEventListener('found-nearest-building', this.innerInitFiniteStateMachine);
                this.el.removeEventListener('transition', this.innerTransition);
            },
        });

        AFRAME.registerComponent('npc-agent', {
            schema: {
                building: {type: 'selector'}
            },
            init: function () {
                this.innerBeginTransition = this.beginTransition.bind(this);
                this.innerHandleDead = this.handleDead.bind(this);
                this.el.addEventListener("navigation-end", this.innerBeginTransition);
                this.el.addEventListener("dead", this.innerHandleDead);
            },
            beginTransition: function () {
                this.data.building.emit('transition', this.el.id);
            },
            handleDead: function () {
                this.data.building.emit('dead', this.el.id);
            },
            remove: function () {
                this.el.removeEventListener("navigation-end", this.innerBeginTransition);
                this.el.removeEventListener("dead", this.innerHandleDead);
            },
        });

        AFRAME.registerComponent('npc-faction', {
            schema: {
                type: 'string',
                default: ''
            },
        });

        AFRAME.registerComponent('npc-attack', {
            schema: {
                range: {type: 'number', default: 10},
                melee: {type: 'boolean', default: false},
            },
            init: function () {
                this.attackEls = [];
                this.innerAttack = this.attack.bind(this);
                this.innerBeginAttack = this.beginAttack.bind(this);
                this.innerMeleeCharge = this.meleeCharge.bind(this);
                this.innerMeleeReturn = this.meleeReturn.bind(this);
                this.innerNavigationBegin = this.navigationBegin.bind(this);
                this.innerNavigationEnd = this.navigationEnd.bind(this);
                this.el.addEventListener('npc-attack', this.innerAttack);
                this.el.addEventListener('npc-begin-attack', this.innerBeginAttack);
                this.el.addEventListener('npc-melee-charge', this.innerMeleeCharge);
                this.el.addEventListener('npc-melee-return', this.innerMeleeReturn);
                if (this.data.melee) {
                    this.el.addEventListener('navigation-start', this.innerNavigationBegin);
                    this.el.addEventListener('navigation-end', this.innerNavigationEnd);
                }

                this.tickCounter = 0;
                this.findTickCount = 120;
                this.charge = false;
                this.immediateCharge = false;
                this.chargeOrigin = this.el.object3D.position.clone();
            },
            remove: function () {
                this.el.removeEventListener('npc-attack', this.innerAttack);
                this.el.removeEventListener('npc-begin-attack', this.innerBeginAttack);
                this.el.removeEventListener('npc-melee-charge', this.innerMeleeCharge);
                this.el.removeEventListener('npc-melee-return', this.innerMeleeReturn);
                if (this.data.melee) {
                    this.el.removeEventListener('navigation-start', this.innerNavigationBegin);
                    this.el.removeEventListener('navigation-end', this.innerNavigationEnd);
                }
                this.attackEls = [];
            },
            tick: function () {
                if (this.tickCounter < this.findTickCount) {
                    this.tickCounter += 1;
                    return;
                }
                this.tickCounter = 0;

                const pos = this.el.object3D.position;
                for (const el of this.attackEls) {
                    const p = el.object3D.position;
                    const distance = pos.distanceTo(p);
                    if (distance < this.data.range) {
                        if (this.data.melee && distance > 1) {
                            if (this.chargeOrigin.distanceTo(p) < this.data.range) {
                                this.el.emit('npc-melee-charge', el);
                                return;
                            }
                        } else {
                            this.el.emit('npc-begin-attack', el);
                            return;
                        }
                    }
                }
                if (this.data.melee) {
                    this.el.emit('npc-melee-return', this.chargeOrigin.clone());
                }
            },
            attack: function (evt) {
                this.attackEls = evt.detail;
            },
            beginAttack: function (evt) {
                const target = evt.detail;
                addProjectile(this.el, target);
            },
            meleeCharge: function (evt) {
                const target = evt.detail;
                const destination2 = target.object3D.position.clone();
                this.el.setAttribute("globe-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2;`);
                this.charge = true;
                this.immediateCharge = true;
            },
            meleeReturn: function (evt) {
                const destination2 = evt.detail.clone();
                this.el.setAttribute("globe-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2;`);
                this.charge = true;
                this.immediateCharge = true;
            },
            navigationBegin: function () {
                if (this.data.melee && this.charge && this.immediateCharge) {
                    this.immediateCharge = false;
                    return;
                }
                if (this.data.melee && this.charge && !this.immediateCharge) {
                    this.charge = false;
                }
            },
            navigationEnd: function () {
                if (this.data.melee && this.charge && !this.immediateCharge) {
                    this.tickCounter = this.findTickCount;
                    this.charge = false;
                    return;
                }
                if (this.data.melee && !this.charge && !this.immediateCharge) {
                    this.chargeOrigin = this.el.object3D.position.clone();
                }
            },
        });

        AFRAME.registerComponent('projectile-flight', {
            schema: {
                target: {type: 'selector'},
                speed: {type: 'number', default: 10},
            },
            init: function () {
            },
            tick: function (t, dt) {
                const vDelta = new THREE.Vector3();
                const vNext = new THREE.Vector3();

                const el = this.el;
                const data = this.data;
                const speed = data.speed * dt / 1000;

                if (!this.data.target) {
                    this.el.emit('miss');
                    this.el.parentNode.removeChild(this.el);
                    return;
                }

                const object3D = this.el.object3D;


                // Current segment is a vector from current position to next waypoint.
                const vCurrent = el.object3D.position;
                let vWaypoint = this.data.target.object3D.position.clone();
                vWaypoint = vWaypoint.add(vWaypoint.clone().normalize());
                vDelta.subVectors(vWaypoint, vCurrent);

                const distance = vDelta.length();
                let gazeTarget;

                if (distance <= speed) {
                    vNext.copy(vCurrent);
                    gazeTarget = vWaypoint;

                    this.data.target.emit('hit', 40);
                    this.el.parentNode.removeChild(this.el);
                } else {
                    // If still far away from next waypoint, find next position for
                    // the current frame.
                    vNext.copy(vDelta.setLength(speed)).add(vCurrent);
                    gazeTarget = vWaypoint;
                }

                // Look at the next waypoint.
                // gazeTarget.y = vCurrent.y;
                el.object3D.up = new THREE.Vector3().copy(vCurrent).normalize();
                el.object3D.lookAt(gazeTarget);

                vCurrent.copy(vNext);
            },
        });

        AFRAME.registerComponent('cannon-ball-flight', {
            schema: {
                speed: {type: 'number', default: 10},
            },
            init: function () {
            },
        });

        AFRAME.registerComponent('health', {
            schema: {
                health: { type: 'number', default: 100 }
            },
            init: function () {
                this.innerHandleHit = this.handleHit.bind(this);
                this.el.addEventListener('hit', this.innerHandleHit);
            },
            remove: function () {
                this.el.removeEventListener('hit', this.innerHandleHit);
            },
            handleHit: function (evt) {
                const hit = evt.detail;
                const oldHealth = this.data.health;
                const newHealth = this.data.health - hit;
                this.el.setAttribute("health", `health: ${newHealth}`);

                if (newHealth <= 0 && oldHealth > 0) {
                    this.el.emit('dead');
                    this.el.parentNode.removeChild(this.el);
                }
            },
        });

        AFRAME.registerComponent('networked-health', {
            schema: {
            },
            init: function () {
                this.innerHandleHit = this.handleHit.bind(this);
                this.el.addEventListener('hit', this.innerHandleHit);
            },
            remove: function () {
                this.el.removeEventListener('hit', this.innerHandleHit);
            },
            handleHit: function (evt) {
                const hit = evt.detail;
                const senderId = this.el.components['networked'].data.owner;
                const networkId = this.el.components['networked'].data.networkId;
                NAF.connection.sendDataGuaranteed(senderId, "networkedHealth", {
                    networkId,
                    hit,
                });
            },
        });

        AFRAME.registerComponent('ship-health', {
            schema: {
                health: { type: 'number', default: 400 }
            },
            init: function () {
                this.innerHandleHit = this.handleHit.bind(this);
                this.el.addEventListener('hit', this.innerHandleHit);
            },
            remove: function () {
                this.el.removeEventListener('hit', this.innerHandleHit);
            },
            handleHit: function (evt) {
                const hit = evt.detail;
                const newHealth = this.data.health - hit;
                this.el.setAttribute("ship-health", `health: ${newHealth}`);
                this.el.components['sound__hit'].playSound();

                if (newHealth <= 0) {
                    this.el.emit('dead');
                }
            },
        });

        AFRAME.registerComponent('networked-ship-health', {
            schema: {
            },
            init: function () {
                this.innerHandleHit = this.handleHit.bind(this);
                this.el.addEventListener('hit', this.innerHandleHit);
            },
            remove: function () {
                this.el.removeEventListener('hit', this.innerHandleHit);
            },
            handleHit: function (evt) {
                const hit = evt.detail;
                const senderId = this.el.parentEl.components['networked'].data.owner;
                const networkId = this.el.parentEl.components['networked'].data.networkId;
                NAF.connection.sendDataGuaranteed(senderId, "networkedShipHealth", {
                    networkId,
                    hit,
                });

                this.el.parentEl.components['sound__hit'].playSound();
            },
        });
        AFRAME.registerComponent('networked-ship-cannonball', {
            schema: {},
            init: function () {
                this.innerHandleFire = this.handleFire.bind(this);
                this.el.addEventListener('firing', this.innerHandleFire);
            },
            remove: function () {
                this.el.removeEventListener('firing', this.innerHandleFire);
            },
            handleFire: function (evt) {
                this.el.components['sound__fire'].playSound();
            }
        })
        AFRAME.registerComponent("ship-death", {
            schema: {},
            init: function () {
                this.innerHandleDeath = this.handleDeath.bind(this);
                this.el.addEventListener('dead', this.innerHandleDeath);
            },
            remove: function () {
                this.el.removeEventListener('dead', this.innerHandleDeath);
            },
            handleDeath: function () {
                this.el.setAttribute("despawn", "");
                this.el.setAttribute("globe-gravity", "ship: true; buoyancy: false;");
            },
        });

        AFRAME.registerComponent("spawn-gold", {
            schema: {},
            init: function () {
                this.innerHandleDead = this.handleDead.bind(this);
                this.innerHandleRaze = this.handleRaze.bind(this);
                this.el.addEventListener('dead', this.innerHandleDead);
                this.el.addEventListener('raze', this.innerHandleRaze);
            },
            remove: function () {
                this.el.removeEventListener('dead', this.innerHandleDead);
                this.el.removeEventListener('raze', this.innerHandleRaze);
            },
            handleDead: function () {
                for (let i = 0; i < 3; i++) {
                    addGoldCoin(this.el);
                }
            },
            handleRaze: function () {
                for (let i = 0; i < 10; i++) {
                    addGoldCoin(this.el);
                }
            },
        });

        AFRAME.registerComponent("gold-coin-movement", {
            schema: {},
            init: function () {
                this.interval = setTimeout(this.applyImpulse.bind(this), 100);
            },
            remove: function () {
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }
            },
            applyImpulse: function () {
                if (this.el.body) {
                    const getRandom1to1 = () => (Math.random() * 2 - 1);
                    const bPos = this.el.body.position.clone();
                    const impulse = new CANNON.Vec3().set(getRandom1to1(), getRandom1to1(), getRandom1to1());
                    const bPosNorm = bPos.clone();
                    bPosNorm.normalize();
                    impulse.normalize();
                    impulse.vadd(bPosNorm, impulse);
                    impulse.scale(300, impulse);
                    const bPosOffset = new CANNON.Vec3().set(getRandom1to1(), getRandom1to1(), getRandom1to1());
                    bPosOffset.normalize();
                    bPosOffset.scale(0.5, bPosOffset);
                    this.el.body.applyImpulse(impulse, bPosOffset);
                    this.interval = setTimeout(this.removeGoldCoin.bind(this), 30_000);
                } else {
                    this.interval = setTimeout(this.applyImpulse.bind(this), 100);
                }
            },
            removeGoldCoin: function () {
                this.el.parentNode.removeChild(this.el);
            },
        });

        AFRAME.registerComponent("handle-shadow-parameter", {
            schema: {},
            tick: function () {
                const cameraEl = document.querySelector("#camera-rig");
                const cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());

                const size = 30;
                const shadowCameraBottom = -cameraPos.z - size;
                const shadowCameraTop = -cameraPos.z + size;
                const shadowCameraLeft = cameraPos.x - size;
                const shadowCameraRight = cameraPos.x + size;

                const el = this.el;
                el.setAttribute("light", {
                    shadowCameraBottom,
                    shadowCameraTop,
                    shadowCameraLeft,
                    shadowCameraRight,
                });
            },
        });

        function addTemplate(templateId, charModelId, instanceModelId) {
            const scene = document.querySelector("a-scene");

            const str = characterModels.get(charModelId);

            const rootGoldCoin = document.createElement("a-entity");
            if (charModelId === "SHIP") {
                const dataEl = document.createElement("a-entity");
                dataEl.setAttribute("class", "data");
                dataEl.setAttribute("scale", "0.1 0.1 0.1");
                dataEl.setAttribute("rotation", "0 -90 0");
                dataEl.setAttribute("gltf-model", str);
                dataEl.setAttribute("networked-ship-health", "");
                dataEl.setAttribute("cannonball-collider", "");
                rootGoldCoin.setAttribute("sound__fire", "src: #fire; poolSize: 40; volume: 5;");
                rootGoldCoin.setAttribute("sound__hit", "src: #hit; poolSize: 40; volume: 5;");
                rootGoldCoin.setAttribute("networked-ship-cannonball", "");
                rootGoldCoin.appendChild(dataEl);
            } else {
                rootGoldCoin.setAttribute("gltf-model", str);
            }

            if (charModelId === "PERSON") {
                rootGoldCoin.setAttribute("npc-faction", "native");
                rootGoldCoin.setAttribute("npc-finder", "active: false;");
                rootGoldCoin.setAttribute("networked-health", "");
            }

            if (charModelId === "WARRIOR") {
                rootGoldCoin.setAttribute("npc-faction", "player");
                rootGoldCoin.setAttribute("npc-finder", "active: false;");
                rootGoldCoin.setAttribute("networked-health", "");
            }

            const a = (() => {
                const assets = document.querySelector("a-assets");
                if (assets) {
                    return assets;
                } else {
                    const a1 = document.createElement("a-assets");
                    scene.appendChild(a1);
                    return a1;
                }
            })();

            const t = (() => {
                const template = a.querySelector(`#${templateId}`);
                if (template) {
                    return null;
                } else {
                    const t1 = document.createElement("template");
                    t1.setAttribute("id", templateId);
                    return [t1];
                }
            })();

            if (t) {
                t[0].content.appendChild(rootGoldCoin);
                a.appendChild(t[0]);

                if (charModelId === "SHIP") {
                    if (!NAF.schemas.hasTemplate(`#${templateId}`)) {
                        NAF.schemas.add({
                            template: `#${templateId}`,
                            components: [
                                {
                                    component: 'position',
                                    requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.001)
                                },
                                {
                                    component: 'rotation',
                                    requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.5)
                                },
                                {
                                    selector: '.data',
                                    component: 'gltf-model',
                                },
                                {
                                    selector: '.data',
                                    component: 'scale',
                                },
                                {
                                    selector: '.data',
                                    component: 'rotation',
                                },
                            ]
                        });
                    }
                } else {
                    if (!NAF.schemas.hasTemplate(`#${templateId}`)) {
                        NAF.schemas.add({
                            template: `#${templateId}`,
                            components: [
                                {
                                    component: 'position',
                                    requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.001)
                                },
                                {
                                    component: 'rotation',
                                    requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.5)
                                },
                                'gltf-model',
                            ]
                        });
                    }
                }
            }
        }

        function addGoldCoin(startEl) {
            const scene = document.querySelector("a-scene");

            const rootGoldCoin = document.createElement("a-entity");
            const id = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
            rootGoldCoin.setAttribute("id", id);
            rootGoldCoin.setAttribute("class", "gold-coin");
            const pos = startEl.object3D.getWorldPosition(new THREE.Vector3());
            pos.add(pos.clone().normalize());
            rootGoldCoin.setAttribute("position", `${pos.x} ${pos.y} ${pos.z}`);
            rootGoldCoin.setAttribute("rotation", "0 0 0");
            rootGoldCoin.setAttribute("dynamic-body", "shape: sphere; sphereRadius: 0.5; mass: 100");
            rootGoldCoin.setAttribute("globe-gravity", "");
            rootGoldCoin.setAttribute("collision-filter", "group: gold-coin; ");
            rootGoldCoin.setAttribute("gold-coin-movement", "");
            rootGoldCoin.setAttribute("shadow", "");

            if (characterModels.has("GOLD_COIN")) {
                const str = characterModels.get("GOLD_COIN");

                // add graphics
                rootGoldCoin.setAttribute("gltf-model", str);
                rootGoldCoin.setAttribute("networked", "template: #gold-coin-template; attachTemplateToLocal: false;");

                scene.components['coin-purse'].addGoldCoins(1);
            } else {
                const modelGold = document.createElement("a-sphere");
                modelGold.setAttribute("scale", "0.1 0.1 0.1");
                modelGold.setAttribute("position", "0 0 0");

                rootGoldCoin.appendChild(modelGold);
            }

            scene.appendChild(rootGoldCoin);

            return id;
        }

        function addProjectile(startEl, destinationEl) {
            const scene = document.querySelector("a-scene");

            const rootProjectile = document.createElement("a-entity");
            const id = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
            rootProjectile.setAttribute("id", id);
            rootProjectile.setAttribute("class", "projectile");
            rootProjectile.setAttribute("projectile-flight", `target: #${destinationEl.id}`);
            const pos = startEl.object3D.position.clone().add(startEl.object3D.position.clone().normalize());
            rootProjectile.setAttribute("position", `${pos.x} ${pos.y} ${pos.z}`);
            rootProjectile.setAttribute("rotation", "0 0 0");
            rootProjectile.setAttribute("shadow", "");

            if (characterModels.has("ARROW")) {
                const str = characterModels.get("ARROW");

                // add graphics
                rootProjectile.setAttribute("gltf-model", str);
                rootProjectile.setAttribute("networked", "template: #arrow-template; attachTemplateToLocal: false;");
            } else {
                const modelArrow = document.createElement("a-sphere");
                modelArrow.setAttribute("scale", "0.1 0.1 0.1");
                modelArrow.setAttribute("position", "0 0 0");

                rootProjectile.appendChild(modelArrow);
            }

            scene.appendChild(rootProjectile);

            return id;
        }

        function addCannonBall(pos, velocity) {
            const scene = document.querySelector("a-scene");

            const rootProjectile = document.createElement("a-entity");
            const id = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
            rootProjectile.setAttribute("id", id);
            rootProjectile.setAttribute("class", "cannonball");
            rootProjectile.setAttribute("position", `${pos.x} ${pos.y} ${pos.z}`);
            rootProjectile.setAttribute("rotation", "0 0 0");
            rootProjectile.setAttribute("shadow", "");
            rootProjectile.setAttribute("dynamic-body", "shape: sphere; sphereRadius: 0.5; mass: 5");
            rootProjectile.setAttribute("globe-gravity", "");
            rootProjectile.setAttribute("collision-filter", "group: cannonball; collidesWith: default");
            rootProjectile.setAttribute("initial-velocity", velocity);
            rootProjectile.setAttribute("despawn", "");

            if (characterModels.has("CANNONBALL")) {
                const str = characterModels.get("CANNONBALL");

                // add graphics
                rootProjectile.setAttribute("gltf-model", str);
                rootProjectile.setAttribute("networked", "template: #cannonball-template; attachTemplateToLocal: false;");
            } else {
                const modelArrow = document.createElement("a-sphere");
                modelArrow.setAttribute("scale", "0.1 0.1 0.1");
                modelArrow.setAttribute("position", "0 0 0");

                rootProjectile.appendChild(modelArrow);
            }

            scene.appendChild(rootProjectile);

            return id;
        }

        function addWalkingNpc(buildingId, buildingEl, destinationEl) {
            const scene = document.querySelector("a-scene");

            const rootNpc = document.createElement("a-entity");
            const id = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
            rootNpc.setAttribute("id", id);
            rootNpc.setAttribute("class", "walking-npc");
            const destination2 = destinationEl.components['position'].data;
            const pos = buildingEl.components['position'].data;
            rootNpc.setAttribute("position", `${pos.x} ${pos.y} ${pos.z}`);
            rootNpc.setAttribute("rotation", "0 0 0");
            rootNpc.setAttribute("npc-agent", `building: #${buildingId}`);
            rootNpc.setAttribute("npc-faction", "native");
            rootNpc.setAttribute("npc-finder", "active: false;");
            rootNpc.setAttribute("health", "");
            rootNpc.setAttribute("spawn-gold", "");
            rootNpc.setAttribute("globe-nav-agent", `active: false;`);
            // rootNpc.setAttribute("sound__scream", "src: #scream; poolSize: 40; volume: 5;");
            rootNpc.setAttribute("shadow", "");
            setTimeout(() => {
                rootNpc.setAttribute("globe-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 1;`);
            }, 2000);

            if (characterModels.has("PERSON")) {
                const str = characterModels.get("PERSON");

                // add graphics
                rootNpc.setAttribute("gltf-model", str);
                rootNpc.setAttribute("networked", "template: #person-template; attachTemplateToLocal: false;");
            } else {
                const modelNpc = document.createElement("a-sphere");
                modelNpc.setAttribute("scale", "0.1 0.1 0.1");
                modelNpc.setAttribute("position", "0 0 0");

                rootNpc.appendChild(modelNpc);
            }

            scene.appendChild(rootNpc);

            return id;
        }

        function updateWalkingNpc(npcId, destinationEl) {
            const rootNpc = document.querySelector(`#${npcId}`);
            const destination2 = destinationEl.components['position'].data;
            rootNpc.setAttribute("globe-nav-agent", `active: false;`);
            setTimeout(() => {
                rootNpc.setAttribute("globe-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 1;`);
            }, 2000);
        }

        function removeWalkingNpc(npcId) {
            const scene = document.querySelector("a-scene");
            const a = document.querySelector(`#${npcId}`);
            scene.removeChild(a);
        }

        function addNpc(i) {
            const scene = document.querySelector("a-scene");

            const rootNpc = document.createElement("a-entity");
            rootNpc.setAttribute("class", `${scene.components['coin-purse'].activeUnit}`);
            rootNpc.setAttribute("globe-nav-agent", "");
            rootNpc.setAttribute("position", "0 0 0");
            rootNpc.setAttribute("rotation", "0 0 0");
            rootNpc.setAttribute("npc-faction", "player");
            rootNpc.setAttribute("npc-finder", "active: true;");
            rootNpc.setAttribute("npc-attack", `range: 10; melee: false;`);
            rootNpc.setAttribute("health", "");
            rootNpc.setAttribute("shadow", "");
            // rootNpc.setAttribute("sound__scream", "src: #scream; poolSize: 40; volume: 5;");
            rootNpc.setAttribute("outline-pass", "");

            if (characterModels.has("WARRIOR")) {
                const str = characterModels.get("WARRIOR");
                rootNpc.setAttribute("gltf-model", str);
                rootNpc.setAttribute("networked", "template: #warrior-template; attachTemplateToLocal: false;");
            } else {
                const modelNpc = document.createElement("a-sphere");
                modelNpc.setAttribute("scale", "0.1 0.1 0.1");
                modelNpc.setAttribute("position", "0 0 0");
                rootNpc.appendChild(modelNpc);
            }

            const positionNpc = document.createElement("a-entity");
            positionNpc.setAttribute("class", `${scene.components['coin-purse'].activeUnit}-position`);
            positionNpc.setAttribute("position", "0 0 -5");
            rootNpc.appendChild(positionNpc);

            scene.appendChild(rootNpc);
        }

        function removeNpc() {
            const scene = document.querySelector("a-scene");
            const arr = Array.from(document.querySelectorAll(`.${unitMap.get(scene.components['coin-purse'].activeUnit)}`));
            arr.forEach(a => scene.removeChild(a));
        }

        function addTerrain(item) {
            const [str, collidable, navmesh, ocean, oceanNavmesh, vertex] = JSON.parse(item);
            const rootTerrain = document.createElement("a-entity");
            rootTerrain.setAttribute("class", "clickable");
            rootTerrain.setAttribute("gltf-model", str);
            rootTerrain.addEventListener("model-loaded", buildBoundsTree);
            rootTerrain.setAttribute("position", "0 0 0");
            rootTerrain.setAttribute("shadow", "");
            rootTerrain.setAttribute("terrain-tile", (vertex ?? []).join(" "));
            if (oceanNavmesh) {
                rootTerrain.setAttribute("go-to-sea", "");
                rootTerrain.setAttribute("globe-ocean-nav-mesh", "");
            } else if (navmesh) {
                rootTerrain.setAttribute("globe-nav-mesh", "");
            } else if (ocean) {
                // do nothing
            } else if (collidable) {
                rootTerrain.setAttribute("static-body", "shape: none;");
                rootTerrain.setAttribute("globe-trimesh", "");
                rootTerrain.setAttribute("go-on-land", "");
            } else {
                rootTerrain.setAttribute("static-body", "shape: none;");
                rootTerrain.setAttribute("globe-trimesh", "");
            }

            const scene = document.querySelector("a-scene");
            scene.appendChild(rootTerrain);
        }

        function clearTerrain() {
            const scene = document.querySelector("a-scene");
            const arr = Array.from(document.querySelectorAll("[terrain-tile]"));
            arr.forEach(a => scene.removeChild(a));
        }

        var characterModels = new Map();
        function addCharacterModel(item) {
            const {
                data: str, type
            } = JSON.parse(item);

            characterModels.set(type, str);

            switch (type) {
                case "WARRIOR": {
                    addTemplate("warrior-template", "WARRIOR", "warrior-model");
                    break;
                }
                case "PERSON": {
                    addTemplate("person-template", "PERSON", "person-model");
                    break;
                }
                case "ARROW": {
                    addTemplate("arrow-template", "ARROW", "arrow-model");
                    break;
                }
                case "CANNONBALL": {
                    addTemplate("cannonball-template", "CANNONBALL", "cannonball-model");
                    break;
                }
                case "GOLD_COIN": {
                    addTemplate("gold-coin-template", "GOLD_COIN", "gold-coin-model");
                    break;
                }
                case "SHIP": {
                    addTemplate("ship-template", "SHIP", "ship-model");
                    break;
                }
            }
        }

        function addHouse(item) {
            const {
                type, point, lookAt
            } = JSON.parse(item);

            const rootHouse = document.createElement("a-entity");
            rootHouse.setAttribute("position", `${point[0]} ${point[1]} ${point[2]}`);
            rootHouse.setAttribute("terrain-tile", "");
            rootHouse.setAttribute("building", type.toString().toLowerCase());

            const rootModel = document.createElement("a-entity");
            rootModel.setAttribute("globe-lod", characterModels.get(type));
            if (type === "PORT") {
                rootModel.setAttribute("scale", "0.1 0.1 0.1");
                rootModel.setAttribute("rotation", "90 0 0");
                rootModel.setAttribute("position", "1.35 -1.1 -0.5");
            } else {
                rootModel.setAttribute("scale", "1 1 1");
                rootModel.setAttribute("rotation", "90 0 0");
                rootModel.setAttribute("position", "0 0 0");
            }
            rootHouse.appendChild(rootModel);

            const lod0 = document.createElement("a-entity");
            lod0.setAttribute("class", `lod0 clickable${type === "PORT" ? " port" : ""}`);
            lod0.setAttribute("raze-target", "");
            lod0.setAttribute("spawn-gold", "");
            lod0.setAttribute("shadow", "");
            rootModel.appendChild(lod0);

            const lod1 = document.createElement("a-entity");
            lod1.setAttribute("class", `lod1 clickable${type === "PORT" ? " port" : ""}`);
            lod1.setAttribute("raze-target", "");
            lod1.setAttribute("spawn-gold", "");
            lod1.setAttribute("shadow", "");
            rootModel.appendChild(lod1);

            const lod2 = document.createElement("a-entity");
            lod2.setAttribute("class", `lod2 clickable${type === "PORT" ? " port" : ""}`);
            lod2.setAttribute("raze-target", "");
            lod2.setAttribute("spawn-gold", "");
            lod2.setAttribute("shadow", "");
            rootModel.appendChild(lod2);

            const scene = document.querySelector("a-scene");
            scene.appendChild(rootHouse);

            rootHouse.object3D.up = new THREE.Vector3(point[0], point[1], point[2]).normalize();
            rootHouse.object3D.lookAt(new THREE.Vector3(lookAt[0], lookAt[1], lookAt[2]));
        }

        window.shipModelStr = "";
        window.shipSpawnPoint = new THREE.Vector3(0, 0, 100);

        function addShip(item) {
            const scene = document.querySelector("a-scene");

            const {
                data: str, point
            } = JSON.parse(item);

            window.shipModelStr = str;
            window.shipSpawnPoint = new THREE.Vector3(point[0], point[1], point[2]);

            const rootShip = document.createElement("a-entity");
            rootShip.setAttribute("class", `${scene.components['coin-purse'].activeUnit} clickable`);
            rootShip.setAttribute("dynamic-body", "shape: sphere; sphereRadius: 1; mass: 100");
            rootShip.setAttribute("collision-filter", "group: ship; collidesWith: default");
            rootShip.setAttribute("globe-gravity", "ship: true;");
            rootShip.setAttribute("globe-keyboard-controls", "enabled: true; fly: true");
            rootShip.setAttribute("ship-health", "");
            rootShip.setAttribute("ship-death", "");
            rootShip.setAttribute("fire-cannons", "");
            rootShip.setAttribute("firing-cannons", "");
            rootShip.setAttribute("shadow", "");
            rootShip.setAttribute("position", `${point[0]} ${point[1]} ${point[2]}`);
            rootShip.setAttribute("rotation", "0 0 0");
            rootShip.setAttribute("outline-pass", "");
            rootShip.setAttribute("sound__fire", "src: #fire; poolSize: 40; volume: 5;");
            rootShip.setAttribute("sound__hit", "src: #hit; poolSize: 40; volume: 5;");

            const rootModel = document.createElement("a-entity");
            rootModel.setAttribute("class", "data");
            rootModel.setAttribute("gltf-model", str);
            rootModel.addEventListener("model-loaded", buildBoundsTree);
            rootModel.setAttribute("go-to-sea", "");
            rootModel.setAttribute("scale", "0.1 0.1 0.1");
            rootModel.setAttribute("rotation", "0 -90 0");
            rootModel.setAttribute("setup-cannons", "");
            rootShip.appendChild(rootModel);
            rootShip.setAttribute("networked", "template: #ship-template; attachTemplateToLocal: false;");

            const rootPosition = document.createElement("a-entity");
            rootPosition.setAttribute("class", `${scene.components['coin-purse'].activeUnit}-position`);
            rootPosition.setAttribute("position", "0 0 5");
            rootShip.appendChild(rootPosition);

            scene.appendChild(rootShip);
            const cameraEl = document.querySelector("#camera-rig");
            cameraEl.setAttribute("look-at-box", `.${scene.components['coin-purse'].getUnit()}`);
        }

        function addClientSecret(item) {
            const {
                roomId,
                clientSecret,
            } = JSON.parse(item);

            window.gmRoomId = roomId;

            const scene = document.querySelector("a-scene");

            scene.setAttribute("networked-scene", `room: ${roomId}; adapter: ws; debug: true;`);
        }

        function spawnNpcsNow() {
            window.spawnNpcsFlag = true;
        }

        function onConnect() {
            document.body.addEventListener("clientConnected", function (evt) {
                console.log("CLIENT CONNECTED", evt.detail.clientId);
            });
            document.body.addEventListener("clientDisconnected", function (evt) {
                console.log("CLIENT DISCONNECTED", evt.detail.clientId);
            });

            NAF.connection.subscribeToDataChannel('isHost', function (sender, dataType, data, targetId) {
                const hostSpanEle = document.getElementById("host-span");
                hostSpanEle.textContent = "HOST";
                spawnNpcsNow();
            });

            NAF.connection.subscribeToDataChannel('networkedHealth', function (sender, dataType, data, targetId) {
                const {
                    networkId,
                    hit,
                } = data;
                const entity = NAF.entities.entities[networkId];
                if (entity) {
                    entity.emit("hit", hit);
                }
            });

            NAF.connection.subscribeToDataChannel('networkedShipHealth', function (sender, dataType, data, targetId) {
                const {
                    networkId,
                    hit,
                } = data;
                const entity = NAF.entities.entities[networkId];
                if (entity) {
                    entity.emit("hit", hit);
                }
            });

            NAF.connection.subscribeToDataChannel('networkedShipCannonball', function (sender, dataType, data, targetId) {
                const {
                    networkId
                } = data;
                const entity = NAF.entities.entities[networkId];
                if (entity) {
                    entity.emit("firing");
                }
            });

            NAF.connection.subscribeToDataChannel('networkedSound', function (sender, dataType, data, targetId) {
                const {
                    networkId,
                    sound,
                } = data;
                const entity = NAF.entities.entities[networkId];
                if (entity && entity.components[sound]) {
                    entity.components[sound].playSound();
                }
            });

            let micEnabled = true;
            const micBtnEle = document.getElementById("mic-btn");

            micBtnEle.addEventListener('click', function () {
                NAF.connection.adapter.enableMicrophone(!micEnabled);
                micEnabled = !micEnabled;
                micBtnEle.textContent = micEnabled ? 'Mute Mic' : 'Unmute Mic';
            });
        }

        AFRAME.registerComponent('align-with-projection', {
            schema: {
                offset: {
                    type: "vec3",
                    default: "0 0 -5",
                },
                rotation: {
                    type: "vec3",
                    default: "0 0 0",
                },
                scale: {
                    type: "vec3",
                    default: "1 1 1",
                },
            },
            tick: function () {
                const scene = document.querySelector("a-scene");
                const camera = scene.camera;

                // do nothing if it is mobile
                const cameraLookControlsEl = document.querySelector('[globe-look-controls]');

                // align with camera in desktop
                const position = new THREE.Vector3(0, 0, 0);
                const rotation = new THREE.Quaternion(0, 0, 0, 1);
                const scale = new THREE.Vector3(1, 1, 1);
                if (!(this.el.sceneEl?.renderer?.xr?.isPresenting || cameraLookControlsEl.components['globe-look-controls']?.magicWindowControls?.enabled)) {
                    camera.projectionMatrix.decompose(position, rotation, scale);
                }
                const aspect = scene.canvas.width / scene.canvas.height;
                const offset = new THREE.Vector3(aspect, 1, 1).multiply(this.data.offset);
                position.add(offset).multiply(scale);
                if (!(this.el.sceneEl?.renderer?.xr?.isPresenting || cameraLookControlsEl.components['globe-look-controls']?.magicWindowControls?.enabled)) {
                    camera.getWorldQuaternion(rotation);
                }
                position.applyQuaternion(rotation);
                this.el.object3D.position.copy(position);
                this.el.object3D.quaternion.copy(rotation.multiply(new THREE.Quaternion().setFromEuler(new THREE.Euler(
                    THREE.MathUtils.degToRad(this.data.rotation.x),
                    THREE.MathUtils.degToRad(this.data.rotation.y),
                    THREE.MathUtils.degToRad(this.data.rotation.z)
                ))));
                this.el.object3D.scale.copy(this.data.scale);
            }
        });

        AFRAME.registerComponent('respawn', {
            schema: {},
            init: function () {
                this.respawnTick = +new Date() + 10_000;
                this.activeRespawn = false;
            },
            tick: function () {
                // respawn 5 seconds after no more ships
                const time = +new Date();
                if (this.activeRespawn) {
                    if (this.respawnTick < time) {
                        this.activeRespawn = false;
                        const scene = document.querySelector("a-scene");
                        scene.components['coin-purse'].shipCount = 1;
                        scene.components['coin-purse'].buyShips();
                    }
                } else {
                    const ships = [];
                    const activeUnits = [
                        'ship-1',
                        'ship-2',
                        'ship-3',
                    ];
                    for (const activeUnit of activeUnits) {
                        const s = Array.from(document.querySelectorAll(`.${activeUnit}`));
                        ships.push(...s);
                    }
                    if (ships.length === 0 && !!window.shipModelStr) {
                        this.respawnTick = time + 5_000;
                        this.activeRespawn = true;
                    }
                }
            },
        });

        AFRAME.registerComponent('setup-cannons', {
            dependencies: ['gltf-model'],
            schema: {},
            init: function () {
                this.el.addEventListener("model-loaded", (e) => {
                    const meshes = [];
                    e.detail.model.traverse((x) => {
                        if (x.isGroup && x.name.includes("Canon")) {
                            meshes.push(x);
                        }
                    });
                    const leftCannons = meshes.filter(x => x.position.z <= 0);
                    const rightCannons = meshes.filter(x => x.position.z > 0);
                    leftCannons.forEach(x => {
                        const entity = document.createElement("a-entity");
                        entity.setAttribute("position", x.position);
                        entity.setAttribute("class", "left-cannon");
                        this.el.appendChild(entity);

                        const positionEntity = document.createElement("a-entity");
                        positionEntity.setAttribute("position", new THREE.Vector3(0, 0, 50).add(x.position));
                        positionEntity.setAttribute("class", "left-cannon-position");
                        this.el.appendChild(positionEntity);
                    });
                    rightCannons.forEach(x => {
                        const entity = document.createElement("a-entity");
                        entity.setAttribute("position", x.position);
                        entity.setAttribute("class", "right-cannon");
                        this.el.appendChild(entity);

                        const positionEntity = document.createElement("a-entity");
                        positionEntity.setAttribute("position", new THREE.Vector3(0, 0, -50).add(x.position));
                        positionEntity.setAttribute("class", "right-cannon-position");
                        this.el.appendChild(positionEntity);
                    });
                });
            }
        });

        AFRAME.registerComponent('select-cannon-side', {
            schema: {
                selector: {
                    type: "string",
                    default: ""
                },
            },
            init: function () {
                this.innerSelectCannonSide = this.selectCannonSide.bind(this);
                this.el.addEventListener("click", this.innerSelectCannonSide);
            },
            remove: function () {
                this.el.removeEventListener("click", this.innerSelectCannonSide);
            },
            tick: function () {
                const scene = document.querySelector("a-scene");
                const unit = scene.components['coin-purse'].getUnit();
                const visible = unit.startsWith("ship");
                this.el.setAttribute("visible", visible);
            },
            selectCannonSide: function () {
                if (this.data.selector === "none-cannon") {
                    const cameraEl = document.querySelector("#camera-rig");
                    const selector = `.${scene.components['coin-purse'].getUnit()}`;
                    const firstClick = cameraEl.getAttribute("look-at-box") !== selector;
                    if (firstClick) {
                        cameraEl.setAttribute("look-at-box", selector);
                    }
                } else {
                    const cameraEl = document.querySelector("#camera-rig");
                    const selector = `.${scene.components['coin-purse'].getUnit()} .${this.data.selector}`;
                    const firstClick = cameraEl.getAttribute("look-at-box") !== selector;
                    if (firstClick) {
                        cameraEl.setAttribute("look-at-box", selector);
                    } else {
                        const ships = document.querySelectorAll(`.${scene.components['coin-purse'].getUnit().split(":", 2)[0]}`);
                        ships.forEach(s => {
                            s.emit("fire-cannons", this.data.selector);
                        });
                    }
                }
            },
        });

        AFRAME.registerComponent('fire-cannons', {
            schema: {},
            init: function () {
                this.innerFireCannons = this.fireCannons.bind(this);
                this.el.addEventListener("fire-cannons", this.innerFireCannons);
                this.lastFire = 0;
            },
            remove: function () {
                this.el.removeEventListener("fire-cannons", this.innerFireCannons);
            },
            fireCannons: function (e) {
                // fire every 2 seconds
                const dateValue = +new Date();
                if (this.lastFire < dateValue) {
                    this.lastFire = dateValue + 2_000;
                    this.el.emit('firing-cannons', e.detail);
                }
            },
        });

        AFRAME.registerComponent('firing-cannons', {
            schema: {},
            init: function () {
                this.innerFiringCannons = this.firingCannons.bind(this);
                this.el.addEventListener("firing-cannons", this.innerFiringCannons);
            },
            remove: function () {
                this.el.removeEventListener("firing-cannons", this.innerFiringCannons);
            },
            firingCannons: function (e) {
                const selector = `.${scene.components['coin-purse'].getUnit().split(":", 2)[0]} .${e.detail}`;
                const cannons = Array.from(document.querySelectorAll(selector));
                cannons.forEach(cannon => {
                    const worldPosition = cannon.object3D.getWorldPosition(new THREE.Vector3());
                    const velocity = new THREE.Vector3(0, 0, e.detail.includes("left") ? -300 : 300).applyQuaternion(cannon.object3D.getWorldQuaternion(new THREE.Quaternion()));

                    addCannonBall(worldPosition, velocity);
                });

                // make sound for all 4 cannons.
                for (let i = 0; i < 4; i++) {
                    this.el.components['sound__fire'].playSound();

                    const networkId = this.el.components['networked'].data.networkId;
                    NAF.connection.broadcastDataGuaranteed("networkedShipCannonball", {
                        networkId,
                    });
                }
            },
        });

        AFRAME.registerComponent("initial-velocity", {
            schema: {
                type: "vec3",
                default: "0 0 0",
            },
            init: function () {
                setTimeout(() => {
                    this.el.body.applyImpulse(new CANNON.Vec3(this.data.x, this.data.y, this.data.z), new CANNON.Vec3(0, 0, 0));
                }, 10);
            },
        });

        AFRAME.registerComponent("despawn", {
            schema: {
                type: "number",
                default: 10,
            },
            init: function () {
                this.deleteTime = +new Date() + this.data * 1000;
            },
            tick: function () {
                if (+new Date() > this.deleteTime) {
                    this.el.parentElement.removeChild(this.el);
                }
            },
        });

        AFRAME.registerComponent("port-show", {
            schema: {},
            tick: function () {
                const scene = document.querySelector("a-scene");
                const activeUnit = scene.components['coin-purse'].activeUnit;
                const ship = scene.querySelector(`.${activeUnit}`);
                if (ship) {
                    const position = ship.object3D.getWorldPosition(new THREE.Vector3());
                    const ports = Array.from(document.querySelectorAll(".port"));
                    const port = ports.find(x => {
                        const xPos = x.object3D.getWorldPosition(new THREE.Vector3());
                        const distance = xPos.distanceTo(position);
                        return distance < 5;
                    });
                    const visible = !!port;
                    this.el.setAttribute("visible", visible);
                    if (visible && !this.el.classList.contains("clickable")) {
                        this.el.classList.add("clickable");
                    }
                    if (!visible && this.el.classList.contains("clickable")) {
                        this.el.classList.remove("clickable");
                    }
                } else {
                    const visible = true;
                    this.el.setAttribute("visible", visible);
                    if (visible && !this.el.classList.contains("clickable")) {
                        this.el.classList.add("clickable");
                    }
                }
            },
        });

        AFRAME.registerComponent("cannonball-collider", {
            schema: {},
            init: function () {
                this.innerCollision = this.collision.bind(this);
            },
            tick: function () {
                const shipPosition = this.el.object3D.getWorldPosition(new THREE.Vector3());
                const cannonballs = Array.from(document.querySelectorAll(".cannonball"));
                cannonballs.forEach((cannonball) => {
                    const cannonballPosition = cannonball.object3D.getWorldPosition(new THREE.Vector3());
                    if (shipPosition.distanceTo(cannonballPosition) < 1.5) {
                        this.innerCollision();
                    }
                });
            },
            collision: function () {
                this.el.emit("hit", 10);
            },
        });

        AFRAME.registerComponent('coin-purse', {
            schema: {},
            init: function () {
                this.activeUnit = 'ship-1';
                this.goldCoins = 30;
                this.shipCount = 0;
                this.raiderCount = 0;
                this.raiderAmount = new Map([
                    ['raider-1', 10],
                    ['raider-2', 0],
                    ['raider-3', 0],
                ]);
                this.updateUi();
            },
            updateUi: function () {
                const goldAmount = document.querySelector("#gold-amount");
                const shipAmount = document.querySelector("#ship-amount");
                const raiderAmount = document.querySelector("#raider-amount");
                goldAmount.innerText = this.goldCoins;
                shipAmount.innerText = this.shipCount;
                raiderAmount.innerText = this.raiderCount;
            },
            addGoldCoins: function (goldCoins) {
                this.goldCoins += goldCoins;
                this.updateUi();
            },
            addShip: function () {
                const ships = Array.from(scene.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`));
                const existingShips = ships.length;
                if (this.goldCoins >= 30 && this.shipCount + existingShips < 5) {
                    this.shipCount += 1;
                    this.goldCoins -= 30;
                    this.updateUi();
                }
            },
            removeShip: function () {
                if (this.shipCount > 0) {
                    this.shipCount -= 1;
                    this.goldCoins += 30;
                    this.updateUi();
                }
            },
            getRaiderAmount: function () {
                return this.raiderAmount.get(unitMap.get(this.activeUnit));
            },
            setRaiderAmount: function (amount) {
                this.raiderAmount.set(unitMap.get(this.activeUnit), amount);
            },
            addRaider: function () {
                if (this.goldCoins >= 30 && this.raiderCount + this.getRaiderAmount() < 50) {
                    this.raiderCount += 10;
                    this.goldCoins -= 30;
                    this.updateUi();
                }
            },
            removeRaider: function () {
                if (this.raiderCount > 0) {
                    this.raiderCount -= 10;
                    this.goldCoins += 30;
                    this.updateUi();
                }
            },
            setUnit: function(u) {
                this.activeUnit = u;
            },
            getUnit: function () {
                const postfix = this.activeUnit.startsWith("ship") ? ":first-of-type" : "";
                return this.activeUnit + postfix;
            },
            buyShips: function () {
                const numShips = this.shipCount;
                this.shipCount = 0;
                const numRaiders = this.raiderCount;
                this.raiderCount = 0;
                this.updateUi();

                const ships = Array.from(document.querySelectorAll(this.activeUnit));
                const point = ships.reduce((acc, x) => acc.add(x.object3D.position), new THREE.Vector3());
                if (point.length() === 0) {
                    point.copy(window.shipSpawnPoint);
                } else {
                    point.divideScalar(ships.length);
                }

                for (let i = 0; i < numShips; i++) {
                    addShip(JSON.stringify({data: window.shipModelStr, point: [point.x, point.y, point.z]}));
                }

                const initialRaiderAmount = this.getRaiderAmount();
                this.setRaiderAmount(initialRaiderAmount + numRaiders);
            }
        });

        function openStoreMenu() {
            const menu1 = document.querySelector("#over-world-menu");
            const menu2 = document.querySelector("#store-menu");
            menu1.style.visibility = "collapse";
            menu1.style.display = "none";
            menu2.style.visibility = "visible";
            menu2.style.display = "inline-block";
        }

        function closeStoreMenu() {
            const menu1 = document.querySelector("#over-world-menu");
            const menu2 = document.querySelector("#store-menu");
            menu1.style.visibility = "visible";
            menu1.style.display = "inline-block";
            menu2.style.visibility = "collapse";
            menu2.style.display = "none";
        }

        function decrementShipAmount() {
            const scene = document.querySelector("a-scene");
            scene.components['coin-purse'].removeShip();
        }

        function incrementShipAmount() {
            const scene = document.querySelector("a-scene");
            scene.components['coin-purse'].addShip();
        }

        function decrementRaiderAmount() {
            const scene = document.querySelector("a-scene");
            scene.components['coin-purse'].removeRaider();
        }

        function incrementRaiderAmount() {
            const scene = document.querySelector("a-scene");
            scene.components['coin-purse'].addRaider();
        }

        function handleCheckbox(t) {
            const scene = document.querySelector("a-scene");
            scene.components['coin-purse'].setUnit(t.value);

            setTimeout(() => {
                const scene = document.querySelector("a-scene");
                const cameraEl = document.querySelector("#camera-rig");
                const ships = Array.from(scene.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`));
                const existingShips = ships.length;
                if (existingShips) {
                    cameraEl.setAttribute("look-at-box", `.${scene.components['coin-purse'].getUnit()}`);
                }
            }, 0);
        }

        function buyShips() {
            const scene = document.querySelector("a-scene");
            scene.components['coin-purse'].buyShips();
        }
    </script>
    <script type="module">
        import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
        import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
        import { OutlinePass } from "three/addons/postprocessing/OutlinePass.js";
        import { OutputPass } from "three/addons/postprocessing/OutputPass.js";

        AFRAME.registerSystem('npc-finder', {
            schema: {},
            init: function () {
                this.islandNpcList = new Map();
                this.npcs = [];
                this.findNpc = this.findNpc.bind(this);
            },
            registerMe: function (el) {
                const pos = el.object3D.position;
                if (pos.length() === 0) {
                    setTimeout(this.registerMe.bind(this, el), 100);
                    return;
                }

                if (this.el.sceneEl.systems['globe-nav'].navMesh) {
                    const group = this.el.sceneEl.systems['globe-nav'].getGroup(pos);
                    if (this.islandNpcList.has(group)) {
                        this.islandNpcList.get(group).push(el);
                    } else {
                        this.islandNpcList.set(group, [el]);
                    }
                    this.npcs.push(el);
                } else {
                    setTimeout(this.registerMe.bind(this, el), 100);
                }
            },
            unregisterMe: function (el) {
                const group = this.el.sceneEl.systems['globe-nav'].getGroup(el.object3D.position);
                if (this.islandNpcList.has(group)) {
                    const arr = this.islandNpcList.get(group);
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
                {
                    const arr = this.npcs;
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
            },
            findNpc: function (checkingNpc) {
                const factionName = checkingNpc.components['npc-faction'].data;
                const position = new THREE.Vector3().copy(checkingNpc.object3D.position);
                const radius = 20;
                const group = this.el.sceneEl.systems['globe-nav'].getGroup(position);
                if (this.islandNpcList.has(group)) {
                    const list = this.islandNpcList.get(group);
                    const els = list.filter(x => {
                        const pos = x.object3D.position;
                        const dist = position.distanceTo(pos);
                        return dist <= radius;
                    });
                    const filtered = els.filter(x => x && x.components['npc-faction'].data !== factionName);
                    return filtered.sort((a, b) => {
                        const distA = new THREE.Vector3().copy(a.object3D.position).distanceTo(position);
                        const distB = new THREE.Vector3().copy(b.object3D.position).distanceTo(position);
                        return distA - distB;
                    });
                }
                return [];
            },
        });

        AFRAME.registerComponent('npc-finder', {
            schema: {
                active: {type: 'boolean', default: false},
            },
            init: function () {
                this.system = this.el.sceneEl.systems['npc-finder'];
                this.system.registerMe(this.el);
                this.tickCounter = 0;
                this.findTickCount = 120;
                this.innerHandleNavigationGroupChange = this.navigationGroupChange.bind(this);
                this.innerHandleNavigationGroupChanged = this.navigationGroupChanged.bind(this);
                this.el.addEventListener("navigation-group-change", this.innerHandleNavigationGroupChange);
                this.el.addEventListener("navigation-group-changed", this.innerHandleNavigationGroupChanged);
            },
            tick: function () {
                if (!this.data.active) {
                    return;
                }

                if (this.tickCounter < this.findTickCount) {
                    this.tickCounter += 1;
                    return;
                }
                this.tickCounter = 0;

                const els = this.system.findNpc(this.el);
                this.el.emit('npc-attack', els);
            },
            remove: function () {
                this.system.unregisterMe(this.el);
                this.tickCounter = null;
                this.findTickCount = null;
                this.el.removeEventListener("navigation-group-change", this.innerHandleNavigationGroupChange);
                this.el.removeEventListener("navigation-group-changed", this.innerHandleNavigationGroupChanged);
            },
            navigationGroupChange: function () {
                this.system.unregisterMe(this.el);
            },
            navigationGroupChanged: function () {
                this.system.registerMe(this.el);
            },
        });

        AFRAME.registerSystem('outline-pass', {
            schema: {
                edgeStrength: { type: 'number', default: 2 },
                edgeGlow: { type: 'number', default: 1 },
            },
            init: function () {
                this.t = 0;
                this.dt = 0;
                this.selectedObjects = [];
                // this.outlinePassFactory();

                // this.innerResizeOutlinePass = this.resizeOutlinePass.bind(this);
                // window.addEventListener("resize", this.innerResizeOutlinePass);
            },
            remove: function () {
                // window.removeEventListener("resize", this.innerResizeOutlinePass);
            },
            resizeOutlinePass: function () {
                const sceneEl = document.querySelector("a-scene");
                if (!sceneEl.renderer || !sceneEl.camera) {
                    const cameraActiveHandler = function () {
                        sceneEl.removeEventListener('camera-set-active', cameraActiveHandler);
                        this.resizeOutlinePass.call(this);
                    }.bind(this);
                    sceneEl.addEventListener('camera-set-active', cameraActiveHandler);
                    return;
                }

                const renderer = sceneEl.renderer;
                const size = renderer.getDrawingBufferSize(new THREE.Vector2());
                this.composer.setSize(size.x, size.y);
                this.outlinePass.setSize(size.x, size.y);
            },
            outlinePassFactory: function () {
                const sceneEl = document.querySelector("a-scene");
                if (!sceneEl.renderer || !sceneEl.camera) {
                    const cameraActiveHandler = function () {
                        sceneEl.removeEventListener('camera-set-active', cameraActiveHandler);
                        this.outlinePassFactory.call(this);
                    }.bind(this);
                    sceneEl.addEventListener('camera-set-active', cameraActiveHandler);
                    return;
                }

                const scene = sceneEl.object3D;
                const renderer = sceneEl.renderer;
                const camera = sceneEl.camera;

                const compose = new EffectComposer(renderer);
                this.composer = compose;

                const renderPass = new RenderPass(scene, camera);
                compose.addPass(renderPass);

                const outlinePass = new OutlinePass(renderer.getDrawingBufferSize(new THREE.Vector2()), scene, camera, this.selectedObjects);
                outlinePass.selectedObjects = this.selectedObjects;
                compose.addPass(outlinePass);

                const params = this.data;
                outlinePass.edgeStrength = params.edgeStrength;
                outlinePass.edgeGlow = params.edgeGlow;
                outlinePass.visibleEdgeColor.set(0x00ff00);
                outlinePass.hiddenEdgeColor.set(0x00ff00);
                this.outlinePass = outlinePass;

                const outputPass = new OutputPass();
                compose.addPass(outputPass);

                this.bind();
            },
            /**
             * Record the timestamp for the current frame.
             * @param {number} t
             * @param {number} dt
             */
            tick: function (t, dt) {
                this.t = t;
                this.dt = dt;
            },
            /**
             * Binds the EffectComposer to the A-Frame render loop.
             * (This is the hacky bit.)
             */
            bind: function () {
                const renderer = this.sceneEl.renderer;
                const render = renderer.render;
                const system = this;
                let isDigest = false;

                renderer.render = function () {
                    if (isDigest) {
                        render.apply(this, arguments);
                    } else {
                        isDigest = true;
                        system.composer.render(system.dt);
                        isDigest = false;
                    }
                };
            },
        });

        AFRAME.registerComponent('outline-pass', {
            schema: {},
            init: function () {
                this.system = this.el.sceneEl.systems['outline-pass'];
                this.system.selectedObjects.push(this.el.object3D);
            },
            remove: function () {
                const idx = this.system.selectedObjects.indexOf(this.el.object3D);
                if (idx >= 0) {
                    this.system.selectedObjects.splice(idx, 1);
                }
            },
        });
    </script>
    <style>
        a-scene {
            width: 100%;
            aspect-ratio: 1;
        }
        #dom-overlay {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: none;
        }
        #my-interface {
            pointer-events: visible;
        }
        .host-span {
            border-radius: 8px;
            pointer-events: none;
            display: inline-block;
        }
        body {
            margin: 0;
        }
    </style>
</head>
<body>
    <a-scene onclick="window.musicPlayer.start();" coin-purse respawn physics="driver: local; gravity: 0 0 0;" globe-nav globe-ocean-nav embedded fog shadow="enabled: true" outline-pass id="scene" webxr="referenceSpaceType: local; requiredFeatures: local;" embedded inspector="url: https://cdn.jsdelivr.net/gh/aframevr/aframe-inspector@master/dist/aframe-inspector.min.js">
        <a-assets>
            <template id="avatar-template">
                <a-entity class="avatar" networked-audio-source>
                </a-entity>
            </template>
            <audio id="fire" src="/sounds/FireSFX.m4a" preload="auto"></audio>
            <audio id="hit" src="/sounds/WoodHitSFX.m4a" preload="auto"></audio>
<!--            <audio id="scream" src="/sounds/WilhelmScreamSFX.mp3"></audio>-->
        </a-assets>
        <a-sphere color="black" radius="0.01" id="cursor" port-show></a-sphere>
        <a-entity light="type: ambient; color: #CCC"></a-entity>
        <a-entity light="type: directional; color: #EEE; intensity: 0.8; castShadow: true; shadowCameraBottom: -150; shadowCameraTop: 150; shadowCameraLeft: -150; shadowCameraRight: 150; shadowCameraNear: -150; shadowCameraFar: 150; shadowMapWidth: 1024; shadowMapHeight: 1024;" position="0 1 0" handle-shadow-parameter></a-entity>
        <a-entity light="type: directional; color: #EEE; intensity: 0.15" position="0 -1 0"></a-entity>
        <a-entity id="camera-rig" position="0 105 5" networked="template: #avatar-template; attachTemplateToLocal: false;">
            <a-entity camera globe-look-controls="mouseEnabled: false; touchEnabled: false;" position="0 1.6 0" cursor-updater cursor="rayOrigin: mouse" raycaster="far: 50; interval: 100; objects: .clickable">
                <a-entity align-with-projection="offset: 0.25 0.2 -0.5; rotation: 0 0 0" port-show html="cursor:#cursor;html:#my-interface" class="clickable"></a-entity>
                <a-entity laser-controls="hand: left;" raycaster="far: 50; interval: 100; objects: .clickable"></a-entity>
                <a-entity laser-controls="hand: right;" raycaster="far: 50; interval: 100; objects: .clickable"></a-entity>
                <a-entity id="left-cannon-fire" align-with-projection="offset: -0.25 -0.2 -0.5; rotation: 0 90 0; scale: 0.03 0.03 0.03" gltf-model="/meshes/Cannon.glb" class="clickable" select-cannon-side="selector: left-cannon"></a-entity>
                <a-entity id="right-cannon-fire" align-with-projection="offset: 0.25 -0.2 -0.5; rotation: 0 -90 0; scale: 0.03 0.03 0.03" gltf-model="/meshes/Cannon.glb" class="clickable" select-cannon-side="selector: right-cannon"></a-entity>
                <a-entity id="none-cannon-fire" align-with-projection="offset: 0 -0.2 -0.5; rotation: 0 0 0; scale: 0.015 0.015 0.015" gltf-model="/meshes/Helm.glb" class="clickable" select-cannon-side="selector: none-cannon"></a-entity>
            </a-entity>
        </a-entity>
    </a-scene>
    <div id="dom-overlay">
        <section id="my-interface" style="display: inline-block; background: lavenderblush; position: absolute; left: -9999px; color: #333; border-radius: 1em; padding: 1em; margin: 0; accent-color: hotpink;">
            <div class="actions">
                <button id="mic-btn" type="button" class="button">Mute Mic</button>
                <span id="host-span" class="host-span">CLIENT</span>
            </div>
            <div class="actions" id="over-world-menu" style="visibility: collapse; display: none">
                <button onclick="openStoreMenu()">Shop</button>
            </div>
            <div class="actions" id="store-menu">
                <button onclick="closeStoreMenu()" style="visibility: collapse; display: none">Exit</button>
                <fieldset>
                    <legend>Gold Amount</legend>
                    <label style="width: 50px; display: inline-block">Gold</label>
                    <label style="width: 50px; display: inline-block; text-align: right; padding: 8px" id="gold-amount">0</label>
                </fieldset>
                <fieldset>
                    <legend>Purchases</legend>
                    <label style="width: 50px; display: inline-block">Ships</label>
                    <button onclick="decrementShipAmount()">-</button>
                    <label style="width: 50px; display: inline-block; text-align: right; padding: 8px" id="ship-amount">0</label>
                    <button onclick="incrementShipAmount()">+</button>
                    <br/>
                    <label style="width: 50px; display: inline-block">Raiders</label>
                    <button onclick="decrementRaiderAmount()">-</button>
                    <label style="width: 50px; display: inline-block; text-align: right; padding: 8px" id="raider-amount">0</label>
                    <button onclick="incrementRaiderAmount()">+</button>
                    <br/>
                    <button onclick="buyShips()">Buy</button>
                </fieldset>
                <fieldset>
                    <legend>Units</legend>
                    <input onclick="handleCheckbox(this)" id="unit-selection-ship-1" type="radio" name="unit-selection" value="ship-1" checked><label for="unit-selection-ship-1">Ship 1</label>
                    <input onclick="handleCheckbox(this)" id="unit-selection-raider-1" type="radio" name="unit-selection" value="raider-1"><label for="unit-selection-ship-1">Raider 1</label>
                    <br/>
                    <input onclick="handleCheckbox(this)" id="unit-selection-ship-2" type="radio" name="unit-selection" value="ship-2"><label for="unit-selection-ship-2">Ship 2</label>
                    <input onclick="handleCheckbox(this)" id="unit-selection-raider-2" type="radio" name="unit-selection" value="raider-2"><label for="unit-selection-raider-2">Raider 2</label>
                    <br/>
                    <input onclick="handleCheckbox(this)" id="unit-selection-ship-3" type="radio" name="unit-selection" value="ship-3"><label for="unit-selection-ship-3">Ship 3</label>
                    <input onclick="handleCheckbox(this)" id="unit-selection-raider-3" type="radio" name="unit-selection" value="raider-3"><label for="unit-selection-raider-3">Raider 3</label>
                </fieldset>
            </div>
        </section>
    </div>
</body>
</html>
