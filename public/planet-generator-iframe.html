<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Planet Generator</title>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <!-- Import ThreeJS 0.154.0 and our Octree lib-->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/",
                "threejs-octree": "/threeoctree.js"
            }
        }
    </script>
    <script src="/aframe-v1.5.0.js"></script>
    <script src="/aframe-physics-system.js"></script>
    <script src="/aframe-extras.min.js"></script>
    <script src="/aframe-physics-extras.min.js"></script>
    <script src="/three-pathfinding.umd.js"></script>
    <script src="/three-to-cannon.umd.js"></script>
    <script src="/aframe-fps-counter-component.min.js"></script>
    <script src="/aframe-look-at-billboard-component.js"></script>
    <script src="/instanced-mesh.min.js"></script>
    <script src="/socket.io.slim.js"></script>
    <script src="/easyrtc/easyrtc.js"></script>
    <script src="/networked-aframe.js"></script>
    <script type="application/javascript">
        const PLANET_SIZE = 100;

        function debounce(function_, wait = 100, options = {}) {
            if (typeof function_ !== 'function') {
                throw new TypeError(`Expected the first parameter to be a function, got \`${typeof function_}\`.`);
            }

            if (wait < 0) {
                throw new RangeError('`wait` must not be negative.');
            }

            // TODO: Deprecate the boolean parameter at some point.
            const {immediate} = typeof options === 'boolean' ? {immediate: options} : options;

            let storedContext;
            let storedArguments;
            let timeoutId;
            let timestamp;
            let result;

            function run() {
                const callContext = storedContext;
                const callArguments = storedArguments;
                storedContext = undefined;
                storedArguments = undefined;
                result = function_.apply(callContext, callArguments);
                return result;
            }

            function later() {
                const last = Date.now() - timestamp;

                if (last < wait && last >= 0) {
                    timeoutId = setTimeout(later, wait - last);
                } else {
                    timeoutId = undefined;

                    if (!immediate) {
                        result = run();
                    }
                }
            }

            const debounced = function (...arguments_) {
                if (storedContext && this !== storedContext) {
                    throw new Error('Debounced method called with different contexts.');
                }

                storedContext = this; // eslint-disable-line unicorn/no-this-assignment
                storedArguments = arguments_;
                timestamp = Date.now();

                const callNow = immediate && !timeoutId;

                if (!timeoutId) {
                    timeoutId = setTimeout(later, wait);
                }

                if (callNow) {
                    result = run();
                }

                return result;
            };

            debounced.clear = () => {
                if (!timeoutId) {
                    return;
                }

                clearTimeout(timeoutId);
                timeoutId = undefined;
            };

            debounced.flush = () => {
                if (!timeoutId) {
                    return;
                }

                debounced.trigger();
            };

            debounced.trigger = () => {
                result = run();

                debounced.clear();
            };

            return debounced;
        }

        AFRAME.registerComponent('globe-lod', {
            schema: {
                default: "",
            },
            counter: 60,
            update: function () {
                const data = this.data.split("|");

                const lod0 = this.el.querySelector(".lod0");
                const lod1 = this.el.querySelector(".lod1");
                const lod2 = this.el.querySelector(".lod2");
                if (!lod0 || !lod1 || !lod2) {
                    return;
                }
                lod0.setAttribute("gltf-model", data[0]);
                lod1.setAttribute("gltf-model", data[1]);
                lod2.setAttribute("gltf-model", data[2]);
            },
            tick: function () {
                if (this.counter > 0) {
                    this.counter -= 1;
                    return;
                }
                this.counter = 60;

                const object3D = this.el.object3D;
                // @ts-ignore
                const pos = object3D.getWorldPosition(new THREE.Vector3());

                const cameraEl = document.querySelector("#camera-rig");
                // @ts-ignore
                const cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());

                const distance = pos.distanceTo(cameraPos);

                const lod0 = this.el.querySelector(".lod0");
                const lod1 = this.el.querySelector(".lod1");
                const lod2 = this.el.querySelector(".lod2");
                if (!lod0 || !lod1 || !lod2) {
                    return;
                }
                if (distance >= 40) {
                    lod0.setAttribute("visible", "false");
                    lod1.setAttribute("visible", "false");
                    lod2.setAttribute("visible", "false");
                } else if (distance >= 20) {
                    lod0.setAttribute("visible", "false");
                    lod1.setAttribute("visible", "false");
                    lod2.setAttribute("visible", "true");
                } else if (distance >= 10) {
                    lod0.setAttribute("visible", "false");
                    lod1.setAttribute("visible", "true");
                    lod2.setAttribute("visible", "false");
                } else if (distance >= 0) {
                    lod0.setAttribute("visible", "true");
                    lod1.setAttribute("visible", "false");
                    lod2.setAttribute("visible", "false");
                }
            }
        });

        AFRAME.registerComponent('globe-gravity', {
            schema: {
                ship: {type: 'boolean', default: false}
            },
            tick: function () {
                const object3D = this.el.object3D;
                const trueUpDistance = object3D.getWorldPosition(new THREE.Vector3());
                const trueUp = trueUpDistance.clone().normalize();
                const currentUp = new THREE.Vector3(0, 1, 0).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                const currentForward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));;
                const currentRight = new THREE.Vector3(1, 0, 0).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                const diffUp = trueUp.clone().sub(currentUp.clone());

                // apply gravity force
                const gravityForce = this.el.body.mass * 10;
                this.el.body.applyForce(new CANNON.Vec3(-trueUp.x, -trueUp.y, -trueUp.z).scale(gravityForce), new CANNON.Vec3(0, 0, 0));

                // apply drag
                this.el.body.applyForce(this.el.body.velocity.clone().scale(-25), new CANNON.Vec3(0, 0, 0));

                if (this.data.ship) {
                    // apply sideways tilt force
                    const sidewaysTilt = this.el.body.velocity.clone().scale(100).dot(currentRight.clone());
                    const tiltForce = new CANNON.Vec3(currentRight.x, currentRight.y, currentRight.z).scale(sidewaysTilt);
                    const tiltPoint = new CANNON.Vec3(currentUp.x, currentUp.y, currentUp.z);
                    this.el.body.applyForce(tiltForce.clone(), tiltPoint.clone());
                    this.el.body.applyForce(tiltForce.clone().scale(-1), tiltPoint.clone().scale(-1));

                    // apply up right force
                    const springForce = 300;
                    const rotateForce = new CANNON.Vec3(diffUp.x, diffUp.y, diffUp.z).scale(springForce);
                    const rotatePoint = new CANNON.Vec3(currentUp.x, currentUp.y, currentUp.z);
                    const dragForce = this.el.body.angularVelocity.clone().cross(rotatePoint.clone()).scale(100);
                    this.el.body.applyForce(rotateForce.clone().vsub(dragForce), rotatePoint.clone());
                    this.el.body.applyForce(rotateForce.clone().vsub(dragForce).scale(-1), rotatePoint.clone().scale(-1));

                    // apply horizontal drag
                    const horizontalRotatePoint = new CANNON.Vec3(currentForward.x, currentForward.y, currentForward.z);
                    const horizontalDragForce = this.el.body.angularVelocity.clone().cross(horizontalRotatePoint.clone()).scale(100);
                    this.el.body.applyForce(horizontalDragForce.clone().scale(-1), horizontalRotatePoint.clone());
                    this.el.body.applyForce(horizontalDragForce.clone(), horizontalRotatePoint.clone().scale(-1));

                    if (trueUpDistance.length() < PLANET_SIZE + 1) {
                        const trueUpMagnitude = -(trueUpDistance.length() - PLANET_SIZE - 1);
                        const trueUpForce = new CANNON.Vec3(trueUp.x, trueUp.y, trueUp.z).scale(trueUpMagnitude * 1000);
                        this.el.body.applyForce(trueUpForce, new CANNON.Vec3(0, 0, 0));
                    }
                }
            }
        });

        AFRAME.registerComponent('globe-trimesh', {
            schema: {},
            init: function () {
                this.el.addEventListener('model-loaded', () => {
                    const obj = this.el.getObject3D('mesh');
                    const result = threeToCannon.getShapeParameters(obj, { type: threeToCannon.ShapeType.MESH });
                    // @ts-ignore
                    const body = (this.el.components['static-body'].body);
                    body.shapes.splice(0, body.shapes.length);
                    body.shapeOffsets.splice(0, body.shapeOffsets.length)
                    body.shapeOrientations.splice(0, body.shapeOrientations.length)
                    if (result !== null) {
                        const {
                            offset,
                            orientation,
                            params: {
                                // @ts-ignore
                                vertices,
                                // @ts-ignore
                                indices,
                            },
                        } = result;
                        const shape = new CANNON.Trimesh(vertices, indices);
                        // @ts-ignore
                        this.el.components['static-body'].addShape(shape, offset, orientation);
                    }
                });
            }
        });

        AFRAME.registerComponent('look-at-box', {
            schema: {
                type: "string",
                default: "#box",
            },
            init: function () {
                this.dtSumTickSize = 5000;
                this.dtSum = this.dtSumTickSize;
                this.heightDiff = 5;
                this.heightDiffLerp = 5;
            },
            tick: function (t, dt) {
                // get elements
                const box = Array.from(document.querySelectorAll(`${this.data}`)).map(el => el.object3D);
                const boxPos = Array.from(document.querySelectorAll(`${this.data}-position`)).map(el => el.object3D);
                if (!box || !boxPos) {
                    return;
                }

                // get position
                const boxWorldPos = new THREE.Vector3();
                box.forEach(b => boxWorldPos.add(b.getWorldPosition(new THREE.Vector3())));
                boxWorldPos.divideScalar(box.length);
                const boxPosWorldPos = new THREE.Vector3();
                boxPos.forEach(b => boxPosWorldPos.add(b.getWorldPosition(new THREE.Vector3())));
                boxPosWorldPos.divideScalar(boxPos.length);

                // get info
                const upVector = boxPosWorldPos.clone().sub(new THREE.Vector3(0, 0, 0)).normalize();
                const object3D = this.el.object3D;
                const objectWorldPos = object3D.getWorldPosition(new THREE.Vector3());
                const height = boxPosWorldPos.clone().sub(new THREE.Vector3(0, 0, 0)).length();

                // update info
                const quaternion = new THREE.Quaternion().setFromUnitVectors(objectWorldPos.clone().normalize(), boxPosWorldPos.clone().normalize());
                const slerp = new THREE.Quaternion().slerp(quaternion, 0.03);
                let destination1 = objectWorldPos.clone().normalize().multiplyScalar(height + 5).applyQuaternion(slerp);

                // compute raycast towards ground
                let finalPosition;
                if (this.dtSum + dt > this.dtSumTickSize) {
                    const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), destination1.clone().negate());
                    const intersections = raycaster.intersectObjects(Array.from(document.querySelectorAll(".clickable")).map(el => el.object3D));
                    if (intersections[0]) {
                        destination1 = intersections[0].point.clone();
                    }
                    finalPosition = destination1.clone().add(destination1.clone().normalize().multiplyScalar(5));
                    this.heightDiff = new THREE.Vector3().distanceTo(finalPosition) - (height + 5);
                    this.heightDiffLerp = 0.1 * this.heightDiff + 0.9 * this.heightDiffLerp;
                    this.dtSum = 0;
                } else {
                    if (this.heightDiff > this.heightDiffLerp) {
                        this.heightDiffLerp = 0.03 * this.heightDiff + 0.97 * this.heightDiffLerp;
                    } else {
                        this.heightDiffLerp = 0.005 * this.heightDiff + 0.995 * this.heightDiffLerp;
                    }
                    finalPosition = objectWorldPos.clone().normalize().multiplyScalar(this.heightDiffLerp + height + 5).applyQuaternion(slerp);
                    this.dtSum += dt;
                }

                // update camera
                object3D.position.set(finalPosition.x, finalPosition.y, finalPosition.z);
                const camera = this.el.sceneEl.camera;
                camera.up = upVector;
                camera.lookAt(boxWorldPos);
            }
        });

        const KEYCODE_TO_CODE = {
            '38': 'ArrowUp',
            '37': 'ArrowLeft',
            '40': 'ArrowDown',
            '39': 'ArrowRight',
            '87': 'KeyW',
            '65': 'KeyA',
            '83': 'KeyS',
            '68': 'KeyD'
        };
        // @ts-ignore
        const bind = AFRAME.utils.bind;
        // @ts-ignore
        const shouldCaptureKeyEvent = AFRAME.utils.shouldCaptureKeyEvent;
        const KEYS = [
            'KeyW', 'KeyA', 'KeyS', 'KeyD',
            'ArrowUp', 'ArrowLeft', 'ArrowRight', 'ArrowDown'
        ];

        AFRAME.registerComponent('globe-keyboard-controls', {
            schema: {
                acceleration: {default: 100},
                enabled: {default: true},
                fly: {default: false},
            },

            init: function () {
                // To keep track of the pressed keys.
                // @ts-ignore
                this.keys = {};
                // @ts-ignore
                this.velocity = new THREE.Vector3();
                // @ts-ignore
                this.rotation = new THREE.Vector3();

                // Bind methods and add event listeners.
                this.onBlur = bind(this.onBlur, this);
                this.onContextMenu = bind(this.onContextMenu, this);
                this.onFocus = bind(this.onFocus, this);
                this.onKeyDown = bind(this.onKeyDown, this);
                this.onKeyUp = bind(this.onKeyUp, this);
                this.onVisibilityChange = bind(this.onVisibilityChange, this);
                this.attachVisibilityEventListeners();
            },

            tick: function (time, delta) {
                var el = this.el;
                // @ts-ignore
                const body = this.el.body;

                // Update velocity.
                delta = delta / 1000;
                this.updateVelocity(delta);

                // Get movement vector and translate position.
                // @ts-ignore
                body.applyForce(this.getMovementVector(delta).clone(), new CANNON.Vec3(0, 0, 0));

                // @ts-ignore
                if (this.rotation.clone().y) {
                    // apply rotation force
                    // @ts-ignore
                    body.applyLocalForce(new CANNON.Vec3(this.rotation.clone().y, 0, 0), new CANNON.Vec3(0, 0, 1));
                    // @ts-ignore
                    body.applyLocalForce(new CANNON.Vec3(-this.rotation.clone().y, 0, 0), new CANNON.Vec3(0, 0, -1));
                }
            },

            remove: function () {
                this.removeKeyEventListeners();
                this.removeVisibilityEventListeners();
            },

            play: function () {
                this.attachKeyEventListeners();
            },

            pause: function () {
                // @ts-ignore
                this.keys = {};
                this.removeKeyEventListeners();
            },

            updateVelocity: function (delta) {
                var acceleration;
                var data = this.data;
                // @ts-ignore
                var keys = this.keys;
                // @ts-ignore
                var velocity = this.velocity;
                // @ts-ignore
                var rotation = this.rotation;

                if (!data.enabled) { return; }

                // Update velocity using keys pressed.
                acceleration = data.acceleration;
                velocity.set(0, 0, 0);
                rotation.set(0, 0, 0);
                if (keys.KeyA || keys.ArrowLeft) { rotation.y = acceleration; }
                if (keys.KeyD || keys.ArrowRight) { rotation.y = -acceleration; }
                if (keys.KeyW || keys.ArrowUp) { velocity.z = -acceleration; }
                if (keys.KeyS || keys.ArrowDown) { velocity.z = acceleration; }

                // @ts-ignore
                const bodyWorldVelocity = this.el.body.velocity.clone();
                // @ts-ignore
                const bodyWorldQuat = this.el.body.quaternion.clone().inverse();
                // @ts-ignore
                const bodyVelocity = new THREE.Vector3(bodyWorldVelocity.x, bodyWorldVelocity.y, bodyWorldVelocity.z).applyQuaternion(new THREE.Quaternion(bodyWorldQuat.x, bodyWorldQuat.y, bodyWorldQuat.z, bodyWorldQuat.w));
                // @ts-ignore
                velocity.sub(new THREE.Vector3(bodyVelocity.x, bodyVelocity.y, bodyVelocity.z).multiplyScalar(1));
            },

            getMovementVector: (function () {
                // @ts-ignore
                var directionVector = new THREE.Vector3(0, 0, 0);

                return function (delta) {
                    // @ts-ignore
                    var velocity = this.velocity;
                    // @ts-ignore
                    var rotation = this.el.object3D.getWorldQuaternion(new THREE.Quaternion());

                    // @ts-ignore
                    directionVector.copy(velocity);

                    // Transform direction relative to heading.
                    // @ts-ignore
                    directionVector.applyQuaternion(rotation);
                    return directionVector;
                };
            })(),

            attachVisibilityEventListeners: function () {
                window.oncontextmenu = this.onContextMenu;
                window.addEventListener('blur', this.onBlur);
                window.addEventListener('focus', this.onFocus);
                document.addEventListener('visibilitychange', this.onVisibilityChange);
            },

            removeVisibilityEventListeners: function () {
                window.removeEventListener('blur', this.onBlur);
                window.removeEventListener('focus', this.onFocus);
                document.removeEventListener('visibilitychange', this.onVisibilityChange);
            },

            attachKeyEventListeners: function () {
                window.addEventListener('keydown', this.onKeyDown);
                window.addEventListener('keyup', this.onKeyUp);
            },

            removeKeyEventListeners: function () {
                window.removeEventListener('keydown', this.onKeyDown);
                window.removeEventListener('keyup', this.onKeyUp);
            },

            onContextMenu: function () {
                // @ts-ignore
                var keys = Object.keys(this.keys);
                for (var i = 0; i < keys.length; i++) {
                    // @ts-ignore
                    delete this.keys[keys[i]];
                }
            },

            onBlur: function () {
                this.pause();
            },

            onFocus: function () {
                this.play();
            },

            onVisibilityChange: function () {
                if (document.hidden) {
                    this.onBlur();
                } else {
                    this.onFocus();
                }
            },

            onKeyDown: function (event) {
                var code;
                if (!shouldCaptureKeyEvent(event)) { return; }
                code = event.code || KEYCODE_TO_CODE[event.keyCode];
                // @ts-ignore
                if (KEYS.indexOf(code) !== -1) { this.keys[code] = true; }
            },

            onKeyUp: function (event) {
                var code;
                code = event.code || KEYCODE_TO_CODE[event.keyCode];
                // @ts-ignore
                delete this.keys[code];
            }
        });

        const pathfinder = new threePathfinding.Pathfinding();
        const oceanPathfinder = new threePathfinding.Pathfinding();
        const ZONE = 'level';

        /**
         * nav
         *
         * Pathfinding system, using PatrolJS.
         */
        AFRAME.registerSystem('globe-nav', {
            navMesh: null,
            agents: new Set(),
            init: function () {
                this.navMesh = null;
                this.agents = new Set();
            },

            /**
             * @param {THREE.Geometry} geometry
             */
            setNavMeshGeometry: function (geometry) {
                // @ts-ignore
                this.navMesh = new THREE.Mesh(geometry);
                pathfinder.setZoneData(ZONE, threePathfinding.Pathfinding.createZone(geometry));
                Array.from(this.agents).forEach((agent) => agent.updateNavLocation());
            },

            /**
             * @return {THREE.Mesh}
             */
            getNavMesh: function () {
                return this.navMesh;
            },

            /**
             * @param {NavAgent} ctrl
             */
            addAgent: function (ctrl) {
                this.agents.add(ctrl);
            },

            /**
             * @param {NavAgent} ctrl
             */
            removeAgent: function (ctrl) {
                this.agents.delete(ctrl);
            },

            /**
             * @param  {THREE.Vector3} start
             * @param  {THREE.Vector3} end
             * @param  {number} groupID
             * @return {Array<THREE.Vector3>}
             */
            getPath: function (start, end, groupID) {
                return this.navMesh
                    ? groupID === null ? [] : pathfinder.findPath(start, end, ZONE, groupID)
                    : null;
            },

            /**
             * @param {THREE.Vector3} position
             * @return {number}
             */
            getGroup: function (position) {
                return this.navMesh
                    ? pathfinder.getGroup(ZONE, position)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} position
             * @param  {number} groupID
             * @return {Node}
             */
            getNode: function (position, groupID) {
                return this.navMesh
                    ? pathfinder.getClosestNode(position, ZONE, groupID, true)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} start Starting position.
             * @param  {THREE.Vector3} end Desired ending position.
             * @param  {number} groupID
             * @param  {Node} node
             * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.
             * @return {Node} Current node, after step is taken.
             */
            clampStep: function (start, end, groupID, node, endTarget) {
                if (!this.navMesh) {
                    endTarget.copy(end);
                    return null;
                } else if (!node) {
                    endTarget.copy(end);
                    return this.getNode(end, groupID);
                }
                return pathfinder.clampStep(start, end, node, ZONE, groupID, endTarget);
            }
        });

        AFRAME.registerComponent('globe-nav-mesh', {
            schema: {
                nodeName: {type: 'string'}
            },
            hasLoadedNavMesh: false,
            nodeName: "",
            init: function () {
                this.system = this.el.sceneEl.systems['globe-nav'];
                this.hasLoadedNavMesh = false;
                this.nodeName = this.data.nodeName;
                this.el.addEventListener('object3dset', this.loadNavMesh.bind(this));
            },

            play: function () {
                if (!this.hasLoadedNavMesh) this.loadNavMesh();
            },

            loadNavMesh: function () {
                var self = this;
                const object = this.el.getObject3D('mesh');
                const scene = this.el.sceneEl.object3D;

                if (!object) return;

                let navMesh;
                object.traverse((node) => {
                    if (node.isMesh &&
                        (!self.nodeName || node.name === self.nodeName)) navMesh = node;
                });

                if (!navMesh) return;

                // @ts-ignore
                const navMeshGeometry = navMesh.geometry.clone();
                // @ts-ignore
                navMesh.updateWorldMatrix(true, false);
                // @ts-ignore
                navMeshGeometry.applyMatrix4(navMesh.matrixWorld);
                // @ts-ignore
                this.system.setNavMeshGeometry(navMeshGeometry);
                this.hasLoadedNavMesh = true;
                this.el.setAttribute("visible", "false");
            }
        });

        AFRAME.registerComponent('globe-nav-agent', {
            schema: {
                destination: {type: 'vec3'},
                active: {default: false},
                speed: {default: 2}
            },
            system: null,
            group: null,
            path: [],
            init: function () {
                this.system = this.el.sceneEl.systems['globe-nav'];
                this.system.addAgent(this);
                this.group = null;
                this.path = [];
                this.material = new THREE.LineBasicMaterial({ color: 0xffffff });
                this.geometry = new THREE.BufferGeometry().setFromPoints([]);
                this.line = new THREE.Line(this.geometry, this.material);
                this.debugId = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
            },
            remove: function () {
                this.system.removeAgent(this);
                const el = this.el;
                if (el.classList.contains("npc")) {
                    if (this.el.sceneEl.object3DMap[`line-debug-${this.debugId}`]) {
                        this.el.sceneEl.removeObject3D(`line-debug-${this.debugId}`);
                    }
                }
            },
            update: function () {
                this.path.length = 0;
            },
            updateNavLocation: function () {
                this.group = null;
                this.path = [];
            },
            tick: function (t, dt) {
                const vDest = new THREE.Vector3();
                const vDelta = new THREE.Vector3();
                const vNext = new THREE.Vector3();

                const el = this.el;
                const data = this.data;
                const speed = data.speed * dt / 1000;

                if (!data.active) return;

                const object3D = this.el.object3D;
                // @ts-ignore
                const pos = object3D.getWorldPosition(new THREE.Vector3());

                const cameraEl = document.querySelector("#camera-rig");
                const cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());

                const cameraDistance = pos.distanceTo(cameraPos);
                object3D.visible = cameraDistance < 20;


                // Use PatrolJS pathfinding system to get the shortest path to target.
                if (!this.path.length) {
                    const position = this.el.object3D.position;
                    this.group = this.group || this.system.getGroup(position);
                    this.path = this.system.getPath(position, vDest.copy(data.destination), this.group) || [];
                    el.emit('navigation-start');
                }

                if (el.classList.contains("npc")) {
                    if (this.el.sceneEl.object3DMap[`line-debug-${this.debugId}`]) {
                        this.el.sceneEl.removeObject3D(`line-debug-${this.debugId}`);
                    }
                    this.geometry.setFromPoints([this.el.object3D.position, ...this.path].map(x => new THREE.Vector3().addVectors(x, x.clone().normalize())));
                    this.geometry.computeBoundingSphere();
                    this.line = new THREE.Line(this.geometry, this.material);
                    this.el.sceneEl.setObject3D(`line-debug-${this.debugId}`, this.line);
                }

                // If no path is found, exit.
                if (!this.path.length) {
                    // console.warn('[nav] Unable to find path to %o.', data.destination);
                    this.el.setAttribute("globe-nav-agent", "active: false;");
                    el.emit('navigation-end');
                    el.emit('navigation-group-change');
                    el.object3D.position.copy(vDest);
                    this.group = null;
                    el.emit('navigation-group-changed');
                    return;
                }

                // Current segment is a vector from current position to next waypoint.
                const vCurrent = el.object3D.position;
                const vWaypoint = this.path[0];
                vDelta.subVectors(vWaypoint, vCurrent);

                const distance = vDelta.length();
                let gazeTarget;

                if (distance <= speed) {
                    // If <1 step from current waypoint, discard it and move toward next.
                    this.path.shift();

                    // After discarding the last waypoint, exit pathfinding.
                    if (!this.path.length) {
                        this.el.setAttribute("globe-nav-agent", "active: false;");
                        el.emit('navigation-end');
                        return;
                    }

                    vNext.copy(vCurrent);
                    gazeTarget = this.path[0];
                } else {
                    // If still far away from next waypoint, find next position for
                    // the current frame.
                    vNext.copy(vDelta.setLength(speed)).add(vCurrent);
                    gazeTarget = vWaypoint;
                }

                // Look at the next waypoint.
                // gazeTarget.y = vCurrent.y;
                el.object3D.up = new THREE.Vector3().copy(vCurrent).normalize();
                el.object3D.lookAt(gazeTarget);

                vCurrent.copy(vNext);
            },
        });

        /**
         * nav
         *
         * Pathfinding system, using PatrolJS.
         */
        AFRAME.registerSystem('globe-ocean-nav', {
            navMesh: null,
            agents: new Set(),
            init: function () {
                this.navMesh = null;
                this.agents = new Set();
            },

            /**
             * @param {THREE.Geometry} geometry
             */
            setNavMeshGeometry: function (geometry) {
                // @ts-ignore
                this.navMesh = new THREE.Mesh(geometry);
                oceanPathfinder.setZoneData(ZONE, threePathfinding.Pathfinding.createZone(geometry));
                Array.from(this.agents).forEach((agent) => agent.updateNavLocation());
            },

            /**
             * @return {THREE.Mesh}
             */
            getNavMesh: function () {
                return this.navMesh;
            },

            /**
             * @param {NavAgent} ctrl
             */
            addAgent: function (ctrl) {
                this.agents.add(ctrl);
            },

            /**
             * @param {NavAgent} ctrl
             */
            removeAgent: function (ctrl) {
                this.agents.delete(ctrl);
            },

            /**
             * @param  {THREE.Vector3} start
             * @param  {THREE.Vector3} end
             * @param  {number} groupID
             * @return {Array<THREE.Vector3>}
             */
            getPath: function (start, end, groupID) {
                return this.navMesh
                    ? groupID === null ? [] : oceanPathfinder.findPath(start, end, ZONE, groupID)
                    : null;
            },

            /**
             * @param {THREE.Vector3} position
             * @return {number}
             */
            getGroup: function (position) {
                return this.navMesh
                    ? oceanPathfinder.getGroup(ZONE, position)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} position
             * @param  {number} groupID
             * @return {Node}
             */
            getNode: function (position, groupID) {
                return this.navMesh
                    ? oceanPathfinder.getClosestNode(position, ZONE, groupID, true)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} start Starting position.
             * @param  {THREE.Vector3} end Desired ending position.
             * @param  {number} groupID
             * @param  {Node} node
             * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.
             * @return {Node} Current node, after step is taken.
             */
            clampStep: function (start, end, groupID, node, endTarget) {
                if (!this.navMesh) {
                    endTarget.copy(end);
                    return null;
                } else if (!node) {
                    endTarget.copy(end);
                    return this.getNode(end, groupID);
                }
                return oceanPathfinder.clampStep(start, end, node, ZONE, groupID, endTarget);
            }
        });

        AFRAME.registerComponent('globe-ocean-nav-mesh', {
            schema: {
                nodeName: {type: 'string'}
            },
            hasLoadedNavMesh: false,
            nodeName: "",
            init: function () {
                this.system = this.el.sceneEl.systems['globe-ocean-nav'];
                this.hasLoadedNavMesh = false;
                this.nodeName = this.data.nodeName;
                this.el.addEventListener('object3dset', this.loadNavMesh.bind(this));
            },

            play: function () {
                if (!this.hasLoadedNavMesh) this.loadNavMesh();
            },

            loadNavMesh: function () {
                var self = this;
                const object = this.el.getObject3D('mesh');
                const scene = this.el.sceneEl.object3D;

                if (!object) return;

                let navMesh;
                object.traverse((node) => {
                    if (node.isMesh &&
                        (!self.nodeName || node.name === self.nodeName)) navMesh = node;
                });

                if (!navMesh) return;

                // @ts-ignore
                const navMeshGeometry = navMesh.geometry.clone();
                // @ts-ignore
                navMesh.updateWorldMatrix(true, false);
                // @ts-ignore
                navMeshGeometry.applyMatrix4(navMesh.matrixWorld);
                // @ts-ignore
                this.system.setNavMeshGeometry(navMeshGeometry);
                this.hasLoadedNavMesh = true;
                this.el.setAttribute("visible", "false");
            }
        });

        AFRAME.registerComponent('globe-ocean-nav-agent', {
            schema: {
                destination: {type: 'vec3'},
                active: {default: false},
                speed: {default: 2}
            },
            system: null,
            group: null,
            path: [],
            init: function () {
                this.system = this.el.sceneEl.systems['globe-ocean-nav'];
                this.system.addAgent(this);
                this.group = null;
                this.path = [];
            },
            remove: function () {
                this.system.removeAgent(this);
            },
            update: function () {
                this.path.length = 0;
            },
            updateNavLocation: function () {
                this.group = null;
                this.path = [];
            },
            tick: function (t, dt) {
                const vDest = new THREE.Vector3();
                const vDelta = new THREE.Vector3();
                const vNext = new THREE.Vector3();

                const el = this.el;
                const data = this.data;
                const speed = data.speed * dt / 1000;

                if (!data.active) return;

                // Use PatrolJS pathfinding system to get the shortest path to target.
                if (!this.path.length) {
                    const position = this.el.object3D.position;
                    this.group = this.group || this.system.getGroup(position);
                    this.path = this.system.getPath(position, vDest.copy(data.destination), this.group) || [];
                    el.emit('navigation-start');
                }

                // If no path is found, exit.
                if (!this.path.length) {
                    // console.warn('[nav] Unable to find path to %o.', data.destination);
                    this.el.setAttribute("globe-ocean-nav-agent", "active: false;");
                    el.emit('navigation-end');
                    el.object3D.position.copy(vDest);
                    console.log(el.object3D.position);
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyW"});
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                    this.group = null;
                    return;
                }

                // Current segment is a vector from current position to next waypoint.
                const vCurrent = new THREE.Vector3().copy(el.components['dynamic-body'].body.position);
                const vWaypoint = this.path[0];
                vDelta.subVectors(vWaypoint, vCurrent);

                const distance = vDelta.length();
                let gazeTarget;

                if (distance < 4) {
                    // If <1 step from current waypoint, discard it and move toward next.
                    this.path.shift();

                    // After discarding the last waypoint, exit pathfinding.
                    if (!this.path.length) {
                        this.el.setAttribute("globe-ocean-nav-agent", "active: false;");
                        el.emit('navigation-end');
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyW"});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                        return;
                    }

                    vNext.copy(vCurrent);
                    gazeTarget = this.path[0];
                } else {
                    // If still far away from next waypoint, find next position for
                    // the current frame.
                    vNext.copy(vDelta.setLength(speed)).add(vCurrent);
                    gazeTarget = vWaypoint;
                }

                // Look at the next waypoint.
                // gazeTarget.y = vCurrent.y;
                // |  x  y  z |
                // | ax ay az |
                // | bx by bz |
                const getDeterminant = () => {
                    const a = vCurrent.clone().normalize();
                    const v1 = new THREE.Vector3(0, 0, -1).applyQuaternion(new THREE.Quaternion().copy(el.components['dynamic-body'].body.quaternion));
                    const v2 = gazeTarget.clone().sub(vCurrent.clone()).normalize();

                    // make two vectors for determinant
                    let ax = v1.x;
                    let ay = v1.y;
                    let az = v1.z;
                    let bx = v2.x;
                    let by = v2.y;
                    let bz = v2.z;

                    // make basis matrix for sphere
                    let aVec = new THREE.Vector3().set(ax, ay, az).normalize();
                    let bVec = new THREE.Vector3().set(bx, by, bz).normalize();
                    const basisY = aVec.clone().normalize();
                    const basisZ = a.clone().normalize();
                    const basisX = new THREE.Vector3().crossVectors(basisY, basisZ);
                    const basis = new THREE.Matrix4().makeBasis(basisX, basisY, basisZ).invert();

                    // apply basis matrix
                    aVec = aVec.applyMatrix4(basis);
                    bVec = bVec.applyMatrix4(basis);
                    ax = aVec.x;
                    ay = aVec.y;
                    az = aVec.z;
                    bx = bVec.x;
                    by = bVec.y;
                    bz = bVec.z;

                    let det = ax * by + ay * bz + az * bx - ay * bx - az * by - ax * bz;
                    if (isNaN(det)) {
                        return 0;
                    }
                    if (aVec.dot(bVec) < 0) {
                        det += Math.sign(det);
                    }
                    return det;
                };
                const det = getDeterminant();
                if (det < 0) {
                    if (Math.random() * 0.5 < Math.abs(det)) {
                        el.components['globe-keyboard-controls'].onKeyDown({code: "KeyD"});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                    } else {
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                    }
                } else if (det > 0) {
                    if (Math.random() * 0.33 < Math.abs(det)) {
                        el.components['globe-keyboard-controls'].onKeyDown({code: "KeyA"});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                    } else {
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                    }
                } else {
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                }

                if (Math.abs(det) < 0.1) {
                    el.components['globe-keyboard-controls'].onKeyDown({code: "KeyW"});
                } else {
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyW"});
                }
            },
        });

        AFRAME.registerComponent('go-on-land', {
            init: function () {
                this.system = this.el.sceneEl.systems['globe-nav'];
                // @ts-ignore
                this.el.addEventListener('click', (e) => {
                    const destination1 = e.detail.intersection.point.clone();
                    setTimeout(() => {
                        const npcs = document.querySelectorAll('.npc');
                        if (npcs.length === 0) {
                            for (let i = 0; i < 10; i++) {
                                addNpc(i);
                            }
                        }
                    }, 0);
                    setTimeout(() => {
                        const npcEls = document.querySelectorAll('.npc');
                        npcEls.forEach(npcEl => {
                            // @ts-ignore
                            npcEl.setAttribute("globe-nav-agent", `active: false; destination: ${destination1.x} ${destination1.y} ${destination1.z}; speed: 2;`);
                        });
                    }, 500);
                    setTimeout(() => {
                        const npcEls = document.querySelectorAll('.npc');
                        const cameraEl = document.querySelector("#camera-rig");
                        cameraEl.setAttribute("look-at-box", ".npc");
                        npcEls.forEach(npcEl => {
                            const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3).add(new THREE.Vector3().random()), destination1.clone().negate());
                            const intersections = raycaster.intersectObject(this.system.getNavMesh());
                            if (intersections[0]) {
                                const destination2 = intersections[0].point.clone();
                                npcEl.setAttribute("globe-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2;`);
                            }
                        });
                    }, 1000);
                });
            }
        });

        AFRAME.registerComponent('raze-target', {
            schema: {},
            init: function () {
                this.el.addEventListener("click", () => {
                    this.el.emit("raze");
                });
            },
        });

        AFRAME.registerComponent('go-to-sea', {
            init: function () {
                this.el.addEventListener('click', function (e) {
                    const destination1 = e.detail.intersection.point.clone();
                    setTimeout(() => {
                        const cameraEl = document.querySelector("#camera-rig");
                        cameraEl.setAttribute("look-at-box", "#box");
                    }, 0);
                    setTimeout(() => {
                        const npcs = document.querySelectorAll('.npc');
                        if (npcs.length !== 0) {
                            removeNpc();
                        }
                    }, 1000);
                    setTimeout(() => {
                        const shipEls = document.querySelectorAll('#box');
                        shipEls.forEach(shipEl => {
                            // @ts-ignore
                            shipEl.setAttribute("globe-ocean-nav-agent", `active: false; destination: ${destination1.x} ${destination1.y} ${destination1.z}; speed: 2;`);
                        });
                    }, 500);
                    setTimeout(() => {
                        const shipEls = document.querySelectorAll('#box');
                        shipEls.forEach(shipEl => {
                            // @ts-ignore
                            shipEl.setAttribute("globe-ocean-nav-agent", `active: true; destination: ${destination1.x} ${destination1.y} ${destination1.z}; speed: 2;`);
                        });
                    }, 1000);
                });
            }
        });
        AFRAME.registerComponent('terrain-tile', {
            schema: {
                type: "string",
                default: ""
            },
            init: function () {
            },
            tick: function () {
                if (!this.data) {
                    return;
                }

                const cameraEl = document.querySelector("#camera-rig");
                // @ts-ignore
                let cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());
                cameraPos = cameraPos.normalize();
                // @ts-ignore
                let tilePos = new THREE.Vector3();
                tilePos = tilePos.set.apply(tilePos, this.data.split(" "));
                tilePos = tilePos.normalize();

                if (cameraPos.dot(tilePos) > 0.75) {
                    this.el.setAttribute("visible", "true");
                } else {
                    this.el.setAttribute("visible", "false");
                }
            }
        });

        AFRAME.registerSystem('building', {
            schema: {},
            init: function () {
                this.islandBuildings = new Map();
                this.buildings = [];
                this.updateBuildings = debounce(this.innerUpdateBuildings.bind(this), 1000);
            },
            innerUpdateBuildings: function () {
                this.buildings.forEach(el => {
                    const building = el.components['building'];
                    const group = this.el.sceneEl.systems['globe-nav'].getGroup(el.components['position'].data);
                    const arr = this.islandBuildings.get(group);
                    if (arr) {
                        building.locateNearestBuilding(arr);
                    }
                });
            },
            registerMe: function (el) {
                if (this.el.sceneEl.systems['globe-nav'].navMesh) {
                    const group = this.el.sceneEl.systems['globe-nav'].getGroup(el.components['position'].data);
                    if (this.islandBuildings.has(group)) {
                        this.islandBuildings.get(group).push(el);
                    } else {
                        this.islandBuildings.set(group, [el]);
                    }
                    this.buildings.push(el);
                    this.updateBuildings();
                } else {
                    setTimeout(this.registerMe.bind(this, el), 100);
                }
            },
            unregisterMe: function (el) {
                const group = this.el.sceneEl.systems['globe-nav'].getGroup(el.components['position'].data);
                if (this.islandBuildings.has(group)) {
                    const arr = this.islandBuildings.get(group);
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
                {
                    const arr = this.buildings;
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
            },
        });

        AFRAME.registerComponent('building', {
            schema: {
                type: "string",
                default: "house",
            },
            init: function () {
                this.system.registerMe(this.el);
                const tempType = this.data?.toString()?.toLowerCase() ?? "";
                let buildingTypes;
                switch (tempType) {
                    case "port": {
                        buildingTypes = [
                            "port"
                        ];
                        break;
                    }
                    case "temple": {
                        buildingTypes = [
                            "temple"
                        ];
                        break;
                    }
                    default: {
                        buildingTypes = [
                            "house",
                            "house",
                            "tavern",
                            "workshop",
                        ];
                    }
                }
                this.buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                if (this.buildingType === "house") {
                    const numNpcs = Math.floor(Math.random() * 4) + 1;
                    for (let i = 0; i < numNpcs; i++) {
                        this.el.setAttribute(`npc-spawner__${i}`, "");
                    }
                }
            },
            locateNearestBuilding: function (islandBuildings) {
                const buildingTypes = new Map();
                for (const el of islandBuildings) {
                    const building = el.components['building'];
                    const buildingType = building.buildingType;
                    if (buildingTypes.has(buildingType)) {
                        const arr = buildingTypes.get(buildingType);
                        arr.push(el);
                    } else {
                        const arr = [el];
                        buildingTypes.set(buildingType, arr);
                    }
                }

                this.nearestBuildingType = new Map();
                for (const [buildingType, els] of buildingTypes.entries()) {
                    const nearestBuilding = els.reduce((el, v) => {
                        if (!el) {
                            return v;
                        }

                        const start = new THREE.Vector3().set(this.el.components['position'].data);
                        const endNew = new THREE.Vector3().set(v.components['position'].data);
                        const endOld = new THREE.Vector3().set(el.components['position'].data);
                        const distanceNew = start.distanceTo(endNew);
                        const distanceOld = start.distanceTo(endOld);
                        if (distanceNew < distanceOld) {
                            return v;
                        }
                        return el;
                    }, undefined);
                    if (nearestBuilding) {
                        this.nearestBuildingType.set(buildingType, nearestBuilding);
                    }
                }
                this.el.emit("found-nearest-building");
            },
            remove: function () {
                this.system.unregisterMe(this.el);
            },
        });

        window.spawnNpcsFlag = false;
        AFRAME.registerComponent('npc-spawner', {
            schema: {},
            multiple: true,
            init: function () {
                if (this.el.id) {
                    this.elId = this.el.id;
                } else {
                    this.elId = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
                    this.el.setAttribute("id", this.elId);
                }
                this.currentNpcId = null;
                this.initFiniteStateMachine();
                this.innerInitFiniteStateMachine = this.initFiniteStateMachine.bind(this)
                this.innerTransition = this.transition.bind(this);
                this.innerHandleDead = this.handleDead.bind(this);
                this.el.addEventListener('found-nearest-building', this.innerInitFiniteStateMachine);
                this.el.addEventListener('transition', this.innerTransition);
                this.el.addEventListener('dead', this.innerHandleDead);
            },
            initFiniteStateMachine: function () {
                const building = this.el.components['building'];
                if (!building.nearestBuildingType || this.isReady) {
                    return;
                }
                this.isHome = true;
                this.otherBuildings = new Map();
                for (const [key, value] of building.nearestBuildingType.entries()) {
                    this.otherBuildings.set(key, value);
                }
                if (this.otherBuildings.has('home')) {
                    this.otherBuildings.delete('home');
                }
                this.isReady = true;
                setTimeout(() => {
                    this.transition();
                }, 10_000);
            },
            transition: function (evt) {
                const npcId = evt?.detail ?? null;
                if (!this.isReady) {
                    setTimeout(() => {
                        this.innerTransition(evt);
                    }, 10_000);
                    return;
                }
                if (!window.spawnNpcsFlag) {
                    setTimeout(() => {
                        this.innerTransition(evt);
                    }, 10_000);
                    return;
                }
                if (npcId && npcId !== this.currentNpcId) {
                    return;
                }
                if (npcId && npcId === this.currentNpcId) {
                    removeWalkingNpc(npcId);
                }
                if (this.isHome) {
                    const arr = Array.from(this.otherBuildings.values());
                    this.otherBuilding = arr[Math.floor(Math.random() * arr.length)];
                    if (this.otherBuilding) {
                        this.isHome = false;
                        this.currentNpcId = addWalkingNpc(this.elId, this.el, this.otherBuilding);
                    }
                } else {
                    this.isHome = true;
                    this.currentNpcId = addWalkingNpc(this.elId, this.otherBuilding, this.el);
                    this.otherBuilding = undefined;
                }
            },
            handleDead: function (evt) {
                const npcId = evt?.detail ?? null;
                if (!this.isReady) {
                    setTimeout(() => {
                        this.innerHandleDead(evt);
                    }, 10_000);
                    return;
                }
                if (npcId && npcId !== this.currentNpcId) {
                    return;
                }
                if (npcId && npcId === this.currentNpcId) {
                    this.el.removeAttribute(`npc-spawner__${this.id}`);
                }
            },
            remove: function () {
                this.el.removeEventListener('found-nearest-building', this.innerInitFiniteStateMachine);
                this.el.removeEventListener('transition', this.innerTransition);
            },
        });

        AFRAME.registerComponent('npc-agent', {
            schema: {
                building: {type: 'selector'}
            },
            init: function () {
                this.innerBeginTransition = this.beginTransition.bind(this);
                this.innerHandleDead = this.handleDead.bind(this);
                this.el.addEventListener("navigation-end", this.innerBeginTransition);
                this.el.addEventListener("dead", this.innerHandleDead);
            },
            beginTransition: function () {
                this.data.building.emit('transition', this.el.id);
            },
            handleDead: function () {
                this.data.building.emit('dead', this.el.id);
            },
            remove: function () {
                this.el.removeEventListener("navigation-end", this.innerBeginTransition);
                this.el.removeEventListener("dead", this.innerHandleDead);
            },
        });

        AFRAME.registerComponent('npc-faction', {
            schema: {
                type: 'string',
                default: ''
            },
        });

        AFRAME.registerComponent('npc-attack', {
            schema: {
                range: {type: 'number', default: 10},
                melee: {type: 'boolean', default: false},
            },
            init: function () {
                this.attackEls = [];
                this.innerAttack = this.attack.bind(this);
                this.innerBeginAttack = this.beginAttack.bind(this);
                this.innerMeleeCharge = this.meleeCharge.bind(this);
                this.innerMeleeReturn = this.meleeReturn.bind(this);
                this.innerNavigationBegin = this.navigationBegin.bind(this);
                this.innerNavigationEnd = this.navigationEnd.bind(this);
                this.el.addEventListener('npc-attack', this.innerAttack);
                this.el.addEventListener('npc-begin-attack', this.innerBeginAttack);
                this.el.addEventListener('npc-melee-charge', this.innerMeleeCharge);
                this.el.addEventListener('npc-melee-return', this.innerMeleeReturn);
                if (this.data.melee) {
                    this.el.addEventListener('navigation-start', this.innerNavigationBegin);
                    this.el.addEventListener('navigation-end', this.innerNavigationEnd);
                }

                this.tickCounter = 0;
                this.findTickCount = 120;
                this.charge = false;
                this.immediateCharge = false;
                this.chargeOrigin = this.el.object3D.position.clone();
            },
            remove: function () {
                this.el.removeEventListener('npc-attack', this.innerAttack);
                this.el.removeEventListener('npc-begin-attack', this.innerBeginAttack);
                this.el.removeEventListener('npc-melee-charge', this.innerMeleeCharge);
                this.el.removeEventListener('npc-melee-return', this.innerMeleeReturn);
                if (this.data.melee) {
                    this.el.removeEventListener('navigation-start', this.innerNavigationBegin);
                    this.el.removeEventListener('navigation-end', this.innerNavigationEnd);
                }
                this.attackEls = [];
            },
            tick: function () {
                if (this.tickCounter < this.findTickCount) {
                    this.tickCounter += 1;
                    return;
                }
                this.tickCounter = 0;

                const pos = this.el.object3D.position;
                for (const el of this.attackEls) {
                    const p = el.object3D.position;
                    const distance = pos.distanceTo(p);
                    if (distance < this.data.range) {
                        if (this.data.melee && distance > 1) {
                            if (this.chargeOrigin.distanceTo(p) < this.data.range) {
                                this.el.emit('npc-melee-charge', el);
                                return;
                            }
                        } else {
                            this.el.emit('npc-begin-attack', el);
                            return;
                        }
                    }
                }
                if (this.data.melee) {
                    this.el.emit('npc-melee-return', this.chargeOrigin.clone());
                }
            },
            attack: function (evt) {
                this.attackEls = evt.detail;
            },
            beginAttack: function (evt) {
                const target = evt.detail;
                addProjectile(this.el, target);
            },
            meleeCharge: function (evt) {
                const target = evt.detail;
                const destination2 = target.object3D.position.clone();
                this.el.setAttribute("globe-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2;`);
                this.charge = true;
                this.immediateCharge = true;
            },
            meleeReturn: function (evt) {
                const destination2 = evt.detail.clone();
                this.el.setAttribute("globe-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2;`);
                this.charge = true;
                this.immediateCharge = true;
            },
            navigationBegin: function () {
                if (this.data.melee && this.charge && this.immediateCharge) {
                    this.immediateCharge = false;
                    return;
                }
                if (this.data.melee && this.charge && !this.immediateCharge) {
                    this.charge = false;
                }
            },
            navigationEnd: function () {
                if (this.data.melee && this.charge && !this.immediateCharge) {
                    this.tickCounter = this.findTickCount;
                    this.charge = false;
                    return;
                }
                if (this.data.melee && !this.charge && !this.immediateCharge) {
                    this.chargeOrigin = this.el.object3D.position.clone();
                }
            },
        });

        AFRAME.registerComponent('projectile-flight', {
            schema: {
                target: {type: 'selector'},
                speed: {type: 'number', default: 10},
            },
            init: function () {
            },
            tick: function (t, dt) {
                const vDelta = new THREE.Vector3();
                const vNext = new THREE.Vector3();

                const el = this.el;
                const data = this.data;
                const speed = data.speed * dt / 1000;

                if (!this.data.target) {
                    this.el.emit('miss');
                    this.el.parentNode.removeChild(this.el);
                    return;
                }

                const object3D = this.el.object3D;


                // Current segment is a vector from current position to next waypoint.
                const vCurrent = el.object3D.position;
                let vWaypoint = this.data.target.object3D.position.clone();
                vWaypoint = vWaypoint.add(vWaypoint.clone().normalize());
                vDelta.subVectors(vWaypoint, vCurrent);

                const distance = vDelta.length();
                let gazeTarget;

                if (distance <= speed) {
                    vNext.copy(vCurrent);
                    gazeTarget = vWaypoint;

                    this.data.target.emit('hit', 10);
                    this.el.parentNode.removeChild(this.el);
                } else {
                    // If still far away from next waypoint, find next position for
                    // the current frame.
                    vNext.copy(vDelta.setLength(speed)).add(vCurrent);
                    gazeTarget = vWaypoint;
                }

                // Look at the next waypoint.
                // gazeTarget.y = vCurrent.y;
                el.object3D.up = new THREE.Vector3().copy(vCurrent).normalize();
                el.object3D.lookAt(gazeTarget);

                vCurrent.copy(vNext);
            },
        });

        AFRAME.registerComponent('health', {
            schema: {
                health: { type: 'number', default: 100 }
            },
            init: function () {
                this.innerHandleHit = this.handleHit.bind(this);
                this.el.addEventListener('hit', this.innerHandleHit);
            },
            remove: function () {
                this.el.removeEventListener('hit', this.innerHandleHit);
            },
            handleHit: function (evt) {
                const hit = evt.detail;
                const newHealth = this.data.health - hit;
                this.el.setAttribute("health", `health: ${newHealth}`);

                if (newHealth <= 0) {
                    this.el.emit('dead');
                    this.el.parentNode.removeChild(this.el);
                }
            },
        });

        AFRAME.registerComponent('networked-health', {
            schema: {
            },
            init: function () {
                this.innerHandleHit = this.handleHit.bind(this);
                this.el.addEventListener('hit', this.innerHandleHit);
            },
            remove: function () {
                this.el.removeEventListener('hit', this.innerHandleHit);
            },
            handleHit: function (evt) {
                const hit = evt.detail;
                const senderId = this.el.components['networked'].data.owner;
                const networkId = this.el.components['networked'].data.networkId;
                NAF.connection.sendDataGuaranteed(senderId, "networkedHealth", {
                    networkId,
                    hit,
                });
            },
        });

        AFRAME.registerComponent("spawn-gold", {
            schema: {},
            init: function () {
                this.innerHandleDead = this.handleDead.bind(this);
                this.innerHandleRaze = this.handleRaze.bind(this);
                this.el.addEventListener('dead', this.innerHandleDead);
                this.el.addEventListener('raze', this.innerHandleRaze);
            },
            remove: function () {
                this.el.removeEventListener('dead', this.innerHandleDead);
                this.el.removeEventListener('raze', this.innerHandleRaze);
            },
            handleDead: function () {
                for (let i = 0; i < 3; i++) {
                    addGoldCoin(this.el);
                }
            },
            handleRaze: function () {
                for (let i = 0; i < 10; i++) {
                    addGoldCoin(this.el);
                }
            },
        });

        AFRAME.registerComponent("gold-coin-movement", {
            schema: {},
            init: function () {
                this.interval = setTimeout(this.applyImpulse.bind(this), 100);
            },
            remove: function () {
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }
            },
            applyImpulse: function () {
                if (this.el.body) {
                    const getRandom1to1 = () => (Math.random() * 2 - 1);
                    const bPos = this.el.body.position.clone();
                    const impulse = new CANNON.Vec3().set(getRandom1to1(), getRandom1to1(), getRandom1to1());
                    const bPosNorm = bPos.clone();
                    bPosNorm.normalize();
                    impulse.normalize();
                    impulse.vadd(bPosNorm, impulse);
                    impulse.scale(100, impulse);
                    const bPosOffset = new CANNON.Vec3().set(getRandom1to1(), getRandom1to1(), getRandom1to1());
                    bPosOffset.normalize();
                    bPosOffset.scale(5, bPosOffset);
                    this.el.body.applyImpulse(impulse, bPosOffset);
                    this.interval = setTimeout(this.removeGoldCoin.bind(this), 30_000);
                } else {
                    this.interval = setTimeout(this.applyImpulse.bind(this), 100);
                }
            },
            removeGoldCoin: function () {
                this.el.parentNode.removeChild(this.el);
            },
        })

        AFRAME.registerComponent("handle-shadow-parameter", {
            schema: {},
            tick: function () {
                const cameraEl = document.querySelector("#camera-rig");
                const cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());

                const size = 30;
                const shadowCameraBottom = -cameraPos.z - size;
                const shadowCameraTop = -cameraPos.z + size;
                const shadowCameraLeft = cameraPos.x - size;
                const shadowCameraRight = cameraPos.x + size;

                const el = this.el;
                el.setAttribute("light", {
                    shadowCameraBottom,
                    shadowCameraTop,
                    shadowCameraLeft,
                    shadowCameraRight,
                });
            },
        })

        function addTemplate(templateId, charModelId, instanceModelId) {
            const scene = document.querySelector("a-scene");

            const str = characterModels.get(charModelId);

            const rootGoldCoin = document.createElement("a-entity");
            if (charModelId === "SHIP") {
                const dataEl = document.createElement("a-entity");
                dataEl.setAttribute("class", "data");
                dataEl.setAttribute("scale", "0.1 0.1 0.1");
                dataEl.setAttribute("rotation", "0 -90 0");
                dataEl.setAttribute("gltf-model", str);
                rootGoldCoin.appendChild(dataEl);
            } else {
                rootGoldCoin.setAttribute("gltf-model", str);
            }

            if (charModelId === "PERSON") {
                rootGoldCoin.setAttribute("npc-faction", "native");
                rootGoldCoin.setAttribute("npc-finder", "active: false;");
                rootGoldCoin.setAttribute("networked-health", "");
            }

            if (charModelId === "WARRIOR") {
                rootGoldCoin.setAttribute("npc-faction", "player");
                rootGoldCoin.setAttribute("npc-finder", "active: false;");
            }

            const a = (() => {
                const assets = document.querySelector("a-assets");
                if (assets) {
                    return assets;
                } else {
                    const a1 = document.createElement("a-assets");
                    scene.appendChild(a1);
                    return a1;
                }
            })();

            const t = (() => {
                const template = a.querySelector(`#${templateId}`);
                if (template) {
                    return null;
                } else {
                    const t1 = document.createElement("template");
                    t1.setAttribute("id", templateId);
                    return [t1];
                }
            })();

            if (t) {
                t[0].content.appendChild(rootGoldCoin);
                a.appendChild(t[0]);

                if (charModelId === "SHIP") {
                    if (!NAF.schemas.hasTemplate(`#${templateId}`)) {
                        NAF.schemas.add({
                            template: `#${templateId}`,
                            components: [
                                {
                                    component: 'position',
                                    requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.001)
                                },
                                {
                                    component: 'rotation',
                                    requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.5)
                                },
                                {
                                    selector: '.data',
                                    component: 'gltf-model',
                                },
                                {
                                    selector: '.data',
                                    component: 'scale',
                                },
                                {
                                    selector: '.data',
                                    component: 'rotation',
                                },
                            ]
                        });
                    }
                } else {
                    if (!NAF.schemas.hasTemplate(`#${templateId}`)) {
                        NAF.schemas.add({
                            template: `#${templateId}`,
                            components: [
                                {
                                    component: 'position',
                                    requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.001)
                                },
                                {
                                    component: 'rotation',
                                    requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.5)
                                },
                                'gltf-model',
                            ]
                        });
                    }
                }
            }
        }

        function addGoldCoin(startEl) {
            const scene = document.querySelector("a-scene");

            const rootGoldCoin = document.createElement("a-entity");
            const id = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
            rootGoldCoin.setAttribute("id", id);
            rootGoldCoin.setAttribute("class", "gold-coin");
            const pos = startEl.object3D.getWorldPosition(new THREE.Vector3());
            pos.add(pos.clone().normalize());
            rootGoldCoin.setAttribute("position", `${pos.x} ${pos.y} ${pos.z}`);
            rootGoldCoin.setAttribute("rotation", "0 0 0");
            rootGoldCoin.setAttribute("dynamic-body", "shape: sphere; sphereRadius: 1; mass: 100");
            rootGoldCoin.setAttribute("globe-gravity", "");
            rootGoldCoin.setAttribute("collision-filter", "group: gold-coin; ");
            rootGoldCoin.setAttribute("gold-coin-movement", "");
            rootGoldCoin.setAttribute("shadow", "");

            if (characterModels.has("GOLD_COIN")) {
                const str = characterModels.get("GOLD_COIN");

                // add graphics
                rootGoldCoin.setAttribute("gltf-model", str);
                rootGoldCoin.setAttribute("networked", "template: #gold-coin-template; attachTemplateToLocal: false;");
            } else {
                const modelGold = document.createElement("a-sphere");
                modelGold.setAttribute("scale", "0.1 0.1 0.1");
                modelGold.setAttribute("position", "0 0 0");

                rootGoldCoin.appendChild(modelGold);
            }

            scene.appendChild(rootGoldCoin);

            return id;
        }

        function addProjectile(startEl, destinationEl) {
            const scene = document.querySelector("a-scene");

            const rootProjectile = document.createElement("a-entity");
            const id = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
            rootProjectile.setAttribute("id", id);
            rootProjectile.setAttribute("class", "projectile");
            rootProjectile.setAttribute("projectile-flight", `target: #${destinationEl.id}`);
            const pos = startEl.object3D.position.clone().add(startEl.object3D.position.clone().normalize());
            rootProjectile.setAttribute("position", `${pos.x} ${pos.y} ${pos.z}`);
            rootProjectile.setAttribute("rotation", "0 0 0");
            rootProjectile.setAttribute("shadow", "");

            if (characterModels.has("ARROW")) {
                const str = characterModels.get("ARROW");

                // add graphics
                rootProjectile.setAttribute("gltf-model", str);
                rootProjectile.setAttribute("networked", "template: #arrow-template; attachTemplateToLocal: false;");
            } else {
                const modelArrow = document.createElement("a-sphere");
                modelArrow.setAttribute("scale", "0.1 0.1 0.1");
                modelArrow.setAttribute("position", "0 0 0");

                rootProjectile.appendChild(modelArrow);
            }

            scene.appendChild(rootProjectile);

            return id;
        }

        function addWalkingNpc(buildingId, buildingEl, destinationEl) {
            const scene = document.querySelector("a-scene");

            const rootNpc = document.createElement("a-entity");
            const id = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
            rootNpc.setAttribute("id", id);
            rootNpc.setAttribute("class", "walking-npc");
            const destination2 = destinationEl.components['position'].data;
            const pos = buildingEl.components['position'].data;
            rootNpc.setAttribute("position", `${pos.x} ${pos.y} ${pos.z}`);
            rootNpc.setAttribute("rotation", "0 0 0");
            rootNpc.setAttribute("npc-agent", `building: #${buildingId}`);
            rootNpc.setAttribute("npc-faction", "native");
            rootNpc.setAttribute("npc-finder", "active: false;");
            rootNpc.setAttribute("health", "");
            rootNpc.setAttribute("spawn-gold", "");
            rootNpc.setAttribute("globe-nav-agent", `active: false;`);
            rootNpc.setAttribute("shadow", "");
            setTimeout(() => {
                rootNpc.setAttribute("globe-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 1;`);
            }, 2000);

            if (characterModels.has("PERSON")) {
                const str = characterModels.get("PERSON");

                // add graphics
                rootNpc.setAttribute("gltf-model", str);
                rootNpc.setAttribute("networked", "template: #person-template; attachTemplateToLocal: false;");
            } else {
                const modelNpc = document.createElement("a-sphere");
                modelNpc.setAttribute("scale", "0.1 0.1 0.1");
                modelNpc.setAttribute("position", "0 0 0");

                rootNpc.appendChild(modelNpc);
            }

            scene.appendChild(rootNpc);

            return id;
        }

        function removeWalkingNpc(npcId) {
            const scene = document.querySelector("a-scene");
            const a = document.querySelector(`#${npcId}`);
            scene.removeChild(a);
        }

        function addNpc(i) {
            const rootNpc = document.createElement("a-entity");
            rootNpc.setAttribute("class", "npc");
            rootNpc.setAttribute("globe-nav-agent", "");
            rootNpc.setAttribute("position", "0 0 0");
            rootNpc.setAttribute("rotation", "0 0 0");
            rootNpc.setAttribute("npc-faction", "player");
            rootNpc.setAttribute("npc-finder", "active: true;");
            rootNpc.setAttribute("npc-attack", `range: 10; melee: false;`);
            rootNpc.setAttribute("health", "");
            rootNpc.setAttribute("shadow", "");
            rootNpc.setAttribute("outline-pass", "");

            if (characterModels.has("WARRIOR")) {
                const str = characterModels.get("WARRIOR");
                rootNpc.setAttribute("gltf-model", str);
                rootNpc.setAttribute("networked", "template: #warrior-template; attachTemplateToLocal: false;");
            } else {
                const modelNpc = document.createElement("a-sphere");
                modelNpc.setAttribute("scale", "0.1 0.1 0.1");
                modelNpc.setAttribute("position", "0 0 0");
                rootNpc.appendChild(modelNpc);
            }

            const positionNpc = document.createElement("a-entity");
            positionNpc.setAttribute("class", "npc-position");
            positionNpc.setAttribute("position", "0 0 -5");
            rootNpc.appendChild(positionNpc);

            const scene = document.querySelector("a-scene");
            scene.appendChild(rootNpc);
        }

        function removeNpc() {
            const scene = document.querySelector("a-scene");
            const arr = Array.from(document.querySelectorAll(".npc"));
            arr.forEach(a => scene.removeChild(a));
        }

        function addTerrain(item) {
            const [str, collidable, navmesh, ocean, oceanNavmesh, vertex] = JSON.parse(item);
            const rootTerrain = document.createElement("a-entity");
            rootTerrain.setAttribute("class", "clickable");
            rootTerrain.setAttribute("gltf-model", str);
            rootTerrain.setAttribute("position", "0 0 0");
            rootTerrain.setAttribute("shadow", "");
            rootTerrain.setAttribute("terrain-tile", (vertex ?? []).join(" "));
            if (oceanNavmesh) {
                rootTerrain.setAttribute("go-to-sea", "");
                rootTerrain.setAttribute("globe-ocean-nav-mesh", "");
            } else if (navmesh) {
                rootTerrain.setAttribute("globe-nav-mesh", "");
            } else if (ocean) {
                // do nothing
            } else if (collidable) {
                rootTerrain.setAttribute("static-body", "shape: none;");
                rootTerrain.setAttribute("globe-trimesh", "");
                rootTerrain.setAttribute("go-on-land", "");
            } else {
                rootTerrain.setAttribute("static-body", "shape: none;");
                rootTerrain.setAttribute("globe-trimesh", "");
            }

            const scene = document.querySelector("a-scene");
            scene.appendChild(rootTerrain);
        }

        function clearTerrain() {
            const scene = document.querySelector("a-scene");
            const arr = Array.from(document.querySelectorAll("[terrain-tile]"));
            arr.forEach(a => scene.removeChild(a));
        }

        var characterModels = new Map();
        function addCharacterModel(item) {
            const {
                data: str, type
            } = JSON.parse(item);

            characterModels.set(type, str);

            switch (type) {
                case "WARRIOR": {
                    addTemplate("warrior-template", "WARRIOR", "warrior-model");
                    break;
                }
                case "PERSON": {
                    addTemplate("person-template", "PERSON", "person-model");
                    break;
                }
                case "ARROW": {
                    addTemplate("arrow-template", "ARROW", "arrow-model");
                    break;
                }
                case "GOLD_COIN": {
                    addTemplate("gold-coin-template", "GOLD_COIN", "gold-coin-model");
                    break;
                }
                case "SHIP": {
                    addTemplate("ship-template", "SHIP", "ship-model");
                    break;
                }
            }
        }

        function addHouse(item) {
            const {
                type, point, lookAt
            } = JSON.parse(item);

            const rootHouse = document.createElement("a-entity");
            rootHouse.setAttribute("position", `${point[0]} ${point[1]} ${point[2]}`);
            rootHouse.setAttribute("terrain-tile", "");
            rootHouse.setAttribute("building", type.toString().toLowerCase());

            const rootModel = document.createElement("a-entity");
            rootModel.setAttribute("globe-lod", characterModels.get(type));
            if (type === "PORT") {
                rootModel.setAttribute("scale", "0.1 0.1 0.1");
                rootModel.setAttribute("rotation", "90 0 0");
                rootModel.setAttribute("position", "1.35 -1.1 -0.5");
            } else {
                rootModel.setAttribute("scale", "1 1 1");
                rootModel.setAttribute("rotation", "90 0 0");
                rootModel.setAttribute("position", "0 0 0");
            }
            rootHouse.appendChild(rootModel);

            const lod0 = document.createElement("a-entity");
            lod0.setAttribute("class", "lod0 clickable");
            lod0.setAttribute("raze-target", "");
            lod0.setAttribute("spawn-gold", "");
            lod0.setAttribute("shadow", "");
            rootModel.appendChild(lod0);

            const lod1 = document.createElement("a-entity");
            lod1.setAttribute("class", "lod1 clickable");
            lod1.setAttribute("raze-target", "");
            lod1.setAttribute("spawn-gold", "");
            lod1.setAttribute("shadow", "");
            rootModel.appendChild(lod1);

            const lod2 = document.createElement("a-entity");
            lod2.setAttribute("class", "lod2 clickable");
            lod2.setAttribute("raze-target", "");
            lod2.setAttribute("spawn-gold", "");
            lod2.setAttribute("shadow", "");
            rootModel.appendChild(lod2);

            const scene = document.querySelector("a-scene");
            scene.appendChild(rootHouse);

            rootHouse.object3D.up = new THREE.Vector3(point[0], point[1], point[2]).normalize();
            rootHouse.object3D.lookAt(new THREE.Vector3(lookAt[0], lookAt[1], lookAt[2]));
        }

        function addShip(item) {
            if (!!document.querySelector("#box")) {
                return;
            }

            const {
                data: str, point
            } = JSON.parse(item);

            const rootShip = document.createElement("a-entity");
            rootShip.setAttribute("id", "box");
            rootShip.setAttribute("class", "clickable");
            rootShip.setAttribute("dynamic-body", "shape: sphere; sphereRadius: 1; mass: 100");
            rootShip.setAttribute("collision-filter", "group: ship; collidesWith: default, ship");
            rootShip.setAttribute("globe-gravity", "ship: true;");
            rootShip.setAttribute("globe-keyboard-controls", "enabled: true; fly: true");
            rootShip.setAttribute("shadow", "");
            rootShip.setAttribute("position", `${point[0]} ${point[1]} ${point[2]}`);
            rootShip.setAttribute("rotation", "0 0 0");
            rootShip.setAttribute("outline-pass", "");

            const rootModel = document.createElement("a-entity");
            rootModel.setAttribute("class", "data");
            rootModel.setAttribute("gltf-model", str);
            rootModel.setAttribute("go-to-sea", "");
            rootModel.setAttribute("scale", "0.1 0.1 0.1");
            rootModel.setAttribute("rotation", "0 -90 0");
            rootShip.appendChild(rootModel);
            rootShip.setAttribute("networked", "template: #ship-template; attachTemplateToLocal: false;");

            const rootPosition = document.createElement("a-entity");
            rootPosition.setAttribute("id", "box-position");
            rootPosition.setAttribute("position", "0 0 5");
            rootShip.appendChild(rootPosition);

            const scene = document.querySelector("a-scene");
            scene.appendChild(rootShip);
            const cameraEl = document.querySelector("#camera-rig");
            cameraEl.setAttribute("look-at-box", "#box");
        }

        function addClientSecret(item) {
            const {
                roomId,
                clientSecret,
            } = JSON.parse(item);

            window.gmRoomId = roomId;
            window.gmClientSecret = clientSecret;
            window.gmClientSecretMap = new Map();

            const scene = document.querySelector("a-scene");

            scene.setAttribute("networked-scene", `room: ${roomId}; debug: false; adapter: easyrtc; audio: true;`);
        }

        function spawnNpcsNow() {
            window.spawnNpcsFlag = true;
        }
        async function handleWalkingNpcSwitchOnOrNot() {
            const roomManifestResponse = await fetch(`/api/room-manifest/${window.gmRoomId}`);
            const roomManifestJson = await roomManifestResponse.json();
            const {
                roomUser
            } = roomManifestJson;
            const orderedSecrets = roomUser.map(x => x.webrtcId);

            const hostSpanEle = document.getElementById("host-span");

            const currentSet = Array.from(window.gmClientSecretMap.values());
            const firstSecret = orderedSecrets.find(x => currentSet.includes(x));
            if (firstSecret && firstSecret === window.gmClientSecret) {
                spawnNpcsNow();
                hostSpanEle.textContent = "HOST";
            } else {
                hostSpanEle.textContent = "CLIENT";
            }
        }
        const debounceWalkingNpcSwitchOnOrNot = debounce(handleWalkingNpcSwitchOnOrNot.bind(window), 5_000);

        function onConnect() {
            window.gmClientSecretMap.set(NAF.clientId, window.gmClientSecret);
            console.log("INIT", window.gmClientSecretMap);
            debounceWalkingNpcSwitchOnOrNot();

            window.addEventListener("beforeunload", function () {
                easyrtc.disconnect();
            });

            document.body.addEventListener("clientConnected", function (evt) {
                console.log("CONNECTED", evt, window.gmClientSecretMap);
                setTimeout(function () {
                    NAF.connection.broadcastDataGuaranteed("gmShareClientSecret", {
                        clientSecret: window.gmClientSecret
                    });
                }, 500);
            });
            document.body.addEventListener("clientDisconnected", function (evt) {
                console.log("DISCONNECT", evt, window.gmClientSecretMap);
                window.gmClientSecretMap.delete(evt.detail.clientId);
                debounceWalkingNpcSwitchOnOrNot();
            });

            NAF.connection.subscribeToDataChannel("gmShareClientSecret", function (senderId, dataType, data, targetId) {
                console.log("SHARE SECRET", senderId, window.gmClientSecretMap);
                window.gmClientSecretMap.set(senderId, data.clientSecret);
                NAF.connection.sendDataGuaranteed(senderId, "gmReplyClientSecret", {
                    clientSecret: window.gmClientSecret
                });
            });

            NAF.connection.subscribeToDataChannel("gmReplyClientSecret", function (senderId, dataType, data, targetId) {
                console.log("SHARE SECRET", targetId, window.gmClientSecretMap);
                window.gmClientSecretMap.set(senderId, data.clientSecret);
            });

            NAF.connection.subscribeToDataChannel('networkedHealth', function (sender, dataType, data, targetId) {
                const {
                    networkId,
                    hit,
                } = data;
                const entity = NAF.entities.entities[networkId];
                if (entity) {
                    entity.emit("hit", hit);
                }
            });

            let micEnabled = true;
            const micBtnEle = document.getElementById("mic-btn");

            micBtnEle.addEventListener('click', function () {
                NAF.connection.adapter.enableMicrophone(!micEnabled);
                micEnabled = !micEnabled;
                micBtnEle.textContent = micEnabled ? 'Mute Mic' : 'Unmute Mic';
            });
        }
    </script>
    <script type="module">
        import Octree from "threejs-octree";
        import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
        import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
        import { OutlinePass } from "three/addons/postprocessing/OutlinePass.js";
        import { OutputPass } from "three/addons/postprocessing/OutputPass.js";

        AFRAME.registerSystem('npc-finder', {
            schema: {},
            init: function () {
                this.islandNpcs = new Map();
                this.islandNpcList = new Map();
                this.npcs = [];
                this.findNpc = this.findNpc.bind(this);
            },
            registerMe: function (el) {
                const addNpcMeshToOctree = (octree) => {
                    const geometry = new THREE.SphereGeometry();
                    const material = new THREE.MeshStandardMaterial({ color: 0xffffff });
                    const meshNode = new THREE.Mesh(geometry, material);
                    meshNode.visible = false;
                    el.setObject3D('octree-collider', meshNode);
                    octree.addMesh(meshNode);
                };

                const pos = el.object3D.position;
                if (pos.length() === 0) {
                    setTimeout(this.registerMe.bind(this, el), 100);
                    return;
                }

                if (this.el.sceneEl.systems['globe-nav'].navMesh) {
                    const group = this.el.sceneEl.systems['globe-nav'].getGroup(pos);
                    if (this.islandNpcs.has(group)) {
                        const octree = this.islandNpcs.get(group);
                        addNpcMeshToOctree(octree);
                    } else {
                        const octree = new Octree(16, 4);
                        const worldExtents = new THREE.Box3(new THREE.Vector3(-150, -150, -150), new THREE.Vector3(150, 150, 150));
                        octree.initialize(worldExtents.min, worldExtents.max, []);
                        addNpcMeshToOctree(octree);
                        this.islandNpcs.set(group, octree);
                    }
                    if (this.islandNpcList.has(group)) {
                        this.islandNpcList.get(group).push(el);
                    } else {
                        this.islandNpcList.set(group, [el]);
                    }
                    this.npcs.push(el);
                } else {
                    setTimeout(this.registerMe.bind(this, el), 100);
                }
            },
            tick: function () {
                for (const [group, octree] of this.islandNpcs.entries()) {
                    const npcs = this.islandNpcList.get(group);
                    if (npcs) {
                        for (const el of npcs) {
                            const collider = el.getObject3D('octree-collider');
                            if (collider) {
                                octree.updateMesh(collider);
                            }
                        }
                    }
                }
            },
            unregisterMe: function (el) {
                const group = this.el.sceneEl.systems['globe-nav'].getGroup(el.object3D.position);
                if (this.islandNpcs.has(group)) {
                    const octree = this.islandNpcs.get(group);
                    const collider = el.getObject3D('octree-collider');
                    if (collider) {
                        octree.removeMesh(collider);
                    }
                }
                if (this.islandNpcList.has(group)) {
                    const arr = this.islandNpcList.get(group);
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
                {
                    const arr = this.npcs;
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
            },
            findNpc: function (checkingNpc) {
                const factionName = checkingNpc.components['npc-faction'].data;
                const position = new THREE.Vector3().copy(checkingNpc.object3D.position);
                const radius = 20;
                const group = this.el.sceneEl.systems['globe-nav'].getGroup(position);
                if (this.islandNpcs.has(group)) {
                    const octree = this.islandNpcs.get(group);
                    const intersects = octree.intersects(position, radius);
                    const meshes = intersects.array;
                    const els = meshes.map(x => x?.parent?.el ?? x?.el);
                    const filtered = els.filter(x => x && x.components['npc-faction'].data !== factionName);
                    return filtered.sort((a, b) => {
                        const distA = new THREE.Vector3().copy(a.object3D.position).distanceTo(position);
                        const distB = new THREE.Vector3().copy(b.object3D.position).distanceTo(position);
                        return distA - distB;
                    });
                }
                return [];
            },
        });

        AFRAME.registerComponent('npc-finder', {
            schema: {
                active: {type: 'boolean', default: false},
            },
            init: function () {
                this.system = this.el.sceneEl.systems['npc-finder'];
                this.system.registerMe(this.el);
                this.tickCounter = 0;
                this.findTickCount = 120;
                this.innerHandleNavigationGroupChange = this.navigationGroupChange.bind(this);
                this.innerHandleNavigationGroupChanged = this.navigationGroupChanged.bind(this);
                this.el.addEventListener("navigation-group-change", this.innerHandleNavigationGroupChange);
                this.el.addEventListener("navigation-group-changed", this.innerHandleNavigationGroupChanged);
            },
            tick: function () {
                if (!this.data.active) {
                    return;
                }

                if (this.tickCounter < this.findTickCount) {
                    this.tickCounter += 1;
                    return;
                }
                this.tickCounter = 0;

                const els = this.system.findNpc(this.el);
                this.el.emit('npc-attack', els);
            },
            remove: function () {
                this.system.unregisterMe(this.el);
                this.tickCounter = null;
                this.findTickCount = null;
                this.el.removeEventListener("navigation-group-change", this.innerHandleNavigationGroupChange);
                this.el.removeEventListener("navigation-group-changed", this.innerHandleNavigationGroupChanged);
            },
            navigationGroupChange: function () {
                this.system.unregisterMe(this.el);
            },
            navigationGroupChanged: function () {
                this.system.registerMe(this.el);
            },
        });

        AFRAME.registerSystem('outline-pass', {
            schema: {
                edgeStrength: { type: 'number', default: 2 },
                edgeGlow: { type: 'number', default: 1 },
            },
            init: function () {
                this.t = 0;
                this.dt = 0;
                this.selectedObjects = [];
                this.outlinePassFactory();

                this.innerResizeOutlinePass = this.resizeOutlinePass.bind(this);
                window.addEventListener("resize", this.innerResizeOutlinePass);
            },
            remove: function () {
                window.removeEventListener("resize", this.innerResizeOutlinePass);
            },
            resizeOutlinePass: function () {
                const sceneEl = document.querySelector("a-scene");
                if (!sceneEl.renderer || !sceneEl.camera) {
                    const cameraActiveHandler = function () {
                        sceneEl.removeEventListener('camera-set-active', cameraActiveHandler);
                        this.resizeOutlinePass.call(this);
                    }.bind(this);
                    sceneEl.addEventListener('camera-set-active', cameraActiveHandler);
                    return;
                }

                const renderer = sceneEl.renderer;
                const size = renderer.getDrawingBufferSize(new THREE.Vector2());
                this.composer.setSize(size.x, size.y);
                this.outlinePass.setSize(size.x, size.y);
            },
            outlinePassFactory: function () {
                const sceneEl = document.querySelector("a-scene");
                if (!sceneEl.renderer || !sceneEl.camera) {
                    const cameraActiveHandler = function () {
                        sceneEl.removeEventListener('camera-set-active', cameraActiveHandler);
                        this.outlinePassFactory.call(this);
                    }.bind(this);
                    sceneEl.addEventListener('camera-set-active', cameraActiveHandler);
                    return;
                }

                const scene = sceneEl.object3D;
                const renderer = sceneEl.renderer;
                const camera = sceneEl.camera;

                const compose = new EffectComposer(renderer);
                this.composer = compose;

                const renderPass = new RenderPass(scene, camera);
                compose.addPass(renderPass);

                const outlinePass = new OutlinePass(renderer.getDrawingBufferSize(new THREE.Vector2()), scene, camera, this.selectedObjects);
                outlinePass.selectedObjects = this.selectedObjects;
                compose.addPass(outlinePass);

                const params = this.data;
                outlinePass.edgeStrength = params.edgeStrength;
                outlinePass.edgeGlow = params.edgeGlow;
                outlinePass.visibleEdgeColor.set(0x00ff00);
                outlinePass.hiddenEdgeColor.set(0x00ff00);
                this.outlinePass = outlinePass;

                const outputPass = new OutputPass();
                compose.addPass(outputPass);

                this.bind();
            },
            /**
             * Record the timestamp for the current frame.
             * @param {number} t
             * @param {number} dt
             */
            tick: function (t, dt) {
                this.t = t;
                this.dt = dt;
            },
            /**
             * Binds the EffectComposer to the A-Frame render loop.
             * (This is the hacky bit.)
             */
            bind: function () {
                const renderer = this.sceneEl.renderer;
                const render = renderer.render;
                const system = this;
                let isDigest = false;

                renderer.render = function () {
                    if (isDigest) {
                        render.apply(this, arguments);
                    } else {
                        isDigest = true;
                        system.composer.render(system.dt);
                        isDigest = false;
                    }
                };
            },
        });

        AFRAME.registerComponent('outline-pass', {
            schema: {},
            init: function () {
                this.system = this.el.sceneEl.systems['outline-pass'];
                this.system.selectedObjects.push(this.el.object3D);
            },
            remove: function () {
                const idx = this.system.selectedObjects.indexOf(this.el.object3D);
                if (idx >= 0) {
                    this.system.selectedObjects.splice(idx, 1);
                }
            },
        });
    </script>
    <style>
        a-scene {
            width: 256px;
            height: 256px;
        }
        .actions {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: none;
        }
        .button {
            border-radius: 8px;
            background-color: bisque;
            pointer-events: visible;
        }
        .host-span {
            border-radius: 8px;
            background-color: beige;
            pointer-events: none;
            display: inline-block;
        }
    </style>
</head>
<body>
    <a-scene physics="driver: local; gravity: 0 0 0;" globe-nav globe-ocean-nav embedded fog shadow outline-pass id="scene" inspector="url: https://cdn.jsdelivr.net/gh/aframevr/aframe-inspector@master/dist/aframe-inspector.min.js">
        <a-assets>
            <template id="avatar-template">
                <a-entity class="avatar" networked-audio-source>
                </a-entity>
            </template>
        </a-assets>
        <a-entity light="type: ambient; color: #CCC"></a-entity>
        <a-entity light="type: directional; color: #EEE; intensity: 0.8; castShadow: true; shadowCameraBottom: -150; shadowCameraTop: 150; shadowCameraLeft: -150; shadowCameraRight: 150; shadowCameraNear: -150; shadowCameraFar: 150; shadowMapWidth: 1024; shadowMapHeight: 1024;" position="0 1 0" handle-shadow-parameter></a-entity>
        <a-entity light="type: directional; color: #EEE; intensity: 0.15" position="0 -1 0"></a-entity>
        <a-entity id="camera-rig" position="0 105 5" networked="template: #avatar-template; attachTemplateToLocal: false;">
            <a-entity camera look-controls="mouseEnabled: false; touchEnabled: false;" wasd-controls-enabled="false" position="0 1.6 0" cursor="rayOrigin: mouse" raycaster="far: 50; interval: 100; objects: .clickable"></a-entity>
            <a-entity laser-controls="hand: left;" raycaster="far: 50; interval: 100; objects: .clickable"></a-entity>
            <a-entity laser-controls="hand: right;" raycaster="far: 50; interval: 100; objects: .clickable"></a-entity>
        </a-entity>
    </a-scene>
    <div class="actions">
        <button id="mic-btn" type="button" class="button">Mute Mic</button>
        <span id="host-span" class="host-span">Connecting...</span>
    </div>
</body>
</html>