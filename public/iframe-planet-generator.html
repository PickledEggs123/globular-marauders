<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Planet Generator</title>
    <script async src="/es-module-shims.js"></script>

    <script src="/aframe-v1.7.0.min.js"></script>
    <script src="/aframe-physics-system.js"></script>
    <script src="/aframe-extras.min.js"></script>
    <script src="/aframe-physics-extras.min.js"></script>
    <script src="/three-pathfinding.umd.js"></script>
    <script src="/three-to-cannon.umd.js"></script>
    <script src="/aframe-fps-counter-component.min.js"></script>
    <script src="/aframe-look-at-billboard-component.js"></script>
    <script src="/instanced-mesh.min.js"></script>
    <script src="/networked-aframe.js"></script>
    <script src="/three-bvh.umd.cjs"></script>
    <script src="/aframe-html.js"></script>
    <script src="/Tone.js"></script>
    <script src="/seedrandom.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "/three.module.js",
                "three/addons": "/lib/three/addons/",
                "three-nebula": "/lib/three/nebula/",
                "lodash/sample": "/lib/lodash/sample.js",
                "lodash/isNumber": "/lib/lodash/isNumber.js",
                "potpack": "/potpack.js",
                "uuid/v1": "/lib/uuid/v1.js"
            }
        }
    </script>
    <script type="module">
        import ProjectedMaterial from './ProjectedMaterial.module.js';
        import {OBB} from './lib/three/addons/math/OBB.js';
        import ParticleSystem, {
            BoxZone,
            Color,
            CrossZone,
            CustomRenderer,
            ease,
            Emitter,
            Life,
            Mass,
            RadialVelocity,
            Radius,
            Rate,
            Rotate,
            Scale,
            Span,
            Vector3D,
        } from './lib/three/nebula/index.js';
        import {MeshSurfaceSampler} from "./lib/three/addons/math/MeshSurfaceSampler.js";

        const createZone = (position) => {
            const zone = new BoxZone(position.x, position.y, position.z, 5, 5, 5);

            zone.friction = 0.95;
            zone.max = 7;

            return zone;
        };

        const createEmitter = (zone, position, particleType) => {
            const emitter = new Emitter();

            emitter
                .setRate(particleType === 'damage' ? new Rate(new Span(2, 4), new Span(0.5, 1)) : new Rate(new Span(1, 2), new Span(0.5, 1)))
                .addInitializers([
                    new Mass(1),
                    new Radius(0.1, 0.1, false),
                    new Life(2, 4),
                    new RadialVelocity(1, new Vector3D(0, 1, 0), 180),
                ])
                .addBehaviours([
                    new Rotate('random', 'random'),
                    new Scale(0.2, 0.05),

                    new CrossZone(zone, 'bound'),
                    new Color(0xff0000, 'random', Infinity, ease.easeOutQuart),
                ])
                .setPosition(position)
                .emit();

            return emitter;
        };

        AFRAME.registerSystem("damage-particles", {
            schema: {},
            init: function () {
                this.particleSystems = [];
            },
            addParticleSystem: function (particleSystem) {
                const time = +new Date();
                this.particleSystems.push({
                    particleSystem,
                    time,
                });
            },
            tick: function (t, dt) {
                for (const {particleSystem} of this.particleSystems) {
                    particleSystem.update(dt / 1000);
                }
                const newTime = +new Date();
                this.particleSystems = this.particleSystems.filter(x => x.time + 60_000 > newTime);
            },
        });

        AFRAME.registerComponent("damage-particles", {
            schema: {
                particleType: {
                    default: "damage",
                    oneOf: ["damage", "smoke", "dirt", "water"],
                },
            },
            init: function () {
                const position = this.el.object3D.position.clone();
                this.zone = createZone(position);
                this.emitter = createEmitter(this.zone, position, this.data.particleType);

                this.particleSystem = new ParticleSystem();
                this.renderer = new CustomRenderer();

                switch (this.data.particleType) {
                    case "damage": {
                        this.mesh = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 1),
                            new THREE.MeshNormalMaterial()
                        );
                        break;
                    }
                    case "smoke": {
                        const imageElement = document.querySelector("#fog");
                        const textureLoader = new THREE.TextureLoader();
                        const map = textureLoader.load(imageElement.src);
                        this.mesh = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 1),
                            new THREE.MeshStandardMaterial({
                                map,
                                color: '#ffffff',
                                alphaTest: 0.01,
                                transparent: true,
                            })
                        );
                        break;
                    }
                    case "dirt": {
                        const imageElement = document.querySelector("#blob");
                        const textureLoader = new THREE.TextureLoader();
                        const map = textureLoader.load(imageElement.src);
                        this.mesh = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 1),
                            new THREE.MeshStandardMaterial({
                                map,
                                color: '#9B7653',
                                alphaTest: 0.01,
                                transparent: true,
                            })
                        );
                        break;
                    }
                    case "water": {
                        const imageElement = document.querySelector("#fog");
                        const textureLoader = new THREE.TextureLoader();
                        const map = textureLoader.load(imageElement.src);
                        this.mesh = new THREE.Mesh(
                            new THREE.BoxGeometry(1, 1, 1),
                            new THREE.MeshStandardMaterial({
                                map,
                                color: '#5555ff',
                                alphaTest: 0.01,
                                transparent: true,
                            })
                        );
                        break;
                    }
                }
                const mesh = this.mesh;
                const scene = this.el.sceneEl.object3D;

                this.renderer.onParticleCreated = function (p) {
                    p.target = this.targetPool.get(mesh);

                    p.target.position.copy(p.position);
                    scene.add(p.target);
                };

                this.renderer.onParticleUpdate = function (p) {
                    const scale = p.scale;

                    p.target.position.copy(p.position);
                    p.target.rotation.set(p.rotation.x, p.rotation.y, p.rotation.z);
                    p.target.scale.set(scale, scale, scale);
                };

                this.renderer.onParticleDead = function (p) {
                    this.targetPool.expire(p.target);
                    scene.remove(p.target);

                    p.target = null;
                };

                this.particleSystem.addRenderer(this.renderer);
                this.particleSystem.addEmitter(this.emitter);
                this.system.addParticleSystem(this.particleSystem);
            },
            tick: function (t, dt) {
                const position = this.el.object3D.getWorldPosition(new THREE.Vector3());
                this.emitter.position.copy(position);
                this.zone.x = position.x;
                this.zone.y = position.y;
                this.zone.z = position.z;
            },
            remove: function () {
                this.emitter.destroy();
                this.emitter = null;
            },
        });

        AFRAME.registerComponent("orthographic-camera", {
            schema: {},
            init: function () {
                this.camera = new THREE.OrthographicCamera(-10, 10, 10, -10, 0.1, 100);
                this.el.sceneEl.object3D.add(this.camera);
            },
            remove: function () {
                this.el.sceneEl.object3D.remove(this.camera);
                this.camera = null;
            },
            tick: function (t, dt) {
                const camera = this.camera;
                camera.position.copy(this.el.object3D.getWorldPosition(new THREE.Vector3()).normalize().multiplyScalar(150));
                camera.up = new THREE.Vector3(0, 0, -1).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                camera.lookAt(0, 0, 0);
            },
            getCamera: function () {
                return this.camera;
            },
        });

        AFRAME.registerComponent("orthographic-camera-building", {
            schema: {},
            init: function () {
                this.camera = new THREE.OrthographicCamera(-8, 8, 8, -8, 0.1, 100);
                this.el.sceneEl.object3D.add(this.camera);
            },
            remove: function () {
                this.el.sceneEl.object3D.remove(this.camera);
                this.camera = null;
            },
            tick: function (t, dt) {
                const camera = this.camera;
                camera.position.copy(this.el.object3D.getWorldPosition(new THREE.Vector3()).normalize().multiplyScalar(150));
                camera.up = new THREE.Vector3(0, 0, -1).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                camera.lookAt(0, 0, 0);
            },
            getCamera: function () {
                return this.camera;
            },
        });

        AFRAME.registerComponent("obb-attack-forward-wave", {
            schema: {
                center: {
                    type: "vec3",
                    default: new THREE.Vector3(0, 0, 0),
                },
                dimension: {
                    type: "vec3",
                    default: new THREE.Vector3(0, 0, 0),
                },
                debug: {
                    type: "boolean",
                    default: false,
                },
                ratio: {
                    type: "number",
                    default: 0.1
                },
                speed: {
                    type: "number",
                    default: 1,
                },
            },
            multiple: true,
            remove: function () {
                if (this.m) {
                    this.el.sceneEl.object3D.remove(this.m);
                    this.m = null;
                }
                this.b = null;
                this.material = null;

                if (this.fireball) {
                    this.el.removeChild(this.fireball);
                }
                this.fireball = null;
            },
            init: function () {
                this.startTime = null;
                this.endTime = null;
                this.npcSet = new Set();

                this.fireball = null;
            },
            tick: function (t, dt) {
                if (!this.fireball) {
                    this.fireball = document.createElement("a-entity");
                    this.fireball.setAttribute("gltf-model", "/meshes/EpicStore/Fireball/source/Fireball.glb");
                    this.fireball.setAttribute("play-all-animations", "");
                    this.el.appendChild(this.fireball);

                    if (this.fireball.getObject3D("mesh")) {
                        this.startTime = (+new Date() / 1000);
                        this.endTime = this.startTime + this.data.speed;
                    } else {
                        this.fireball.addEventListener("model-loaded", () => {
                            this.startTime = (+new Date() / 1000);
                            this.endTime = this.startTime + this.data.speed;
                        });
                    }
                }

                if (!this.startTime || !this.endTime) {
                    return;
                }

                const dimension = new THREE.Vector3().copy(this.data.dimension);
                const ratioDimension = dimension.clone().multiply(new THREE.Vector3(1, 1, this.data.ratio));
                let center = new THREE.Vector3().copy(this.data.center);
                const ratioCenterStart = center.clone().add(dimension.clone()).sub(ratioDimension.clone());
                const ratioCenterEnd = center.clone().sub(dimension.clone()).add(ratioDimension.clone());
                const linear = THREE.MathUtils.mapLinear(+new Date() / 1000, this.startTime, this.endTime, 0, 1);
                const clamp = THREE.MathUtils.clamp(linear, 0, 1);
                const ratioCenter = new THREE.Vector3().lerpVectors(ratioCenterStart, ratioCenterEnd, clamp);

                if (linear > 1) {
                    this.el.removeAttribute("obb-attack-forward-wave");
                    return;
                }

                center = ratioCenter.clone().negate().applyMatrix4(this.el.object3D.matrixWorld);
                const raycaster = new THREE.Raycaster(center.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), center.clone().negate());
                const intersections = raycaster.intersectObjects([
                    this.el.sceneEl.systems['globe-nav'].getNavMesh(),
                    this.el.sceneEl.systems['globe-ocean-nav'].getNavMesh(),
                ]);
                if (intersections.length === 0) {
                    return;
                }
                center = intersections[0].point;

                if (this.data.debug) {
                    this.b = new THREE.BoxGeometry(1, 1, 1);
                    if (!this.material) {
                        this.material = new THREE.MeshBasicMaterial({
                            color: 0xff0000,
                            wireframe: true
                        });
                    }
                    if (this.m) {
                        this.el.sceneEl.object3D.remove(this.m);
                        this.m = null;
                    }
                    if (!this.m) {
                        this.m = new THREE.Mesh(this.b, this.material);
                        this.m.scale.copy(ratioDimension.clone().multiplyScalar(2));
                        this.m.position.copy(center.clone());
                        this.m.quaternion.copy(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                        this.el.sceneEl.object3D.add(this.m);
                    }
                }

                if (this.fireball) {
                    const scene = this.el.sceneEl.object3D;
                    scene.attach(this.fireball.object3D);
                    this.fireball.object3D.position.copy(center.clone().add(center.clone().normalize()));
                    this.fireball.object3D.up = center.clone().normalize();
                    this.fireball.object3D.quaternion.copy(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                    this.fireball.object3D.scale.copy(new THREE.Vector3(0.2, 0.2, 0.2));
                    this.el.object3D.attach(this.fireball.object3D);
                }

                const obb = new OBB();
                obb.center.copy(center);
                obb.halfSize.copy(ratioDimension);
                obb.rotation.setFromMatrix4(this.el.object3D.matrixWorld);

                const radius = 20;
                const position = center;
                const group = this.el.sceneEl.systems['globe-nav'].getGroup(position);
                const factionName = findParentAttribute(this.el, 'npc-faction').data;
                if (this.el.sceneEl.systems['npc-finder'].islandNpcList.has(group)) {
                    const list = this.el.sceneEl.systems['npc-finder'].islandNpcList.get(group);
                    const els = list.filter(x => {
                        const pos = x.object3D.position;
                        const dist = position.distanceTo(pos);
                        return dist <= radius;
                    });
                    const filtered = els.filter(x => x && x.components['npc-faction'].data !== factionName);
                    const npcs = filtered.sort((a, b) => {
                        const distA = new THREE.Vector3().copy(a.object3D.position).distanceTo(position);
                        const distB = new THREE.Vector3().copy(b.object3D.position).distanceTo(position);
                        return distA - distB;
                    });
                    npcs.forEach(npc => {
                        if (obb.containsPoint(npc.object3D.position)) {
                            if (!this.npcSet.has(npc)) {
                                this.npcSet.add(npc);
                                npc.emit("hit", 100);
                            }
                        }
                    })
                }
            },
        });

        AFRAME.registerComponent("obb-attack-center-wave", {
            schema: {
                center: {
                    type: "vec3",
                    default: new THREE.Vector3(0, 0, 0),
                },
                dimension: {
                    type: "vec3",
                    default: new THREE.Vector3(0, 0, 0),
                },
                debug: {
                    type: "boolean",
                    default: false,
                },
                height: {
                    type: "number",
                    default: 50,
                },
                speed: {
                    type: "number",
                    default: 1,
                },
            },
            multiple: true,
            remove: function () {
                if (this.m) {
                    this.el.sceneEl.object3D.remove(this.m);
                    this.m = null;
                }
                this.b = null;
                this.material = null;

                if (this.fireball) {
                    this.el.removeChild(this.fireball);
                }
                this.fireball = null;
            },
            init: function () {
                this.startTime = null;
                this.endTime = null;
                this.npcSet = new Set();

                this.fireball = null;
            },
            tick: function (t, dt) {
                if (!this.fireball) {
                    this.fireball = document.createElement("a-entity");
                    this.fireball.setAttribute("gltf-model", "/meshes/EpicStore/Fireball/source/Fireball.glb");
                    this.fireball.setAttribute("play-all-animations", "");
                    this.el.appendChild(this.fireball);

                    if (this.fireball.getObject3D("mesh")) {
                        this.startTime = (+new Date() / 1000);
                        this.endTime = this.startTime + this.data.speed;
                    } else {
                        this.fireball.addEventListener("model-loaded", () => {
                            this.startTime = (+new Date() / 1000);
                            this.endTime = this.startTime + this.data.speed;
                        });
                    }
                }

                if (!this.startTime || !this.endTime) {
                    return;
                }

                const dimension = new THREE.Vector3().copy(this.data.dimension);
                let center = new THREE.Vector3().copy(this.data.center);
                const linear = THREE.MathUtils.mapLinear(+new Date() / 1000, this.startTime, this.endTime, 0, 1);
                const clamp = THREE.MathUtils.clamp(linear, 0, 1);

                if (linear > 1) {
                    const obb = new OBB();
                    obb.center.copy(center);
                    obb.halfSize.copy(dimension);
                    obb.rotation.setFromMatrix4(this.el.object3D.matrixWorld);

                    const radius = 20;
                    const position = center;
                    const group = this.el.sceneEl.systems['globe-nav'].getGroup(position);
                    const factionName = findParentAttribute(this.el, 'npc-faction').data;
                    if (this.el.sceneEl.systems['npc-finder'].islandNpcList.has(group)) {
                        const list = this.el.sceneEl.systems['npc-finder'].islandNpcList.get(group);
                        const els = list.filter(x => {
                            const pos = x.object3D.position;
                            const dist = position.distanceTo(pos);
                            return dist <= radius;
                        });
                        const filtered = els.filter(x => x && x.components['npc-faction'].data !== factionName);
                        const npcs = filtered.sort((a, b) => {
                            const distA = new THREE.Vector3().copy(a.object3D.position).distanceTo(position);
                            const distB = new THREE.Vector3().copy(b.object3D.position).distanceTo(position);
                            return distA - distB;
                        });
                        npcs.forEach(npc => {
                            if (obb.containsPoint(npc.object3D.position)) {
                                if (!this.npcSet.has(npc)) {
                                    this.npcSet.add(npc);
                                    npc.emit("hit", 100);
                                }
                            }
                        })
                    }

                    this.el.removeAttribute("obb-attack-center-wave");
                } else {
                    center = center.clone().negate().applyMatrix4(this.el.object3D.matrixWorld);
                    const raycaster = new THREE.Raycaster(center.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), center.clone().negate());
                    const intersections = raycaster.intersectObjects([
                        this.el.sceneEl.systems['globe-nav'].getNavMesh(),
                        this.el.sceneEl.systems['globe-ocean-nav'].getNavMesh(),
                    ]);
                    if (intersections.length === 0) {
                        return;
                    }
                    center = intersections[0].point;
                    const centerStart = new THREE.Vector3().copy(center).add(center.clone().normalize().multiplyScalar(this.data.height));
                    const centerEnd = center.clone();
                    const ratioCenter = new THREE.Vector3().lerpVectors(centerStart, centerEnd, clamp);
                    center = ratioCenter.clone();

                    if (this.data.debug) {
                        this.b = new THREE.BoxGeometry(1, 1, 1);
                        if (!this.material) {
                            this.material = new THREE.MeshBasicMaterial({
                                color: 0xff0000,
                                wireframe: true
                            });
                        }
                        if (this.m) {
                            this.el.sceneEl.object3D.remove(this.m);
                            this.m = null;
                        }
                        if (!this.m) {
                            this.m = new THREE.Mesh(this.b, this.material);
                            this.m.scale.copy(dimension.clone().multiplyScalar(2));
                            this.m.position.copy(center.clone());
                            this.m.up = new THREE.Vector3(0, 0, 1).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                            this.m.lookAt(center.clone());
                            this.el.sceneEl.object3D.add(this.m);
                        }
                    }

                    if (this.fireball) {
                        const scene = this.el.sceneEl.object3D;
                        scene.attach(this.fireball.object3D);
                        this.fireball.object3D.position.copy(center.clone().add(center.clone().normalize()));
                        this.fireball.object3D.up = new THREE.Vector3(0, 0, 1).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                        this.fireball.object3D.lookAt(center.clone());
                        this.fireball.object3D.scale.copy(new THREE.Vector3(0.2, 0.2, 0.2));
                        this.el.object3D.attach(this.fireball.object3D);
                    }
                }
            },
        });

        AFRAME.registerComponent("wizard-mana", {
            init: function () {
                const time = +new Date();
                this.startTime = time - 10_000;
                this.endTime = time;
            },
            shouldAttack: function () {
                const time = +new Date();
                if (time > this.endTime) {
                    this.startTime = time;
                    this.endTime = time + 10_000;
                    return true;
                } else {
                    return false;
                }
            },
            canAttack: function () {
                const time = +new Date();
                return time > this.endTime;
            },
        });

        AFRAME.registerComponent("obb-attack-zone", {
            schema: {
                center: {
                    type: "vec3",
                    default: new THREE.Vector3(0, 0, 0),
                },
                dimension: {
                    type: "vec3",
                    default: new THREE.Vector3(0, 0, 0),
                },
                debug: {
                    type: "boolean",
                    default: false,
                },
            },
            multiple: true,
            remove: function () {
                if (this.m) {
                    this.el.sceneEl.object3D.remove(this.m);
                    this.m = null;
                }
                this.b = null;
                this.material = null;
            },
            tick: function () {
                if (this.data.debug) {
                    this.b = new THREE.BoxGeometry(1, 1, 1);
                    if (!this.material) {
                        this.material = new THREE.MeshBasicMaterial({
                            color: 0xff0000,
                            wireframe: true
                        });
                    }
                    if (this.m) {
                        this.el.sceneEl.object3D.remove(this.m);
                        this.m = null;
                    }
                    if (!this.m) {
                        this.m = new THREE.Mesh(this.b, this.material);
                        this.m.scale.copy(new THREE.Vector3().copy(this.data.dimension).multiplyScalar(2));
                        this.m.position.copy(new THREE.Vector3().copy(this.data.center).negate().applyMatrix4(this.el.object3D.matrixWorld));
                        this.m.quaternion.copy(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                        this.el.sceneEl.object3D.add(this.m);
                    }
                }
            },
            attack: function () {
                if (!findParentAttribute(this.el, "wizard-mana")?.shouldAttack()) {
                    return;
                }

                if (new THREE.Vector3().copy(this.data.center).length() === 0) {
                    if (this.el.hasAttribute("obb-attack-center-wave")) {
                        this.el.removeAttribute("obb-attack-center-wave");
                    }
                    this.el.setAttribute("obb-attack-center-wave", {
                        center: this.data.center,
                        dimension: this.data.dimension,
                        debug: false,
                        height: 20,
                        speed: 2,
                    });
                } else {
                    if (this.el.hasAttribute("obb-attack-forward-wave")) {
                        this.el.removeAttribute("obb-attack-forward-wave");
                    }
                    this.el.setAttribute("obb-attack-forward-wave", {
                        center: this.data.center,
                        dimension: this.data.dimension,
                        debug: false,
                        ratio: 0.2,
                    });
                }
            }
        })

        class NavMeshTriangles {
            constructor(geometry) {
                this.vertices = [];
                for (let i = 0; i < geometry.attributes.position.array.length; i += 3) {
                    const vertex = new THREE.Vector3(
                        geometry.attributes.position.array[i],
                        geometry.attributes.position.array[i + 1],
                        geometry.attributes.position.array[i + 2]
                    );
                    this.vertices.push(vertex);
                }
                this.nextIndex = Math.round(this.vertices.length);
                this.indices = [...geometry.index.array];

                const groupEls = document.querySelectorAll("[grass-particles]");
                const groups = [...groupEls].map(x => ({
                    vertex: new THREE.Vector3().copy(x.components["grass-particles"].data.origin),
                    faces: [],
                }));
                this.faces = [];
                for (let i = 0; i < this.indices.length; i += 3) {
                    this.faces.push(this.makeFaceObject(i));
                }
                this.groups = groups.map(x => ({
                    vertex: x.vertex,
                    faces: this.faces.filter(y => y.centroid.distanceTo(x.vertex) < 30),
                }));

                this.obbs = [];
            }
            makeFaceObject(i) {
                const a = this.indices[i];
                const b = this.indices[i + 1];
                const c = this.indices[i + 2];
                const centroid = new THREE.Vector3().add(this.vertices[a]).add(this.vertices[b]).add(this.vertices[c]).multiplyScalar(1/3);

                const f = {
                    a, b, c,
                    centroid,
                    faceIndex: Math.round(i / 3),
                    center: centroid,
                    radius: 1,
                };

                // compute size of hole in graph for bowyer-watson algorithm
                const {
                    center,
                    radius,
                } = this.computeCircumcircle(f);
                f.center = center;
                f.radius = radius;
                return f;
            }
            computeCircumcircle(face) {
                const a = this.vertices[face.a].clone().normalize();
                const b = this.vertices[face.b].clone().normalize();
                const c = this.vertices[face.c].clone().normalize();

                const computeCenterMaths = [() => {
                    const v1 = a.clone().sub(b.clone()).normalize();
                    const v2 = a.clone().sub(c.clone()).normalize();
                    return new THREE.Vector3().crossVectors(
                        v1,
                        v2
                    ).normalize();
                }, () => {
                    const v1 = b.clone().sub(c.clone()).normalize();
                    const v2 = b.clone().sub(a.clone()).normalize();
                    return new THREE.Vector3().crossVectors(
                        v1,
                        v2
                    ).normalize();
                }, () => {
                    const v1 = c.clone().sub(a.clone()).normalize();
                    const v2 = c.clone().sub(b.clone()).normalize();
                    return new THREE.Vector3().crossVectors(
                        v1,
                        v2
                    ).normalize();
                }]
                for (const math of computeCenterMaths) {
                    const center = math();
                    if (isNaN(center.x) || isNaN(center.y) || isNaN(center.z)) {
                        // skip insertion if normal is NaN.
                        continue;
                    }
                    const radius = center.clone().dot(a.clone());
                    const rb = center.clone().dot(b.clone());
                    const rc = center.clone().dot(c.clone());
                    if (Math.abs(rb - radius) < 0.01 && Math.abs(rc - radius) < 0.01) {
                        return {
                            center,
                            radius,
                        };
                    }
                }
                return null;
            }
            insertPoint(point, closestGroup) {
                this.nextIndex = Math.round(this.vertices.length);
                this.vertices.push(point.clone());

                // create hole in graph
                const intersectingFaces = closestGroup.faces.filter(x => x.center.clone().normalize().dot(point.clone().normalize()) >= x.radius && Math.abs(this.vertices[x.a].clone().length() - this.vertices[x.b].clone().length()) < 0.1 && Math.abs(this.vertices[x.b].clone().length() - this.vertices[x.c].clone().length()) < 0.1);
                const edges = intersectingFaces.reduce((acc, x) => [...acc, [x.a, x.b, x], [x.b, x.c, x], [x.c, x.a, x]], []);
                const badEdges = [...edges.filter(([a,b],i,arr) => arr.some(([c,d]) => a === d && b === c))].sort(([,,a], [,,b]) => b.faceIndex - a.faceIndex);
                const goodEdges = [...edges.filter(([a,b],i,arr) => !arr.some(([c,d]) => a === d && b === c))].sort(([,,a], [,,b]) => b.faceIndex - a.faceIndex);

                // create new indices
                const uniqueFacesToCull = new Set();
                for (const [,,badFace] of badEdges) {
                    const faceIndex = badFace.faceIndex;
                    if (uniqueFacesToCull.has(faceIndex)) {
                        continue;
                    }
                    uniqueFacesToCull.add(faceIndex);

                    this.faces.splice(faceIndex, 1);
                    this.indices.splice(faceIndex * 3, 3);
                }
                for (const [a,b] of goodEdges) {
                    const currentIndex = this.indices.length;
                    this.indices.push(this.nextIndex, a, b);
                    this.faces.push(this.makeFaceObject(currentIndex));
                }

                // fix data after procedure
                for (let i = 0; i < this.faces.length; i++) {
                    this.faces[i].faceIndex = i;
                }
                this.nextIndex = Math.round(this.vertices.length);
            }
            insertMesh(el) {
                const scene = document.querySelector("a-scene");
                if (!scene) {
                    return;
                }
                let m = scene.systems['globe-nav'].getNavMesh();
                if (!m) {
                    return;
                }

                const meshes = [];
                el.object3D.traverse(n => {
                    if (n.isMesh) {
                        meshes.push(n);
                    }
                });

                for (const mesh of meshes) {
                    const geometry = mesh.geometry;
                    geometry.computeBoundingBox();
                }

                const obbs = meshes.map(mesh => {
                    const matrixWorld = new THREE.Matrix4().copy(mesh.matrixWorld);
                    const geometry = mesh.geometry;
                    const obb = new OBB();

                    obb.center.copy(geometry.boundingBox.getCenter(new THREE.Vector3()).applyMatrix4(matrixWorld));
                    obb.halfSize.copy(geometry.boundingBox.getSize(new THREE.Vector3()).multiplyScalar(0.5));
                    obb.rotation.copy(new THREE.Matrix3().setFromMatrix4(matrixWorld));

                    return obb;
                });
                this.obbs.push(...obbs);

                // Function to get OBB corner points
                function getOBBPoints(obb) {
                    const points = [];
                    const dirs = [
                        // new THREE.Vector3(-1, -1, -1),
                        // new THREE.Vector3( 1, -1, -1),
                        // new THREE.Vector3( 1,  1, -1),
                        // new THREE.Vector3(-1,  1, -1),

                        new THREE.Vector3(-1, -1,  1),
                        new THREE.Vector3( 0, -1,  1),
                        new THREE.Vector3( 1, -1,  1),
                        new THREE.Vector3( 1,  0,  1),
                        new THREE.Vector3( 1,  1,  1),
                        new THREE.Vector3( 0,  1,  1),
                        new THREE.Vector3(-1,  1,  1),
                        new THREE.Vector3(-1,  0,  1),
                        new THREE.Vector3( 0,  0,  1),
                    ];
                    dirs.reverse();

                    for (let dir of dirs) {
                        const corner = new THREE.Vector3().copy(obb.center);
                        const basisX = new THREE.Vector3();
                        const basisY = new THREE.Vector3();
                        const basisZ = new THREE.Vector3();
                        obb.rotation.extractBasis(basisX, basisY, basisZ);
                        corner.addScaledVector(basisX, dir.x * obb.halfSize.x);
                        corner.addScaledVector(basisY, dir.y * obb.halfSize.y);
                        corner.addScaledVector(basisZ, dir.z * obb.halfSize.z);
                        points.push(corner);
                    }
                    return points;
                }

                // Get and log OBB points
                const obbPoints = obbs.reduce((acc, obb) => [...acc, ...getOBBPoints(obb)], []);
                const pp = obbPoints[0];
                if (!pp) {
                    return;
                }

                for (const p of obbPoints) {
                    const [,closestGroup] = this.groups.reduce((acc, x) => {
                        const d = x.vertex.distanceTo(pp);
                        if (acc[0] > d) {
                            return [d, x];
                        } else {
                            return acc;
                        }
                    }, [Infinity, null]);
                    if (!closestGroup) {
                        continue;
                    }

                    const raycaster = new THREE.Raycaster(p.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), p.clone().negate());
                    const intersections = raycaster.intersectObjects([
                        scene.systems['globe-nav'].getNavMesh(),
                    ]);
                    if (intersections[0]) {
                        const ip = intersections[0].point.clone();
                        this.insertPoint(ip, closestGroup);

                        const groupEls = document.querySelectorAll("[grass-particles]");
                        const groups = [...groupEls].map(x => ({
                            vertex: new THREE.Vector3().copy(x.components["grass-particles"].data.origin),
                            faces: [],
                        }));
                        this.groups = groups.map(x => ({
                            vertex: x.vertex,
                            faces: this.faces.filter(y => y.centroid.distanceTo(x.vertex) < 30),
                        }));

                        scene.systems['globe-nav'].setNavMeshGeometry(this.getGeometry(true));
                    }
                }
            }
            isPointInObb(obb, point) {
                return obb.clone().containsPoint(point.clone());
            }
            getGeometry(includeObb = false) {
                const ix = [];
                for (let i = 0; i < this.indices.length; i += 3) {
                    // check if face is in obb
                    const ip = this.faces[i / 3].centroid.clone().multiplyScalar(1.001);
                    let obbHit = false;
                    if (!includeObb) {
                        if (this.obbs.some(obb => this.isPointInObb(obb, ip))) {
                            obbHit = true;
                        }
                    }
                    if (obbHit) {
                        continue;
                    }

                    const a = this.indices[i];
                    const b = this.indices[i + 1]
                    const c = this.indices[i + 2];
                    ix.push(a, b, c);
                }
                const vx = [];
                for (let i = 0; i < this.vertices.length; i++) {
                    const x = this.vertices[i];
                    vx.push(
                        x.x, x.y, x.z
                    );
                }
                const g = new THREE.BufferGeometry();
                g.setAttribute("position", new THREE.BufferAttribute(new Float32Array(vx), 3));
                g.setIndex(new THREE.BufferAttribute(new Uint32Array(ix), 1));
                return g;
            }
            getLineSegmentGeometry(includeObb = false) {
                const ix = [];
                for (let i = 0; i < this.indices.length; i += 3) {
                    // check if face is in obb
                    const ip = this.faces[i / 3].centroid.clone().multiplyScalar(1.001);
                    let obbHit = false;
                    if (includeObb) {
                        if (this.obbs.every(obb => !this.isPointInObb(obb, ip))) {
                            obbHit = true;
                        }
                    } else {
                        if (this.obbs.some(obb => this.isPointInObb(obb, ip))) {
                            obbHit = true;
                        }
                    }
                    if (obbHit) {
                        continue;
                    }

                    // insert face
                    const a = this.indices[i];
                    const b = this.indices[i + 1]
                    const c = this.indices[i + 2];
                    ix.push(a, b, b, c, c, a);
                }
                const vx = [];
                for (let i = 0; i < ix.length; i++) {
                    const x = this.vertices[ix[i]];
                    vx.push(
                        x.x, x.y, x.z
                    );
                }
                const v = new THREE.BufferAttribute(new Float32Array(vx), 3);
                const g = new THREE.BufferGeometry();
                g.setAttribute("position", v);
                return g;
            }
        }
        window.NavMeshTriangles = NavMeshTriangles;

        AFRAME.registerComponent("projected-texture", {
            schema: {
                enabled: {
                    type: "boolean",
                    default: false,
                },
                image: {
                    type: "string",
                    default: "",
                },
            },
            multiple: true,
            init: function () {
                this.m = null;
                this.cameraEl = null;
                this.texture = null;
                this.material = null;
            },
            remove: function () {
                if (this.m) {
                    this.el.sceneEl.object3D.remove(this.m);
                }
                this.m = null;
                this.cameraEl = null;
                this.texture = null;
                this.material = null;
            },
            tick: function (t, dt) {
                if (!this.data.enabled) {
                    if (this.m) {
                        this.remove();
                    }
                    return;
                }
                const mesh = this.el.sceneEl.systems['globe-nav-projected'].getNavMesh();
                if (!mesh) {
                    return;
                }
                const geometry = mesh.geometry;
                let texture;
                if (this.texture) {
                    texture = this.texture;
                } else {
                    texture = new THREE.TextureLoader().load(this.data.image);
                    this.texture = texture;
                }
                if (!this.cameraEl) {
                    this.cameraEl = this.el;
                }
                if (!this.cameraEl) {
                    return;
                }
                if (!texture.image) {
                    return;
                }
                const camera = (this.cameraEl.components['orthographic-camera'] ?? this.cameraEl.components['orthographic-camera-building']).getCamera();
                if (!camera) {
                    return;
                }
                let material;
                if (this.material) {
                    material = this.material;
                } else {
                    material = new ProjectedMaterial({
                        camera,
                        texture,
                        textureScale: 1,
                        textureOffset: new THREE.Vector2(0, 0),
                        transparent: true,
                        backgroundOpacity: 0.0,
                    });
                    this.material = material;
                }
                if (!this.m) {
                    const m = new THREE.Mesh(geometry, material);
                    this.el.sceneEl.object3D.add(m);
                    this.m = m;
                }
                material.project(this.m);
            },
        });
    </script>
    <script type="application/javascript">
        class MusicPlayer {
            synth = null;
            synthPart = null;

            start() {
                // already playing do nothing
                if (this.synthPart)
                    return;

                this.startTone().catch(err => {
                    console.log("FAILED TO START MUSIC", err);
                });
            }

            stop() {
                if (this.synthPart) {
                    this.synthPart.stop();
                    this.synthPart.dispose();
                    this.synthPart = null;
                }
                Tone.Transport.stop();
            }

            static firstMelody = [
                // stanza 1
                "C3",
                ["C3", "C3"],
                null,
                ["G3", "A#3"],
                null,
                ["A3", "G3"],
                null,
                null,

                // stanza 3
                "A#3",
                ["A#3", "A3"],
                null,
                ["F3", "G3"],
                null,
                ["C2", "C2"],
                null,
                null,

                // stanza 2
                "C3",
                ["C3", "C3"],
                null,
                ["G3", "A#3"],
                null,
                ["A3", "G3"],
                null,
                null,

                // stanza 4
                "A#3",
                ["A#3", "A3"],
                null,
                ["F3", "G3"],
                null,
                ["C2", "C2"],
                null,
                null,
                "END"
            ];
            static secondMelody = [
                // stanza 1
                "C3",
                "D3",
                "Eb3",
                null,

                // stanza 2
                "Eb3",
                null,
                "D3",
                null,

                // stanza 3
                "Eb3",
                "D3",
                "C3",
                null,

                // stanza 4
                "A2",
                null,
                "A#2",
                null,

                // stanza 1
                "C3",
                "D3",
                "Eb3",
                null,

                // stanza 2
                "Eb3",
                null,
                "D3",
                null,

                // stanza 3
                "Eb3",
                "D3",
                "C3",
                null,

                // stanza 4
                "A2",
                null,
                "A#2",
                null,
                "END"
            ];
            static thirdMelody = [
                // stanza 1
                "C3",
                "G2",
                "A2",
                "A#2",
                "A2",
                "G2",

                // stanza 2
                "C3",
                "G2",
                "A2",
                "A#2",
                "A2",
                "G2",

                // stanza 3
                "C3",
                "G2",
                "A2",
                "A#2",
                "A2",
                "G2",

                // stanza 4
                "A2",
                "G2",
                "F2",
                "G2",
                "C2",
                "C2",
                "END"
            ];
            static forthMelody = [
                // stanza 1
                "C3",
                null,
                "G3",
                "G3",
                null,
                null,

                // stanza 2
                "F3",
                null,
                "Eb3",
                "C3",
                null,
                null,

                // stanza 3
                "D3",
                null,
                "Eb3",
                "D3",
                null,
                null,

                // stanza 4
                "C3",
                null,
                "B2",
                "C3",
                null,
                null,
                "END"
            ];

            melodyMap = [{
                id: "main",
                next: "main2",
                notes: MusicPlayer.firstMelody
            }, {
                id: "main2",
                next: "main3",
                notes: MusicPlayer.secondMelody
            }, {
                id: "main3",
                next: "main4",
                notes: MusicPlayer.thirdMelody
            }, {
                id: "main4",
                next: "main5",
                notes: MusicPlayer.thirdMelody
            }, {
                id: "main5",
                next: "main6",
                notes: MusicPlayer.secondMelody
            }, {
                id: "main6",
                next: "main7",
                notes: MusicPlayer.forthMelody
            }, {
                id: "main7",
                next: "main",
                notes: MusicPlayer.forthMelody
            }];
            currentMelody = "main7";

            getNextMelody() {
                const melodyNode = this.melodyMap.find(m => m.id === this.currentMelody);
                if (melodyNode) {
                    const nextMelodyNode = this.melodyMap.find(m => m.id === melodyNode.next);
                    if (nextMelodyNode) {
                        this.currentMelody = nextMelodyNode.id;
                        return nextMelodyNode.notes;
                    }
                }
                const firstMelodyNode = this.melodyMap[0];
                if (firstMelodyNode) {
                    this.currentMelody = firstMelodyNode.id;
                    return firstMelodyNode.notes;
                }
                throw new Error("Could not find melody node to play next sound");
            }

            /**
             * Handle the playing of music and the transition between melodies.
             * @param time
             * @param note
             */
            handleToneSequenceCallback = (time, note) => {
                if (note === "END") {
                    this.setupMelody(this.getNextMelody());
                    if (this.synthPart) {
                        this.synthPart.start(Tone.Transport.seconds);
                    }
                    return;
                }
                if (this.synth && note) {
                    this.synth.triggerAttackRelease(note, "10hz", time);
                }
            };

            setupMelody(notes) {
                // clean up old synth parts
                if (this.synthPart) {
                    this.synthPart.stop();
                    this.synthPart.dispose();
                    this.synthPart = null;
                }
                this.synthPart = new Tone.Sequence(
                    this.handleToneSequenceCallback,
                    notes,
                    "4n"
                );
                this.synthPart.loop = false;
            }

            async startTone() {
                await Tone.start();

                this.synth = new Tone.PolySynth(Tone.Synth).toDestination();

                // first melody
                this.setupMelody(this.getNextMelody());
                if (this.synthPart) {
                    this.synthPart.start(Tone.Transport.seconds);
                }
                Tone.Transport.start();
            }
        }
        window.musicPlayer = new MusicPlayer();

        let playMusic = true;
        function setPlayMusic(p) {
            playMusic = p;
            if (playMusic) {
                window.musicPlayer.start();
            } else {
                window.musicPlayer.stop();
            }
        }

        let isDemoMode = true;
        function setDemo(b) {
            isDemoMode = b;
            if (document.querySelector("#port-menu")) {
                document.querySelector("a-scene").setAttribute("xr-mode-ui", "enabled: false");
            } else {
                setTimeout(() => {
                    setDemo(b);
                }, 10);
            }
        }
        function addMovingCamera() {
            const scene = document.querySelector("a-scene");
            if (scene) {
                const cameraRig = scene.querySelector("#camera-rig");
                const demoNode = scene.querySelector("#demo-node");
                const demoNodePosition = scene.querySelector("#demo-node-position");
                if (cameraRig && demoNode && demoNodePosition) {
                    cameraRig.setAttribute("look-at-box", "#demo-node");
                    demoNode.setAttribute("moving-camera", "");
                    demoNode.setAttribute("dynamic-body", "shape: sphere; sphereRadius: 1; mass: 100");
                    demoNode.setAttribute("collision-filter", "group: ship; collidesWith: default");
                    demoNode.setAttribute("globe-gravity", "ship: true;");
                    return;
                }
            }
            setTimeout(() => {
                addMovingCamera();
            }, 10);
        }

        AFRAME.registerComponent("moving-camera", {
            schema: {
            },
            tick: function (t, dt) {

                this.el.object3D.position.copy(new THREE.Vector3(0, Math.cos(t * 0.000_033), Math.sin(t * 0.000_033)).multiplyScalar(PLANET_SIZE + 10));
                console.log(this.el.object3D.position)
            },
        });

        setDemo(isDemoMode);

        const PLANET_SIZE = 100;

        // Add the extension functions
        THREE.BufferGeometry.prototype.computeBoundsTree = MeshBVHLib.computeBoundsTree;
        THREE.BufferGeometry.prototype.disposeBoundsTree = MeshBVHLib.disposeBoundsTree;
        THREE.Mesh.prototype.raycast = MeshBVHLib.acceleratedRaycast;

        THREE.BatchedMesh.prototype.computeBoundsTree = MeshBVHLib.computeBatchedBoundsTree;
        THREE.BatchedMesh.prototype.disposeBoundsTree = MeshBVHLib.disposeBatchedBoundsTree;
        THREE.BatchedMesh.prototype.raycast = MeshBVHLib.acceleratedRaycast;

        const buildBoundsTree = (e) => {
            const meshes = [];
            e.detail.model.traverse((x) => {
                if (x.isMesh) {
                    meshes.push(x);
                }
            });
            meshes.forEach((m) => m.geometry.computeBoundsTree());
        };

        function debounce(function_, wait = 100, options = {}) {
            if (typeof function_ !== 'function') {
                throw new TypeError(`Expected the first parameter to be a function, got \`${typeof function_}\`.`);
            }

            if (wait < 0) {
                throw new RangeError('`wait` must not be negative.');
            }

            // TODO: Deprecate the boolean parameter at some point.
            const {immediate} = typeof options === 'boolean' ? {immediate: options} : options;

            let storedContext;
            let storedArguments;
            let timeoutId;
            let timestamp;
            let result;

            function run() {
                const callContext = storedContext;
                const callArguments = storedArguments;
                storedContext = undefined;
                storedArguments = undefined;
                result = function_.apply(callContext, callArguments);
                return result;
            }

            function later() {
                const last = Date.now() - timestamp;

                if (last < wait && last >= 0) {
                    timeoutId = setTimeout(later, wait - last);
                } else {
                    timeoutId = undefined;

                    if (!immediate) {
                        result = run();
                    }
                }
            }

            const debounced = function (...arguments_) {
                // if (storedContext && this !== storedContext) {
                //     throw new Error('Debounced method called with different contexts.');
                // }

                storedContext = this; // eslint-disable-line unicorn/no-this-assignment
                storedArguments = arguments_;
                timestamp = Date.now();

                const callNow = immediate && !timeoutId;

                if (!timeoutId) {
                    timeoutId = setTimeout(later, wait);
                }

                if (callNow) {
                    result = run();
                }

                return result;
            };

            debounced.clear = () => {
                if (!timeoutId) {
                    return;
                }

                clearTimeout(timeoutId);
                timeoutId = undefined;
            };

            debounced.flush = () => {
                if (!timeoutId) {
                    return;
                }

                debounced.trigger();
            };

            debounced.trigger = () => {
                result = run();

                debounced.clear();
            };

            return debounced;
        }

        /**
         * Throttle execution of a function. Especially useful for rate limiting
         * execution of handlers on events like resize and scroll.
         *
         * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)
         *                                            are most useful.
         * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,
         *                                            as-is, to `callback` when the throttled-function is executed.
         * @param {object} [options] -              An object to configure options.
         * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds
         *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed
         *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for
         *                                            `delay` milliseconds, the internal counter is reset).
         * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback
         *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that
         *                                            callback will never executed if both noLeading = true and noTrailing = true.
         * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is
         *                                            false (at end), schedule `callback` to execute after `delay` ms.
         *
         * @returns {Function} A new, throttled, function.
         */
        const throttle = function (delay, callback, options) {
            const {
                noTrailing = false,
                noLeading = false,
                debounceMode = undefined
            } = options || {};
            /*
             * After wrapper has stopped being called, this timeout ensures that
             * `callback` is executed at the proper times in `throttle` and `end`
             * debounce modes.
             */
            let timeoutID;
            let cancelled = false;

            // Keep track of the last time `callback` was executed.
            let lastExec = 0;

            // Function to clear existing timeout
            function clearExistingTimeout() {
                if (timeoutID) {
                    clearTimeout(timeoutID);
                }
            }

            // Function to cancel next exec
            function cancel(options) {
                const { upcomingOnly = false } = options || {};
                clearExistingTimeout();
                cancelled = !upcomingOnly;
            }

            /*
             * The `wrapper` function encapsulates all of the throttling / debouncing
             * functionality and when executed will limit the rate at which `callback`
             * is executed.
             */
            function wrapper(...arguments_) {
                let self = this;
                let elapsed = Date.now() - lastExec;

                if (cancelled) {
                    return;
                }

                // Execute `callback` and update the `lastExec` timestamp.
                function exec() {
                    lastExec = Date.now();
                    callback.apply(self, arguments_);
                }

                /*
                 * If `debounceMode` is true (at begin) this is used to clear the flag
                 * to allow future `callback` executions.
                 */
                function clear() {
                    timeoutID = undefined;
                }

                if (!noLeading && debounceMode && !timeoutID) {
                    /*
                     * Since `wrapper` is being called for the first time and
                     * `debounceMode` is true (at begin), execute `callback`
                     * and noLeading != true.
                     */
                    exec();
                }

                clearExistingTimeout();

                if (debounceMode === undefined && elapsed > delay) {
                    if (noLeading) {
                        /*
                         * In throttle mode with noLeading, if `delay` time has
                         * been exceeded, update `lastExec` and schedule `callback`
                         * to execute after `delay` ms.
                         */
                        lastExec = Date.now();
                        if (!noTrailing) {
                            timeoutID = setTimeout(debounceMode ? clear : exec, delay);
                        }
                    } else {
                        /*
                         * In throttle mode without noLeading, if `delay` time has been exceeded, execute
                         * `callback`.
                         */
                        exec();
                    }
                } else if (noTrailing !== true) {
                    /*
                     * In trailing throttle mode, since `delay` time has not been
                     * exceeded, schedule `callback` to execute `delay` ms after most
                     * recent execution.
                     *
                     * If `debounceMode` is true (at begin), schedule `clear` to execute
                     * after `delay` ms.
                     *
                     * If `debounceMode` is false (at end), schedule `callback` to
                     * execute after `delay` ms.
                     */
                    timeoutID = setTimeout(
                        debounceMode ? clear : exec,
                        debounceMode === undefined ? delay - elapsed : delay
                    );
                }
            }

            wrapper.cancel = cancel;

            // Return the wrapper function.
            return wrapper;
        }

        const buildingLodHashmap = new Map();
        function getBuildingLodHash(url, capacity, updateMode) {
            const randomString = 'a' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
            if (buildingLodHashmap.has(url)) {
                return buildingLodHashmap.get(url);
            } else {
                buildingLodHashmap.set(url, randomString);

                const scene = document.querySelector("a-scene");
                const entity = document.createElement("a-entity");
                entity.setAttribute("id", randomString);
                entity.setAttribute("gltf-model", url);
                entity.setAttribute("instanced-mesh", `capacity: ${capacity}; positioning: world; updateMode: ${updateMode};`);
                entity.addEventListener("model-loaded", buildBoundsTree);
                scene.appendChild(entity);

                return randomString;
            }
        }
        AFRAME.registerComponent('globe-networked-instanced-mesh-member', {
            schema: {
                meshUrl: {type: 'string', default: ""},
                capacity: {type: 'number', default: 100},
                updateMode: {type: 'string', default: "auto"},
                memberMesh: {type: 'boolean', default: false},
                ghostBuilding: {type: 'boolean', default: false},
            },
            init: function () {
                this.done = false;
            },
            tick: function () {
                if (this.done) {
                    return;
                }

                const data = this.data;
                const id = getBuildingLodHash(data.meshUrl, data.capacity, data.updateMode);
                let mesh;
                try {
                    const scene = document.querySelector("a-scene");
                    mesh = scene.querySelector(`#${id}`);
                } catch {}
                if (!mesh) {
                    return;
                }
                const gltf = mesh.getObject3D("mesh");
                if (!gltf) {
                    return;
                }
                this.el.setAttribute("instanced-mesh-member", `mesh: #${id}; memberMesh: ${data.memberMesh};`);

                if (data.ghostBuilding) {
                }

                this.done = true;
            }
        });

        AFRAME.registerComponent('globe-lod', {
            schema: {
                default: "",
            },
            counter: 1,
            update: function () {
                const data = this.data.split("|");

                const lod0 = this.el.querySelector(".lod0");
                const lod1 = this.el.querySelector(".lod1");
                const lod2 = this.el.querySelector(".lod2");
                if (!lod0 || !lod1 || !lod2) {
                    return;
                }

                const lod0Mesh = getBuildingLodHash(data[0], 3000, "manual");
                const lod1Mesh = getBuildingLodHash(data[1], 3000, "manual");
                const lod2Mesh = getBuildingLodHash(data[2], 3000, "manual");

                const checkLoadedModel = (lodNode, id) => {
                    const interval = setInterval(() => {
                        let mesh;
                        try {
                            const scene = document.querySelector("a-scene");
                            mesh = scene.querySelector(`#${id}`);
                        } catch {}
                        if (!mesh) {
                            return;
                        }
                        const gltf = mesh.getObject3D("mesh");
                        if (!gltf) {
                            return;
                        }
                        lodNode.setAttribute("instanced-mesh-member", `mesh: #${id}; memberMesh: true;`);
                        clearInterval(interval);
                    }, 10);
                };
                checkLoadedModel(lod0, lod0Mesh);
                checkLoadedModel(lod1, lod1Mesh);
                checkLoadedModel(lod2, lod2Mesh);
            },
            tick: function (t, dt) {
                if (this.counter > 0) {
                    this.counter -= dt / 1000;
                    return;
                }
                this.counter = 1;

                const object3D = this.el.object3D;
                const pos = object3D.getWorldPosition(new THREE.Vector3());

                const cameraEl = document.querySelector("#camera-rig");
                const cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());

                const distance = pos.distanceTo(cameraPos);

                const lod0 = this.el.querySelector(".lod0");
                const lod1 = this.el.querySelector(".lod1");
                const lod2 = this.el.querySelector(".lod2");
                if (!lod0 || !lod1 || !lod2) {
                    return;
                }
                if (distance >= 40) {
                    lod0.setAttribute("visible", "false");
                    lod1.setAttribute("visible", "false");
                    lod2.setAttribute("visible", "false");
                    lod0.components.visible.update();
                    lod1.components.visible.update();
                    lod2.components.visible.update();
                    lod0.emit("object3DUpdated");
                    lod1.emit("object3DUpdated");
                    lod2.emit("object3DUpdated");
                } else if (distance >= 20) {
                    lod0.setAttribute("visible", "false");
                    lod1.setAttribute("visible", "false");
                    lod2.setAttribute("visible", "true");
                    lod0.components.visible.update();
                    lod1.components.visible.update();
                    lod2.components.visible.update();
                    lod0.emit("object3DUpdated");
                    lod1.emit("object3DUpdated");
                    lod2.emit("object3DUpdated");
                } else if (distance >= 10) {
                    lod0.setAttribute("visible", "false");
                    lod1.setAttribute("visible", "true");
                    lod2.setAttribute("visible", "false");
                    lod0.components.visible.update();
                    lod1.components.visible.update();
                    lod2.components.visible.update();
                    lod0.emit("object3DUpdated");
                    lod1.emit("object3DUpdated");
                    lod2.emit("object3DUpdated");
                } else if (distance >= 0) {
                    lod0.setAttribute("visible", "true");
                    lod1.setAttribute("visible", "false");
                    lod2.setAttribute("visible", "false");
                    lod0.emit("object3DUpdated");
                    lod1.emit("object3DUpdated");
                    lod2.emit("object3DUpdated");
                }

                // auto update clickable
                const className = "clickable";
                if (distance >= 40 && this.el.classList.contains(className)) {
                    this.el.classList.remove(className);
                } else if (!(distance >= 40) && !this.el.classList.contains(className)) {
                    this.el.classList.add(className);
                }
            }
        });

        AFRAME.registerComponent('globe-gravity', {
            schema: {
                ship: {type: 'boolean', default: false},
                buoyancy: {type: 'boolean', default: true},
            },
            tick: function (t, dt) {
                const object3D = this.el.object3D;
                const trueUpDistance = object3D.getWorldPosition(new THREE.Vector3());
                const trueUp = trueUpDistance.clone().normalize();
                const currentUp = new THREE.Vector3(0, 1, 0).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                const currentForward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                const currentRight = new THREE.Vector3(1, 0, 0).applyQuaternion(this.el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                const diffUp = trueUp.clone().sub(currentUp.clone());

                // apply gravity force
                const gravityForce = this.el.body.mass * 10;
                this.el.body.applyForce(new CANNON.Vec3(-trueUp.x, -trueUp.y, -trueUp.z).scale(gravityForce * 60 * dt / 1000), new CANNON.Vec3(0, 0, 0));

                // apply drag
                this.el.body.applyForce(this.el.body.velocity.clone().scale(-25), new CANNON.Vec3(0, 0, 0));

                if (this.data.ship) {
                    if (this.data.buoyancy) {
                        // apply sideways tilt force
                        const sidewaysTilt = this.el.body.velocity.clone().scale(100).dot(currentRight.clone());
                        const tiltForce = new CANNON.Vec3(currentRight.x, currentRight.y, currentRight.z).scale(sidewaysTilt);
                        const tiltPoint = new CANNON.Vec3(currentUp.x, currentUp.y, currentUp.z);
                        this.el.body.applyForce(tiltForce.clone().scale(60 * dt / 1000), tiltPoint.clone());
                        this.el.body.applyForce(tiltForce.clone().scale(-60 * dt / 1000), tiltPoint.clone().scale(-1));

                        // apply up right force
                        const springForce = 300;
                        const rotateForce = new CANNON.Vec3(diffUp.x, diffUp.y, diffUp.z).scale(springForce);
                        const rotatePoint = new CANNON.Vec3(currentUp.x, currentUp.y, currentUp.z);
                        const dragForce = this.el.body.angularVelocity.clone().cross(rotatePoint.clone()).scale(100);
                        this.el.body.applyForce(rotateForce.clone().vsub(dragForce).scale(60 * dt / 1000), rotatePoint.clone());
                        this.el.body.applyForce(rotateForce.clone().vsub(dragForce).scale(-60 * dt / 1000), rotatePoint.clone().scale(-1));

                        // apply horizontal drag
                        const horizontalRotatePoint = new CANNON.Vec3(currentForward.x, currentForward.y, currentForward.z);
                        const horizontalDragForce = this.el.body.angularVelocity.clone().cross(horizontalRotatePoint.clone()).scale(100);
                        this.el.body.applyForce(horizontalDragForce.clone().scale(-1), horizontalRotatePoint.clone());
                        this.el.body.applyForce(horizontalDragForce.clone(), horizontalRotatePoint.clone().scale(-1));
                    }

                    if (trueUpDistance.length() < PLANET_SIZE + 1) {
                        const trueUpMagnitude = -(trueUpDistance.length() - PLANET_SIZE - 1);
                        const trueUpForce = new CANNON.Vec3(trueUp.x, trueUp.y, trueUp.z).scale(trueUpMagnitude * (this.data.buoyancy ? 1000 : 10));
                        this.el.body.applyForce(trueUpForce.scale(60 * dt / 1000), new CANNON.Vec3(0, 0, 0));
                    }
                }
            }
        });

        AFRAME.registerComponent('globe-trimesh', {
            schema: {},
            init: function () {
                this.el.addEventListener('model-loaded', () => {
                    const obj = this.el.getObject3D('mesh');
                    const result = threeToCannon.getShapeParameters(obj, { type: threeToCannon.ShapeType.MESH });
                    const body = this.el.components['static-body'].body;
                    this.addShapes.call(this, body, result);
                });
            },
            addShapes: function (body, result) {
                if (body) {
                    body.shapes.splice(0, body.shapes.length);
                    body.shapeOffsets.splice(0, body.shapeOffsets.length)
                    body.shapeOrientations.splice(0, body.shapeOrientations.length)
                    if (result !== null) {
                        const {
                            offset,
                            orientation,
                            params: {
                                vertices,
                                indices,
                            },
                        } = result;
                        const shape = new CANNON.Trimesh(vertices, indices);
                        this.el.components['static-body'].addShape(shape, offset, orientation);
                    }
                }
            },
        });

        AFRAME.registerComponent('cursor-updater', {
            dependencies: ['cursor', 'raycaster'],
            schema: {},
            init: function () {
                this.clientX = 0;
                this.clientY = 0;
                this.handleMouseMove = this.handleMouseMove.bind(this);
                this.el.sceneEl.addEventListener("mousemove", this.handleMouseMove);
            },
            remove: function () {
                this.el.sceneEl.removeEventListener("mousemove", this.handleMouseMove);
            },
            handleMouseMove: function (evt) {
                if (evt.detail.synthetic) {
                    return;
                }
                this.clientX = evt.clientX;
                this.clientY = evt.clientY;
            },
            tick: function () {
                this.el.components['cursor'].onMouseMove(new MouseEvent("mousemove", {
                    clientX: this.clientX,
                    clientY: this.clientY,
                    bubbles: true,
                    cancelable: true,
                    detail: {
                        synthetic: true
                    }
                }));
                this.el.components['raycaster'].checkIntersections();
            },
        });

        AFRAME.registerComponent('look-at-box', {
            schema: {
                type: "string",
                default: ".ship-1:first-of-type",
            },
            init: function () {
                this.dtSumTickSize = 5000;
                this.dtSum = this.dtSumTickSize + 1;
                this.heightDiff = 5;
                this.heightDiffLerp = 5;
            },
            update(oldData) {
                this.dtSum = this.dtSumTickSize + 1;
            },
            tick: function (t, dt) {
                // get elements
                let [dataItem, dataPostfix] = this.data.split(":");
                let otherClassName = "";
                if (dataPostfix) {
                    [dataPostfix, otherClassName] = dataPostfix.split(" ", 2);
                    dataPostfix = `:${dataPostfix}`;
                    if (otherClassName) {
                        otherClassName = ` ${otherClassName}`;
                    } else {
                        otherClassName = "";
                    }
                }
                const boxSelector = `${dataItem}${otherClassName}`;
                const boxPosSelector = `${dataItem}${otherClassName}-position`;
                const box = Array.from(document.querySelectorAll(boxSelector)).map(el => el.object3D);
                const boxPos = Array.from(document.querySelectorAll(boxPosSelector)).map(el => el.object3D);
                if (!box.length || !boxPos.length) {
                    return;
                }
                if (dataPostfix) {
                    box.splice(1, box.length - 1);
                    boxPos.splice(1, boxPos.length - 1);
                }

                // get position
                const boxWorldPos = new THREE.Vector3();
                box.forEach(b => boxWorldPos.add(b.getWorldPosition(new THREE.Vector3())));
                boxWorldPos.divideScalar(box.length);
                const boxPosWorldPos = new THREE.Vector3();
                boxPos.forEach(b => boxPosWorldPos.add(b.getWorldPosition(new THREE.Vector3())));
                boxPosWorldPos.divideScalar(boxPos.length);
                if (!boxPos.length) {
                    return;
                }

                // get info
                const upVector = boxPosWorldPos.clone().sub(new THREE.Vector3(0, 0, 0)).normalize();
                const object3D = this.el.object3D;
                const objectWorldPos = object3D.getWorldPosition(new THREE.Vector3());
                const height = THREE.MathUtils.clamp(boxPosWorldPos.clone().sub(new THREE.Vector3(0, 0, 0)).length(), 100, 150);

                // update info
                const quaternion = new THREE.Quaternion().setFromUnitVectors(objectWorldPos.clone().normalize(), boxPosWorldPos.clone().normalize());
                const slerp = new THREE.Quaternion().slerp(quaternion, 0.03 * 60 * dt / 1000);
                let destination1 = objectWorldPos.clone().normalize().multiplyScalar(height + 5).applyQuaternion(slerp);

                // compute raycast towards ground
                let finalPosition;
                if (this.dtSum + dt > this.dtSumTickSize) {
                    const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), destination1.clone().negate());
                    const intersections = raycaster.intersectObjects(Array.from(document.querySelectorAll(".clickable")).map(el => el.object3D));
                    if (intersections[0]) {
                        destination1 = intersections[0].point.clone();
                    }
                    finalPosition = destination1.clone().add(destination1.clone().normalize().multiplyScalar(5));
                    this.heightDiff = THREE.MathUtils.clamp(new THREE.Vector3().distanceTo(finalPosition) - (height + 5), -5, 5);
                    this.heightDiffLerp = 0.1 * this.heightDiff + 0.9 * this.heightDiffLerp;
                    this.dtSum = 0;
                } else {
                    if (this.heightDiff > this.heightDiffLerp) {
                        this.heightDiffLerp = 0.03 * this.heightDiff + 0.97 * this.heightDiffLerp;
                    } else {
                        this.heightDiffLerp = 0.01 * this.heightDiff + 0.99 * this.heightDiffLerp;
                    }
                    finalPosition = objectWorldPos.clone().normalize().multiplyScalar(this.heightDiffLerp + height + 5).applyQuaternion(slerp);
                    this.dtSum += dt;
                }

                // update camera
                const cameraLookControlsEl = document.querySelector('[globe-look-controls]');
                object3D.position.set(finalPosition.x, finalPosition.y, finalPosition.z);
                if (this.el.sceneEl?.renderer?.xr?.isPresenting || cameraLookControlsEl.components['globe-look-controls']?.magicWindowControls?.enabled) {
                    object3D.up = upVector;
                    object3D.lookAt(boxWorldPos.clone().add(upVector.clone().add(upVector.clone().multiplyScalar(5))));
                } else {
                    const camera = this.el.sceneEl.camera;
                    camera.up = upVector;
                    camera.lookAt(boxWorldPos);
                }
            }
        });

        AFRAME.registerComponent('globe-look-controls', {
            dependencies: ['position', 'rotation'],

            schema: {
                enabled: {default: true},
                magicWindowTrackingEnabled: {default: true},
                pointerLockEnabled: {default: false},
                reverseMouseDrag: {default: false},
                reverseTouchDrag: {default: false},
                touchEnabled: {default: true},
                mouseEnabled: {default: true}
            },

            init: function () {
                this.deltaYaw = 0;
                this.previousHMDPosition = new THREE.Vector3();
                this.hmdQuaternion = new THREE.Quaternion();
                this.magicWindowAbsoluteQuaternion = new THREE.Quaternion();
                this.magicWindowDeltaQuaternion = new THREE.Quaternion();
                this.position = new THREE.Vector3();
                this.magicWindowObject = new THREE.Object3D();
                this.rotation = {};
                this.deltaRotation = {};
                this.savedPose = null;
                this.pointerLocked = false;
                this.setupMouseControls();
                this.bindMethods();
                this.previousMouseEvent = {};

                this.setupMagicWindowControls();

                // To save / restore camera pose
                this.savedPose = {
                    position: new THREE.Vector3(),
                    rotation: new THREE.Euler()
                };

                // Call enter VR handler if the scene has entered VR before the event listeners attached.
                if (this.el.sceneEl.is('vr-mode') || this.el.sceneEl.is('ar-mode')) { this.onEnterVR(); }
            },

            setupMagicWindowControls: function () {
                var magicWindowControls;
                var data = this.data;

                // Only on mobile devices and only enabled if DeviceOrientation permission has been granted.
                if (AFRAME.utils.device.isMobile() || AFRAME.utils.device.isMobileDeviceRequestingDesktopSite()) {
                    magicWindowControls = this.magicWindowControls = new THREE.DeviceOrientationControls(this.magicWindowObject);
                    if (typeof DeviceOrientationEvent !== 'undefined' && DeviceOrientationEvent.requestPermission) {
                        magicWindowControls.enabled = false;
                        if (this.el.sceneEl.components['device-orientation-permission-ui'].permissionGranted) {
                            magicWindowControls.enabled = data.magicWindowTrackingEnabled;
                        } else {
                            this.el.sceneEl.addEventListener('deviceorientationpermissiongranted', function () {
                                magicWindowControls.enabled = data.magicWindowTrackingEnabled;
                            });
                        }
                    }
                }
            },

            update: function (oldData) {
                var data = this.data;

                // Disable grab cursor classes if no longer enabled.
                if (data.enabled !== oldData.enabled) {
                    this.updateGrabCursor(data.enabled);
                }

                // Reset magic window eulers if tracking is disabled.
                if (oldData && !data.magicWindowTrackingEnabled && oldData.magicWindowTrackingEnabled) {
                    this.magicWindowAbsoluteQuaternion.set(0, 0, 0, 1);
                    this.magicWindowDeltaQuaternion.set(0, 0, 0, 1);
                }

                // Pass on magic window tracking setting to magicWindowControls.
                if (this.magicWindowControls) {
                    this.magicWindowControls.enabled = data.magicWindowTrackingEnabled;
                }

                if (oldData && !data.pointerLockEnabled !== oldData.pointerLockEnabled) {
                    this.removeEventListeners();
                    this.addEventListeners();
                    if (this.pointerLocked) { this.exitPointerLock(); }
                }
            },

            tick: function (t, dt) {
                var data = this.data;
                if (!data.enabled) { return; }
                this.updateOrientation();
            },

            play: function () {
                this.addEventListeners();
            },

            pause: function () {
                this.removeEventListeners();
                if (this.pointerLocked) { this.exitPointerLock(); }
            },

            remove: function () {
                this.removeEventListeners();
                if (this.pointerLocked) { this.exitPointerLock(); }
            },

            bindMethods: function () {
                this.onMouseDown = bind(this.onMouseDown, this);
                this.onMouseMove = bind(this.onMouseMove, this);
                this.onMouseUp = bind(this.onMouseUp, this);
                this.onTouchStart = bind(this.onTouchStart, this);
                this.onTouchMove = bind(this.onTouchMove, this);
                this.onTouchEnd = bind(this.onTouchEnd, this);
                this.onEnterVR = bind(this.onEnterVR, this);
                this.onExitVR = bind(this.onExitVR, this);
                this.onPointerLockChange = bind(this.onPointerLockChange, this);
                this.onPointerLockError = bind(this.onPointerLockError, this);
            },

            /**
             * Set up states and Object3Ds needed to store rotation data.
             */
            setupMouseControls: function () {
                this.mouseDown = false;
                this.pitchObject = new THREE.Object3D();
                this.yawObject = new THREE.Object3D();
                this.yawObject.position.y = 10;
                this.yawObject.add(this.pitchObject);
            },

            /**
             * Add mouse and touch event listeners to canvas.
             */
            addEventListeners: function () {
                var sceneEl = this.el.sceneEl;
                var canvasEl = sceneEl.canvas;

                // Wait for canvas to load.
                if (!canvasEl) {
                    sceneEl.addEventListener('render-target-loaded', bind(this.addEventListeners, this));
                    return;
                }

                // Mouse events.
                canvasEl.addEventListener('mousedown', this.onMouseDown, false);
                window.addEventListener('mousemove', this.onMouseMove, false);
                window.addEventListener('mouseup', this.onMouseUp, false);

                // Touch events.
                canvasEl.addEventListener('touchstart', this.onTouchStart);
                window.addEventListener('touchmove', this.onTouchMove);
                window.addEventListener('touchend', this.onTouchEnd);

                // sceneEl events.
                sceneEl.addEventListener('enter-vr', this.onEnterVR);
                sceneEl.addEventListener('exit-vr', this.onExitVR);

                // Pointer Lock events.
                if (this.data.pointerLockEnabled) {
                    document.addEventListener('pointerlockchange', this.onPointerLockChange, false);
                    document.addEventListener('mozpointerlockchange', this.onPointerLockChange, false);
                    document.addEventListener('pointerlockerror', this.onPointerLockError, false);
                }
            },

            /**
             * Remove mouse and touch event listeners from canvas.
             */
            removeEventListeners: function () {
                var sceneEl = this.el.sceneEl;
                var canvasEl = sceneEl && sceneEl.canvas;

                if (!canvasEl) { return; }

                // Mouse events.
                canvasEl.removeEventListener('mousedown', this.onMouseDown);
                window.removeEventListener('mousemove', this.onMouseMove);
                window.removeEventListener('mouseup', this.onMouseUp);

                // Touch events.
                canvasEl.removeEventListener('touchstart', this.onTouchStart);
                window.removeEventListener('touchmove', this.onTouchMove);
                window.removeEventListener('touchend', this.onTouchEnd);

                // sceneEl events.
                sceneEl.removeEventListener('enter-vr', this.onEnterVR);
                sceneEl.removeEventListener('exit-vr', this.onExitVR);

                // Pointer Lock events.
                document.removeEventListener('pointerlockchange', this.onPointerLockChange, false);
                document.removeEventListener('mozpointerlockchange', this.onPointerLockChange, false);
                document.removeEventListener('pointerlockerror', this.onPointerLockError, false);
            },

            /**
             * Update orientation for mobile, mouse drag, and headset.
             * Mouse-drag only enabled if HMD is not active.
             */
            updateOrientation: function () {
                var object3D = this.el.object3D;
                var pitchObject = this.pitchObject;
                var yawObject = this.yawObject;
                var sceneEl = this.el.sceneEl;

                // In VR or AR mode, THREE is in charge of updating the camera pose.
                if ((sceneEl.is('vr-mode') || sceneEl.is('ar-mode')) && sceneEl.checkHeadsetConnected()) {
                    // With WebXR THREE applies headset pose to the object3D internally.
                    return;
                }

                this.updateMagicWindowOrientation();

                // On mobile, do camera rotation with touch events and sensors.
                object3D.quaternion.copy(this.magicWindowAbsoluteQuaternion);
            },

            updateMagicWindowOrientation: function () {
                var magicWindowAbsoluteQuaternion = this.magicWindowAbsoluteQuaternion;
                var magicWindowDeltaQuaternion = this.magicWindowDeltaQuaternion;
                // Calculate magic window HMD quaternion.
                if (this.magicWindowControls && this.magicWindowControls.enabled) {
                    this.magicWindowControls.update();
                    const magicQuaternion = this.magicWindowObject.quaternion.clone().multiply(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 0, 1)));
                    magicQuaternion.x *= -1;
                    magicQuaternion.z *= -1;
                    magicWindowAbsoluteQuaternion.copy(magicQuaternion);
                }
            },

            /**
             * Translate mouse drag into rotation.
             *
             * Dragging up and down rotates the camera around the X-axis (yaw).
             * Dragging left and right rotates the camera around the Y-axis (pitch).
             */
            onMouseMove: function (evt) {
                var direction;
                var movementX;
                var movementY;
                var pitchObject = this.pitchObject;
                var previousMouseEvent = this.previousMouseEvent;
                var yawObject = this.yawObject;

                // Not dragging or not enabled.
                if (!this.data.enabled || (!this.mouseDown && !this.pointerLocked)) { return; }

                // Calculate delta.
                if (this.pointerLocked) {
                    movementX = evt.movementX || evt.mozMovementX || 0;
                    movementY = evt.movementY || evt.mozMovementY || 0;
                } else {
                    movementX = evt.screenX - previousMouseEvent.screenX;
                    movementY = evt.screenY - previousMouseEvent.screenY;
                }
                this.previousMouseEvent.screenX = evt.screenX;
                this.previousMouseEvent.screenY = evt.screenY;

                // Calculate rotation.
                direction = this.data.reverseMouseDrag ? 1 : -1;
                yawObject.rotation.y += movementX * 0.002 * direction;
                pitchObject.rotation.x += movementY * 0.002 * direction;
                pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));
            },

            /**
             * Register mouse down to detect mouse drag.
             */
            onMouseDown: function (evt) {
                var sceneEl = this.el.sceneEl;
                if (!this.data.enabled || !this.data.mouseEnabled || ((sceneEl.is('vr-mode') || sceneEl.is('ar-mode')) && sceneEl.checkHeadsetConnected())) { return; }
                // Handle only primary button.
                if (evt.button !== 0) { return; }

                var canvasEl = sceneEl && sceneEl.canvas;

                this.mouseDown = true;
                this.previousMouseEvent.screenX = evt.screenX;
                this.previousMouseEvent.screenY = evt.screenY;
                this.showGrabbingCursor();

                if (this.data.pointerLockEnabled && !this.pointerLocked) {
                    if (canvasEl.requestPointerLock) {
                        canvasEl.requestPointerLock();
                    } else if (canvasEl.mozRequestPointerLock) {
                        canvasEl.mozRequestPointerLock();
                    }
                }
            },

            /**
             * Shows grabbing cursor on scene
             */
            showGrabbingCursor: function () {
                this.el.sceneEl.canvas.style.cursor = 'grabbing';
            },

            /**
             * Hides grabbing cursor on scene
             */
            hideGrabbingCursor: function () {
                this.el.sceneEl.canvas.style.cursor = '';
            },

            /**
             * Register mouse up to detect release of mouse drag.
             */
            onMouseUp: function () {
                this.mouseDown = false;
                this.hideGrabbingCursor();
            },

            /**
             * Register touch down to detect touch drag.
             */
            onTouchStart: function (evt) {
                if (evt.touches.length !== 1 ||
                    !this.data.touchEnabled ||
                    this.el.sceneEl.is('vr-mode') ||
                    this.el.sceneEl.is('ar-mode')) { return; }
                this.touchStart = {
                    x: evt.touches[0].pageX,
                    y: evt.touches[0].pageY
                };
                this.touchStarted = true;
            },

            /**
             * Translate touch move to Y-axis rotation.
             */
            onTouchMove: function (evt) {
                var direction;
                var canvas = this.el.sceneEl.canvas;
                var deltaY;
                var yawObject = this.yawObject;

                if (!this.touchStarted || !this.data.touchEnabled) { return; }

                deltaY = 2 * Math.PI * (evt.touches[0].pageX - this.touchStart.x) / canvas.clientWidth;

                direction = this.data.reverseTouchDrag ? 1 : -1;
                // Limit touch orientaion to to yaw (y axis).
                yawObject.rotation.y -= deltaY * 0.5 * direction;
                this.touchStart = {
                    x: evt.touches[0].pageX,
                    y: evt.touches[0].pageY
                };
            },

            /**
             * Register touch end to detect release of touch drag.
             */
            onTouchEnd: function () {
                this.touchStarted = false;
            },

            /**
             * Save pose.
             */
            onEnterVR: function () {
                var sceneEl = this.el.sceneEl;
                if (!sceneEl.checkHeadsetConnected()) { return; }
                this.saveCameraPose();
                this.el.object3D.position.set(0, 0, 0);
                this.el.object3D.rotation.set(0, 0, 0);
                if (sceneEl.hasWebXR) {
                    this.el.object3D.matrixAutoUpdate = false;
                    this.el.object3D.updateMatrix();
                }
            },

            /**
             * Restore the pose.
             */
            onExitVR: function () {
                if (!this.el.sceneEl.checkHeadsetConnected()) { return; }
                this.restoreCameraPose();
                this.previousHMDPosition.set(0, 0, 0);
                this.el.object3D.matrixAutoUpdate = true;
            },

            /**
             * Update Pointer Lock state.
             */
            onPointerLockChange: function () {
                this.pointerLocked = !!(document.pointerLockElement || document.mozPointerLockElement);
            },

            /**
             * Recover from Pointer Lock error.
             */
            onPointerLockError: function () {
                this.pointerLocked = false;
            },

            // Exits pointer-locked mode.
            exitPointerLock: function () {
                document.exitPointerLock();
                this.pointerLocked = false;
            },

            /**
             * Toggle the feature of showing/hiding the grab cursor.
             */
            updateGrabCursor: function (enabled) {
                var sceneEl = this.el.sceneEl;

                function enableGrabCursor () { sceneEl.canvas.classList.add('a-grab-cursor'); }
                function disableGrabCursor () { sceneEl.canvas.classList.remove('a-grab-cursor'); }

                if (!sceneEl.canvas) {
                    if (enabled) {
                        sceneEl.addEventListener('render-target-loaded', enableGrabCursor);
                    } else {
                        sceneEl.addEventListener('render-target-loaded', disableGrabCursor);
                    }
                    return;
                }

                if (enabled) {
                    enableGrabCursor();
                    return;
                }
                disableGrabCursor();
            },

            /**
             * Save camera pose before entering VR to restore later if exiting.
             */
            saveCameraPose: function () {
                var el = this.el;

                this.savedPose.position.copy(el.object3D.position);
                this.savedPose.rotation.copy(el.object3D.rotation);
                this.hasSavedPose = true;
            },

            /**
             * Reset camera pose to before entering VR.
             */
            restoreCameraPose: function () {
                var el = this.el;
                var savedPose = this.savedPose;

                if (!this.hasSavedPose) { return; }

                // Reset camera orientation.
                el.object3D.position.copy(savedPose.position);
                el.object3D.rotation.copy(savedPose.rotation);
                this.hasSavedPose = false;
            }
        });

        const unitMap = new Map([
            ["ship-1", "raider-1"],
            ["ship-2", "raider-2"],
            ["ship-3", "raider-3"],
            ["raider-1", "raider-1"],
            ["raider-2", "raider-2"],
            ["raider-3", "raider-3"],
        ]);
        const inverseUnitMap = new Map([
            ["ship-1", "ship-1"],
            ["ship-2", "ship-2"],
            ["ship-3", "ship-3"],
            ["raider-1", "ship-1"],
            ["raider-2", "ship-2"],
            ["raider-3", "ship-3"],
        ]);

        const KEYCODE_TO_CODE = {
            '38': 'ArrowUp',
            '37': 'ArrowLeft',
            '40': 'ArrowDown',
            '39': 'ArrowRight',
            '87': 'KeyW',
            '65': 'KeyA',
            '83': 'KeyS',
            '68': 'KeyD',
            '81': 'KeyQ',
            '69': 'KeyE',
            '70': 'KeyF',
        };
        const bind = AFRAME.utils.bind;
        const shouldCaptureKeyEvent = AFRAME.utils.shouldCaptureKeyEvent;
        const KEYS = [
            'KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyQ', 'KeyE', 'KeyF',
            'ArrowUp', 'ArrowLeft', 'ArrowRight', 'ArrowDown',
        ];

        AFRAME.registerComponent('globe-keyboard-controls', {
            schema: {
                acceleration: {default: 100},
                enabled: {default: true},
                fly: {default: false},
                npc: {default: false},
            },

            init: function () {
                // To keep track of the pressed keys.
                this.keys = {};
                this.mainKeys = {};
                this.velocity = new THREE.Vector3();
                this.rotation = new THREE.Vector3();

                // Bind methods and add event listeners.
                this.onBlur = bind(this.onBlur, this);
                this.onContextMenu = bind(this.onContextMenu, this);
                this.onFocus = bind(this.onFocus, this);
                this.onKeyDown = bind(this.onKeyDown, this);
                this.onKeyUp = bind(this.onKeyUp, this);
                this.onVisibilityChange = bind(this.onVisibilityChange, this);
                this.attachVisibilityEventListeners();
                this.throttle = throttle(250, function () {
                    const destination1 = this.el.object3D.position.clone();
                    setTimeout(() => {
                        const scene = document.querySelector("a-scene");
                        const shipEls = Array.from(document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`));
                        shipEls.slice(1).forEach(shipEl => {
                            const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), destination1.clone().negate());
                            const m = findParentScene(shipEl)?.systems['globe-ocean-nav'].getNavMesh();
                            if (!m) {
                                return;
                            }
                            const intersections = raycaster.intersectObject(m);
                            if (intersections[0]) {
                                const destination2 = intersections[0].point.clone();
                                shipEl.setAttribute("globe-ocean-nav-agent", `active: false; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2;`);
                            }
                        });
                    }, 125);
                    setTimeout(() => {
                        const scene = document.querySelector("a-scene");
                        const shipEls = Array.from(document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`));
                        shipEls.slice(1).forEach(shipEl => {
                            const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), destination1.clone().negate());
                            const m = findParentScene(shipEl)?.systems['globe-ocean-nav'].getNavMesh();
                            if (!m) {
                                return;
                            }
                            const intersections = raycaster.intersectObject(m);
                            if (intersections[0]) {
                                const destination2 = intersections[0].point.clone();
                                shipEl.setAttribute("globe-ocean-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2;`);
                            }
                        });
                    }, 250);
                });
            },

            tick: function (t, dt) {
                const body = this.el.body;

                // Update velocity.
                dt = dt / 1000;
                this.updateVelocity(dt);

                // Get movement vector and translate position.
                body.applyForce(this.getMovementVector(dt).clone(), new CANNON.Vec3(0, 0, 0));

                if (this.rotation.clone().y) {
                    // apply rotation force
                    body.applyLocalForce(new CANNON.Vec3(this.rotation.clone().y * 60 * dt, 0, 0), new CANNON.Vec3(0, 0, 1));
                    body.applyLocalForce(new CANNON.Vec3(-this.rotation.clone().y * 60 * dt, 0, 0), new CANNON.Vec3(0, 0, -1));
                }

                if (Object.keys(this.mainKeys).length) {
                    this.throttle();
                }
            },

            remove: function () {
                this.removeKeyEventListeners();
                this.removeVisibilityEventListeners();
            },

            play: function () {
                this.attachKeyEventListeners();
            },

            pause: function () {
                this.keys = {};
                this.removeKeyEventListeners();
            },

            updateVelocity: function (delta) {
                var acceleration;
                var data = this.data;
                var keys = this.keys;
                var velocity = this.velocity;
                var rotation = this.rotation;

                if (!data.enabled) { return; }

                // Update velocity using keys pressed.
                acceleration = data.acceleration;
                velocity.set(0, 0, 0);
                rotation.set(0, 0, 0);
                if (keys.KeyA || keys.ArrowLeft) { rotation.y = acceleration; }
                if (keys.KeyD || keys.ArrowRight) { rotation.y = -acceleration; }
                if (keys.KeyW || keys.ArrowUp) { velocity.z = -acceleration; }
                if (keys.KeyS || keys.ArrowDown) { velocity.z = acceleration; }

                const bodyWorldVelocity = this.el.body.velocity.clone();
                const bodyWorldQuat = this.el.body.quaternion.clone().inverse();
                const bodyVelocity = new THREE.Vector3(bodyWorldVelocity.x, bodyWorldVelocity.y, bodyWorldVelocity.z).applyQuaternion(new THREE.Quaternion(bodyWorldQuat.x, bodyWorldQuat.y, bodyWorldQuat.z, bodyWorldQuat.w));
                velocity.sub(new THREE.Vector3(bodyVelocity.x, bodyVelocity.y, bodyVelocity.z).multiplyScalar(1));
            },

            getMovementVector: (function () {
                var directionVector = new THREE.Vector3(0, 0, 0);

                return function (dt) {
                    var velocity = this.velocity;
                    var rotation = this.el.object3D.getWorldQuaternion(new THREE.Quaternion());

                    directionVector.copy(velocity);

                    // Transform direction relative to heading.
                    directionVector.applyQuaternion(rotation);
                    return directionVector;
                };
            })(),

            attachVisibilityEventListeners: function () {
                window.oncontextmenu = this.onContextMenu;
                window.addEventListener('blur', this.onBlur);
                window.addEventListener('focus', this.onFocus);
                document.addEventListener('visibilitychange', this.onVisibilityChange);
            },

            removeVisibilityEventListeners: function () {
                window.removeEventListener('blur', this.onBlur);
                window.removeEventListener('focus', this.onFocus);
                document.removeEventListener('visibilitychange', this.onVisibilityChange);
            },

            attachKeyEventListeners: function () {
                window.addEventListener('keydown', this.onKeyDown);
                window.addEventListener('keyup', this.onKeyUp);
            },

            removeKeyEventListeners: function () {
                window.removeEventListener('keydown', this.onKeyDown);
                window.removeEventListener('keyup', this.onKeyUp);
            },

            onContextMenu: function () {
                var keys = Object.keys(this.keys);
                for (var i = 0; i < keys.length; i++) {
                    delete this.keys[keys[i]];
                }
            },

            onBlur: function () {
                this.pause();
            },

            onFocus: function () {
                this.play();
            },

            onVisibilityChange: function () {
                if (document.hidden) {
                    this.onBlur();
                } else {
                    this.onFocus();
                }
            },

            onKeyDown: function (event) {
                var el = this.el;

                var code;
                if (!shouldCaptureKeyEvent(event)) { return; }
                code = event.code || KEYCODE_TO_CODE[event.keyCode];

                if (code === "KeyE") {
                    if (event.synthetic) {
                        this.el.emit("fire-cannons", "left-cannon");
                    } else if (!this.data.npc && this.data.enabled) {
                        const leftCannonFire = document.querySelector("#left-cannon-fire");
                        leftCannonFire.click();
                    }
                }
                if (code === "KeyQ") {
                    if (event.synthetic) {
                        this.el.emit("fire-cannons", "right-cannon");
                    } else if (!this.data.npc && this.data.enabled) {
                        const rightCannonFire = document.querySelector("#right-cannon-fire");
                        rightCannonFire.click();
                    }
                }
                if (code === "KeyF") {
                    if (event.synthetic) {
                        this.el.emit("fire-cannons", "none-cannon");
                    } else if (!this.data.npc && this.data.enabled) {
                        const noneCannonFire = document.querySelector("#none-cannon-fire");
                        noneCannonFire.click();
                    }
                }

                const scene = document.querySelector("a-scene");
                const ships = Array.from(scene.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`));
                if (el === ships[0]) {
                    if (!event.synthetic) {
                        if (KEYS.indexOf(code) !== -1) { this.mainKeys[code] = true; }

                        scene.emit("clear-ship-indicator");
                    }
                } else {
                    if (!event.synthetic) {
                        for (const key in this.keys) {
                            this.keys[key] = false;
                        }
                        return;
                    }
                }

                if (KEYS.indexOf(code) !== -1) { this.keys[code] = true; }
            },

            onKeyUp: function (event) {
                var el = this.el;

                var code;
                if (!shouldCaptureKeyEvent(event)) { return; }
                code = event.code || KEYCODE_TO_CODE[event.keyCode];

                const scene = document.querySelector("a-scene");
                const ships = Array.from(scene.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`));
                if (el === ships[0]) {
                    if (!event.synthetic) {
                        delete this.mainKeys[code];
                    }
                } else {
                    if (!event.synthetic) {
                        for (const key in this.keys) {
                            this.keys[key] = false;
                        }
                        return;
                    }
                }
                delete this.keys[code];
            },
            update(oldData) {
                if (this.data.enabled === true && oldData.enabled === false) {
                    this.play();
                }
                if (this.data.enabled === false && oldData.enabled === true) {
                    this.pause();
                }
            },
        });

        AFRAME.registerComponent("update-wizard-position-entity", {
            schema: {
                destination: {type: "vec3", default: new THREE.Vector3()},
            },
            tick: function (t, dt) {
                const center = this.el.parentElement;
                const centerHeight = center.object3D.getWorldPosition(new THREE.Vector3()).length();

                const scene = document.querySelector("a-scene");
                scene.object3D.attach(this.el.object3D);
                const thisPos = center.object3D.getWorldPosition(new THREE.Vector3()).normalize().multiplyScalar(centerHeight);
                const destinationPos = new THREE.Vector3().copy(this.data.destination).normalize().multiplyScalar(centerHeight);
                const forward = destinationPos.clone().sub(thisPos.clone()).normalize().multiplyScalar(5);
                this.el.object3D.position.copy(center.object3D.getWorldPosition(new THREE.Vector3()).sub(forward.clone()));
                this.el.object3D.up = this.el.object3D.getWorldPosition(new THREE.Vector3()).normalize();
                this.el.object3D.lookAt(destinationPos);
                center.object3D.attach(this.el.object3D);
                if (forward.length() === 0) {
                    this.el.object3D.position.set(0, 0, -5);
                }
            },
        });

        AFRAME.registerComponent("globe-moba-controls", {
            schema: {},
            init: function () {
                // To keep track of the pressed keys.
                this.keys = {};
                this.mainKeys = {};

                // Bind methods and add event listeners.
                this.onBlur = bind(this.onBlur, this);
                this.onContextMenu = bind(this.onContextMenu, this);
                this.onFocus = bind(this.onFocus, this);
                this.onKeyDown = bind(this.onKeyDown, this);
                this.onKeyUp = bind(this.onKeyUp, this);
                this.onVisibilityChange = bind(this.onVisibilityChange, this);
                this.attachVisibilityEventListeners();

                this.handleClick = this.handleClick.bind(this);
            },
            remove: function () {
                this.removeKeyEventListeners();
                this.removeVisibilityEventListeners();
                this.el.removeEventListener("moba-move", this.handleClick);
            },

            play: function () {
                this.attachKeyEventListeners();
                this.el.addEventListener("moba-move", this.handleClick);
            },

            pause: function () {
                this.keys = {};
                this.removeKeyEventListeners();
                this.el.removeEventListener("moba-move", this.handleClick);
            },

            attachVisibilityEventListeners: function () {
                window.oncontextmenu = this.onContextMenu;
                window.addEventListener('blur', this.onBlur);
                window.addEventListener('focus', this.onFocus);
                document.addEventListener('visibilitychange', this.onVisibilityChange);
            },

            removeVisibilityEventListeners: function () {
                window.removeEventListener('blur', this.onBlur);
                window.removeEventListener('focus', this.onFocus);
                document.removeEventListener('visibilitychange', this.onVisibilityChange);
            },

            attachKeyEventListeners: function () {
                window.addEventListener('keydown', this.onKeyDown);
                window.addEventListener('keyup', this.onKeyUp);
            },

            removeKeyEventListeners: function () {
                window.removeEventListener('keydown', this.onKeyDown);
                window.removeEventListener('keyup', this.onKeyUp);
            },

            onContextMenu: function () {
                var keys = Object.keys(this.keys);
                for (var i = 0; i < keys.length; i++) {
                    delete this.keys[keys[i]];
                }
            },

            onBlur: function () {
                this.pause();
            },

            onFocus: function () {
                this.play();
            },

            onVisibilityChange: function () {
                if (document.hidden) {
                    this.onBlur();
                } else {
                    this.onFocus();
                }
            },

            onKeyDown: function (event) {
                var el = this.el;

                var code;
                if (!shouldCaptureKeyEvent(event)) { return; }
                code = event.code || KEYCODE_TO_CODE[event.keyCode];

                if (code === "KeyE") {
                    // forward attack

                    // if (event.synthetic) {
                    //     this.el.emit("fire-cannons", "left-cannon");
                    // } else {
                    //     const leftCannonFire = document.querySelector("#left-cannon-fire");
                    //     leftCannonFire.click();
                    // }

                    const forwardAttackFire = document.querySelector("#forward-attack-fire");
                    forwardAttackFire.click();
                }
                if (code === "KeyQ") {
                    // area attack

                    // if (event.synthetic) {
                    //     this.el.emit("fire-cannons", "right-cannon");
                    // } else {
                    //     const rightCannonFire = document.querySelector("#right-cannon-fire");
                    //     rightCannonFire.click();
                    // }

                    const areaAttackFire = document.querySelector("#area-attack-fire");
                    areaAttackFire.click();
                }

                if (KEYS.indexOf(code) !== -1) { this.keys[code] = true; }
            },

            onKeyUp: function (event) {
                var code;
                if (!shouldCaptureKeyEvent(event)) { return; }
                code = event.code || KEYCODE_TO_CODE[event.keyCode]
                delete this.keys[code];
            },

            handleClick: function (e) {
                const destination1 = new THREE.Vector3().copy(e.detail);

                // set moba target
                const scene = document.querySelector("a-scene");
                const wizard = scene.querySelector(`.${scene.components['coin-purse'].activeUnit}-wizard`);
                wizard.querySelector("[update-wizard-position-entity]").setAttribute("update-wizard-position-entity", {
                    destination: destination1,
                });

                // navigate to moba target
                wizard.setAttribute("globe-nav-agent", `active: true; destination: ${destination1.x} ${destination1.y} ${destination1.z}; speed: 2;`);

                // set camera to start behind wizard facing moba target


                // detect attacks
                // apply projection onto land
                // apply attacks 1 second later

                // q area attack

                // e forward attack
            },
        });

        const pathfinder = new threePathfinding.Pathfinding();
        const oceanPathfinder = new threePathfinding.Pathfinding();
        const ZONE = 'level';

        /**
         * nav
         *
         * Pathfinding system, using PatrolJS.
         */
        AFRAME.registerSystem('globe-nav-projected', {
            navMesh: null,
            agents: new Set(),
            init: function () {
                this.navMesh = null;
            },

            /**
             * @param {THREE.Geometry} geometry
             */
            setNavMeshGeometry: function (geometry) {
                this.navMesh = new THREE.Mesh(geometry);
            },

            /**
             * @return {THREE.Mesh}
             */
            getNavMesh: function () {
                return this.navMesh;
            },
        });

        AFRAME.registerComponent('globe-nav-projected-mesh', {
            schema: {
                nodeName: {type: 'string'}
            },
            hasLoadedNavMesh: false,
            nodeName: "",
            init: function () {
                this.system = this.el.sceneEl.systems['globe-nav-projected'];
                this.hasLoadedNavMesh = false;
                this.nodeName = this.data.nodeName;
                this.el.addEventListener('object3dset', this.loadNavMesh.bind(this));
            },

            play: function () {
                if (!this.hasLoadedNavMesh) this.loadNavMesh();
            },

            loadNavMesh: function () {
                var self = this;
                const object = this.el.getObject3D('mesh');

                if (!object) return;

                let navMesh;
                object.traverse((node) => {
                    if (node.isMesh &&
                        (!self.nodeName || node.name === self.nodeName)) navMesh = node;
                });

                if (!navMesh) return;

                const navMeshGeometry = navMesh.geometry.clone();
                navMesh.updateWorldMatrix(true, false);
                navMeshGeometry.applyMatrix4(navMesh.matrixWorld);
                this.system.setNavMeshGeometry(navMeshGeometry);
                this.hasLoadedNavMesh = true;
                this.el.setAttribute("visible", "false");
            }
        });

        /**
         * nav
         *
         * Pathfinding system, using PatrolJS.
         */
        AFRAME.registerSystem('globe-nav', {
            navMesh: null,
            debugMesh: null,
            agents: new Set(),
            dynamicMap: null,
            schema: {
                debug: {
                    type: "boolean",
                    default: false,
                },
            },
            init: function () {
                this.navMesh = null;
                this.agents = new Set();
            },

            insertGhostBuilding: function (el) {
                if (!this.dynamicMap) {
                    return;
                }

                this.dynamicMap.insertMesh(el);
                this.setNavMeshGeometry(null);
            },

            /**
             * @param {THREE.Geometry | null} geometry
             */
            setNavMeshGeometry: function (geometry) {
                if (!this.dynamicMap && geometry) {
                    this.dynamicMap = new window.NavMeshTriangles(geometry);
                }

                if (this.data.debug) {
                    const scene = document.querySelector("a-scene").object3D;

                    // draw red mesh for obb block
                    if (this.debugObbMesh) {
                        this.debugObbMesh.parent.remove(this.debugObbMesh);
                        this.debugObbMesh?.material.dispose();
                        this.debugObbMesh?.geometry.dispose();
                        this.debugObbMesh = null;
                    }
                    const material2 = new THREE.LineBasicMaterial({ color: 0xffff0000 });
                    const g2 = this.dynamicMap.getLineSegmentGeometry(true);
                    this.debugObbMesh = new THREE.LineSegments(g2, material2);
                    this.debugObbMesh.scale.set(1.001, 1.001, 1.001);
                    scene.add(this.debugObbMesh);

                    // draw blue mesh
                    if (this.debugMesh) {
                        this.debugMesh.parent.remove(this.debugMesh);
                        this.debugMesh?.material.dispose();
                        this.debugMesh?.geometry.dispose();
                        this.debugMesh = null;
                    }
                    const material = new THREE.LineBasicMaterial({ color: 0xff0000ff });
                    const g = this.dynamicMap.getLineSegmentGeometry();
                    this.debugMesh = new THREE.LineSegments(g, material);
                    this.debugMesh.scale.set(1.001, 1.001, 1.001);
                    scene.add(this.debugMesh);

                }

                if (!geometry) {
                    geometry = this.dynamicMap.getGeometry(false);
                }

                this.navMesh = new THREE.Mesh(geometry);
                pathfinder.setZoneData(ZONE, threePathfinding.Pathfinding.createZone(geometry));
                Array.from(this.agents).forEach((agent) => agent.updateNavLocation());
            },

            /**
             * @return {THREE.Mesh}
             */
            getNavMesh: function () {
                return this.navMesh;
            },

            /**
             * @param {NavAgent} ctrl
             */
            addAgent: function (ctrl) {
                this.agents.add(ctrl);
            },

            /**
             * @param {NavAgent} ctrl
             */
            removeAgent: function (ctrl) {
                this.agents.delete(ctrl);
            },

            /**
             * @param  {THREE.Vector3} start
             * @param  {THREE.Vector3} end
             * @param  {number} groupID
             * @return {Array<THREE.Vector3>}
             */
            getPath: function (start, end, groupID) {
                return this.navMesh
                    ? groupID === null ? [] : pathfinder.findPath(start, end, ZONE, groupID)
                    : null;
            },

            /**
             * @param {THREE.Vector3} position
             * @return {number}
             */
            getGroup: function (position) {
                return this.navMesh
                    ? pathfinder.getGroup(ZONE, position)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} position
             * @param  {number} groupID
             * @return {Node}
             */
            getNode: function (position, groupID) {
                return this.navMesh
                    ? pathfinder.getClosestNode(position, ZONE, groupID, true)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} start Starting position.
             * @param  {THREE.Vector3} end Desired ending position.
             * @param  {number} groupID
             * @param  {Node} node
             * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.
             * @return {Node} Current node, after step is taken.
             */
            clampStep: function (start, end, groupID, node, endTarget) {
                if (!this.navMesh) {
                    endTarget.copy(end);
                    return null;
                } else if (!node) {
                    endTarget.copy(end);
                    return this.getNode(end, groupID);
                }
                return pathfinder.clampStep(start, end, node, ZONE, groupID, endTarget);
            }
        });

        AFRAME.registerComponent('globe-nav-mesh', {
            schema: {
                nodeName: {type: 'string'}
            },
            hasLoadedNavMesh: false,
            nodeName: "",
            init: function () {
                this.system = this.el.sceneEl.systems['globe-nav'];
                this.hasLoadedNavMesh = false;
                this.nodeName = this.data.nodeName;
                this.el.addEventListener('object3dset', this.loadNavMesh.bind(this));
            },

            play: function () {
                if (!this.hasLoadedNavMesh) this.loadNavMesh();
            },

            loadNavMesh: function () {
                var self = this;
                const object = this.el.getObject3D('mesh');

                if (!object) return;

                let navMesh;
                object.traverse((node) => {
                    if (node.isMesh &&
                        (!self.nodeName || node.name === self.nodeName)) navMesh = node;
                });

                if (!navMesh) return;

                const navMeshGeometry = navMesh.geometry.clone();
                navMesh.updateWorldMatrix(true, false);
                navMeshGeometry.applyMatrix4(navMesh.matrixWorld);
                this.system.setNavMeshGeometry(navMeshGeometry);
                this.hasLoadedNavMesh = true;
                this.el.setAttribute("visible", "false");
            }
        });

        AFRAME.registerComponent('networked-globe-nav-agent', {
            schema: {
                start: {type: 'vec3'},
                destination: {type: 'vec3'},
                startTime: {type: 'number'},
                active: {default: false},
                speed: {default: 2},
                razeTarget: {
                    type: 'selector',
                    default: null,
                },
            },
            system: null,
            group: null,
            path: [],
            pathDistance: 0,
            init: function () {
                this.system = this.el.sceneEl.systems['globe-nav'];
                this.system.addAgent(this);
                this.group = null;
                this.pathDistance = 0;
                this.path = [];
            },
            remove: function () {
                this.system.removeAgent(this);
            },
            update: function () {
                this.path.length = 0;
                this.pathDistance = 0;
                this.el.object3D.position.copy(this.data.start || new THREE.Vector3());
            },
            updateNavLocation: function () {
                this.group = null;
                this.path = [];
                this.pathDistance = 0;
            },
            tick: function (t, dt) {
                const vDest = new THREE.Vector3();
                const vDelta = new THREE.Vector3();
                const vNext = new THREE.Vector3();

                const el = this.el;
                const data = this.data;
                const time = (+new Date() - data.startTime) / 1000;
                const pathDistance = data.speed * time;

                if (!data.active) return;

                const object3D = this.el.object3D;
                const pos = object3D.getWorldPosition(new THREE.Vector3());

                const cameraEl = document.querySelector("#camera-rig");
                const cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());

                const cameraDistance = pos.distanceTo(cameraPos);
                object3D.visible = cameraDistance < 20;

                // Use PatrolJS pathfinding system to get the shortest path to target.
                if (!this.path.length) {
                    const position = new THREE.Vector3().copy(data.start);
                    object3D.position.copy(position);
                    this.group = this.group || this.system.getGroup(position);
                    this.path = this.system.getPath(position, vDest.copy(data.destination), this.group) || [];
                    el.emit('navigation-start');
                }

                // If no path is found, exit.
                if (!this.path.length) {
                    // console.warn('[nav] Unable to find path to %o.', data.destination);
                    this.el.setAttribute("networked-globe-nav-agent", {
                        active: false,
                    });
                    el.emit('navigation-end');
                    el.emit('navigation-group-change');
                    el.object3D.position.copy(vDest);
                    this.pathDistance = pathDistance;
                    this.group = null;
                    el.emit('navigation-group-changed');
                    return;
                }

                while (this.path.length && pathDistance - this.pathDistance >= 0) {
                    // Current segment is a vector from current position to next waypoint.
                    const vCurrent = el.object3D.position;
                    const vWaypoint = this.path[0];
                    vDelta.subVectors(vWaypoint, vCurrent);

                    const distance = vDelta.length();
                    let gazeTarget;
                    let shouldBreak = false;

                    const tickDistance = pathDistance - this.pathDistance;
                    if (distance <= tickDistance) {
                        // If <1 step from current waypoint, discard it and move toward next.
                        this.path.shift();
                        this.pathDistance += distance;

                        // After discarding the last waypoint, exit pathfinding.
                        if (!this.path.length) {
                            this.el.setAttribute("networked-globe-nav-agent", {
                                active: false,
                            });
                            if (this.data.razeTarget) {
                                this.data.razeTarget.emit("raze");
                            }
                            el.emit('navigation-end');
                            return;
                        }

                        vNext.copy(vWaypoint);
                        gazeTarget = this.path[0];
                    } else {
                        // If still far away from next waypoint, find next position for
                        // the current frame.
                        this.pathDistance += tickDistance;
                        vNext.copy(vDelta.setLength(tickDistance)).add(vCurrent);
                        gazeTarget = vWaypoint;
                        shouldBreak = true;
                    }

                    vCurrent.copy(vNext);

                    // Look at the next waypoint.
                    // gazeTarget.y = vCurrent.y;
                    el.object3D.up = new THREE.Vector3().copy(vCurrent).normalize();
                    el.object3D.lookAt(gazeTarget);

                    if (shouldBreak) {
                        break;
                    }
                }
            },
        });

        AFRAME.registerComponent('globe-nav-agent', {
            schema: {
                destination: {type: 'vec3'},
                active: {default: false},
                speed: {default: 2},
                razeTarget: {
                    type: 'selector',
                    default: null,
                },
            },
            system: null,
            group: null,
            path: [],
            init: function () {
                this.system = this.el.sceneEl.systems['globe-nav'];
                this.system.addAgent(this);
                this.group = null;
                this.path = [];
                this.material = new THREE.LineBasicMaterial({ color: 0xffffff });
                this.geometry = new THREE.BufferGeometry().setFromPoints([]);
                this.line = new THREE.Line(this.geometry, this.material);
                this.debugId = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
            },
            remove: function () {
                this.system.removeAgent(this);
                if (this.el.sceneEl.object3DMap[`line-debug-${this.debugId}`]) {
                    this.el.sceneEl.removeObject3D(`line-debug-${this.debugId}`);
                }
            },
            update: function () {
                this.path.length = 0;
            },
            updateNavLocation: function () {
                this.group = null;
                this.path = [];
            },
            tick: function (t, dt) {
                const vDest = new THREE.Vector3();
                const vDelta = new THREE.Vector3();
                const vNext = new THREE.Vector3();

                const el = this.el;
                const data = this.data;
                const speed = data.speed * dt / 1000;

                if (!data.active) return;

                const object3D = this.el.object3D;
                const pos = object3D.getWorldPosition(new THREE.Vector3());

                const cameraEl = document.querySelector("#camera-rig");
                const cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());

                const cameraDistance = pos.distanceTo(cameraPos);
                object3D.visible = cameraDistance < 20;

                // Use PatrolJS pathfinding system to get the shortest path to target.
                if (!this.path.length) {
                    const position = this.el.object3D.position;
                    if (position.length() === 0) {
                        position.copy(data.destination);
                    }
                    this.group = this.group || this.system.getGroup(position);
                    this.path = this.system.getPath(position, vDest.copy(data.destination), this.group) || [];
                    el.emit('navigation-start');
                }

                const scene = document.querySelector("a-scene");
                if (el.classList.contains(`${scene.components['coin-purse'].activeUnit}`)) {
                    if (this.el.sceneEl.object3DMap[`line-debug-${this.debugId}`]) {
                        this.el.sceneEl.removeObject3D(`line-debug-${this.debugId}`);
                    }
                    this.geometry.dispose();
                    this.geometry = new THREE.BufferGeometry().setFromPoints([this.el.object3D.position, this.el.object3D.position, ...this.path].map(x => new THREE.Vector3().addVectors(x, x.clone().normalize())));
                    this.geometry.computeBoundingSphere();
                    this.line = new THREE.Line(this.geometry, this.material);
                    this.el.sceneEl.setObject3D(`line-debug-${this.debugId}`, this.line);
                } else {
                    if (this.el.sceneEl.object3DMap[`line-debug-${this.debugId}`]) {
                        this.el.sceneEl.removeObject3D(`line-debug-${this.debugId}`);
                    }
                }

                // If no path is found, exit.
                if (!this.path.length) {
                    // console.warn('[nav] Unable to find path to %o.', data.destination);
                    this.el.setAttribute("globe-nav-agent", "active: false;");
                    el.emit('navigation-end');
                    el.emit('navigation-group-change');
                    el.object3D.position.copy(vDest);
                    this.group = null;
                    if (this.el.sceneEl.object3DMap[`line-debug-${this.debugId}`]) {
                        this.el.sceneEl.removeObject3D(`line-debug-${this.debugId}`);
                    }
                    el.emit('navigation-group-changed');
                    return;
                }

                // Current segment is a vector from current position to next waypoint.
                const vCurrent = el.object3D.position;
                const vWaypoint = this.path[0];
                vDelta.subVectors(vWaypoint, vCurrent);

                const distance = vDelta.length();
                let gazeTarget;

                if (distance <= speed) {
                    // If <1 step from current waypoint, discard it and move toward next.
                    this.path.shift();

                    // After discarding the last waypoint, exit pathfinding.
                    if (!this.path.length) {
                        this.el.setAttribute("globe-nav-agent", "active: false;");
                        if (this.data.razeTarget) {
                            this.data.razeTarget.emit("raze");
                        }
                        el.emit('navigation-end');
                        return;
                    }

                    vNext.copy(vDelta.clone().add(vCurrent));
                    gazeTarget = this.path[0];
                } else {
                    // If still far away from next waypoint, find next position for
                    // the current frame.
                    vNext.copy(vDelta.setLength(speed)).add(vCurrent);
                    gazeTarget = vWaypoint;
                }

                // Look at the next waypoint.
                // gazeTarget.y = vCurrent.y;
                el.object3D.up = new THREE.Vector3().copy(vCurrent).normalize();
                el.object3D.lookAt(gazeTarget);

                vCurrent.copy(vNext);
            },
        });

        /**
         * nav
         *
         * Pathfinding system, using PatrolJS.
         */
        AFRAME.registerSystem('globe-ocean-nav', {
            navMesh: null,
            agents: new Set(),
            init: function () {
                this.navMesh = null;
                this.agents = new Set();
            },

            /**
             * @param {THREE.Geometry} geometry
             */
            setNavMeshGeometry: function (geometry) {
                this.navMesh = new THREE.Mesh(geometry);
                oceanPathfinder.setZoneData(ZONE, threePathfinding.Pathfinding.createZone(geometry));
                Array.from(this.agents).forEach((agent) => agent.updateNavLocation());
            },

            /**
             * @return {THREE.Mesh}
             */
            getNavMesh: function () {
                return this.navMesh;
            },

            /**
             * @param {NavAgent} ctrl
             */
            addAgent: function (ctrl) {
                this.agents.add(ctrl);
            },

            /**
             * @param {NavAgent} ctrl
             */
            removeAgent: function (ctrl) {
                this.agents.delete(ctrl);
            },

            /**
             * @param  {THREE.Vector3} start
             * @param  {THREE.Vector3} end
             * @param  {number} groupID
             * @return {Array<THREE.Vector3>}
             */
            getPath: function (start, end, groupID) {
                return this.navMesh
                    ? groupID === null ? [] : oceanPathfinder.findPath(start, end, ZONE, groupID)
                    : null;
            },

            /**
             * @param {THREE.Vector3} position
             * @return {number}
             */
            getGroup: function (position) {
                return this.navMesh
                    ? oceanPathfinder.getGroup(ZONE, position)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} position
             * @param  {number} groupID
             * @return {Node}
             */
            getNode: function (position, groupID) {
                return this.navMesh
                    ? oceanPathfinder.getClosestNode(position, ZONE, groupID, true)
                    : null;
            },

            /**
             * @param  {THREE.Vector3} start Starting position.
             * @param  {THREE.Vector3} end Desired ending position.
             * @param  {number} groupID
             * @param  {Node} node
             * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.
             * @return {Node} Current node, after step is taken.
             */
            clampStep: function (start, end, groupID, node, endTarget) {
                if (!this.navMesh) {
                    endTarget.copy(end);
                    return null;
                } else if (!node) {
                    endTarget.copy(end);
                    return this.getNode(end, groupID);
                }
                return oceanPathfinder.clampStep(start, end, node, ZONE, groupID, endTarget);
            }
        });

        AFRAME.registerComponent('globe-ocean-nav-mesh', {
            schema: {
                nodeName: {type: 'string'}
            },
            hasLoadedNavMesh: false,
            nodeName: "",
            init: function () {
                this.system = this.el.sceneEl.systems['globe-ocean-nav'];
                this.hasLoadedNavMesh = false;
                this.nodeName = this.data.nodeName;
                this.el.addEventListener('object3dset', this.loadNavMesh.bind(this));
            },

            play: function () {
                if (!this.hasLoadedNavMesh) this.loadNavMesh();
            },

            loadNavMesh: function () {
                var self = this;
                const object = this.el.getObject3D('mesh');

                if (!object) return;

                let navMesh;
                object.traverse((node) => {
                    if (node.isMesh &&
                        (!self.nodeName || node.name === self.nodeName)) navMesh = node;
                });

                if (!navMesh) return;

                const navMeshGeometry = navMesh.geometry.clone();
                navMesh.updateWorldMatrix(true, false);
                navMeshGeometry.applyMatrix4(navMesh.matrixWorld);
                this.system.setNavMeshGeometry(navMeshGeometry);
                this.hasLoadedNavMesh = true;
                this.el.setAttribute("visible", "false");
            }
        });

        AFRAME.registerComponent('globe-ocean-nav-agent', {
            schema: {
                destination: {type: 'vec3'},
                active: {default: false},
                speed: {default: 2}
            },
            system: null,
            group: null,
            path: [],
            init: function () {
                this.system = this.el.sceneEl.systems['globe-ocean-nav'];
                this.system.addAgent(this);
                this.group = null;
                this.path = [];
            },
            remove: function () {
                this.system.removeAgent(this);
            },
            update: function () {
                this.path.length = 0;
            },
            updateNavLocation: function () {
                this.group = null;
                this.path = [];
            },
            tick: function (t, dt) {
                const vDest = new THREE.Vector3();
                const vDelta = new THREE.Vector3();
                const vNext = new THREE.Vector3();

                const el = this.el;
                const data = this.data;
                const speed = data.speed * dt / 1000;

                if (!data.active) return;
                if (!el.components['globe-keyboard-controls']) return;

                // Use PatrolJS pathfinding system to get the shortest path to target.
                if (!this.path.length) {
                    const position = this.el.object3D.position;
                    if (position.length() === 0) {
                        position.copy(data.destination);
                    }
                    this.group = this.group || this.system.getGroup(position);
                    this.path = this.system.getPath(position, vDest.copy(data.destination), this.group) || [];
                    el.emit('navigation-start');
                }

                // If no path is found, exit.
                if (!this.path.length) {
                    // console.warn('[nav] Unable to find path to %o.', data.destination);
                    this.el.setAttribute("globe-ocean-nav-agent", "active: false;");
                    el.emit('navigation-end');
                    el.object3D.position.copy(vDest);
                    // console.log(el.object3D.position);
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyW"});
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                    this.group = null;
                    return;
                }

                // Current segment is a vector from current position to next waypoint.
                const vCurrent = new THREE.Vector3().copy(el.components['dynamic-body']?.body.position ?? el.object3D.position);
                const vWaypoint = this.path[0];
                vDelta.subVectors(vWaypoint, vCurrent);

                const distance = vDelta.length();
                let gazeTarget;

                if (distance < 4) {
                    // If <1 step from current waypoint, discard it and move toward next.
                    this.path.shift();

                    // After discarding the last waypoint, exit pathfinding.
                    if (!this.path.length) {
                        this.el.setAttribute("globe-ocean-nav-agent", "active: false;");
                        el.emit('navigation-end');
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyW"});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD"});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA"});
                        return;
                    }

                    vNext.copy(vCurrent);
                    gazeTarget = this.path[0];
                } else {
                    // If still far away from next waypoint, find next position for
                    // the current frame.
                    vNext.copy(vDelta.setLength(speed)).add(vCurrent);
                    gazeTarget = vWaypoint;
                }

                // Look at the next waypoint.
                // gazeTarget.y = vCurrent.y;
                // |  x  y  z |
                // | ax ay az |
                // | bx by bz |
                const getDeterminant = () => {
                    const a = vCurrent.clone().normalize();
                    const v1 = new THREE.Vector3(0, 0, -1).applyQuaternion(new THREE.Quaternion().copy(el.components['dynamic-body'].body.quaternion));
                    const v2 = gazeTarget.clone().sub(vCurrent.clone()).normalize();

                    // make two vectors for determinant
                    let ax = v1.x;
                    let ay = v1.y;
                    let az = v1.z;
                    let bx = v2.x;
                    let by = v2.y;
                    let bz = v2.z;

                    // make basis matrix for sphere
                    let aVec = new THREE.Vector3().set(ax, ay, az).normalize();
                    let bVec = new THREE.Vector3().set(bx, by, bz).normalize();
                    const basisY = aVec.clone().normalize();
                    const basisZ = a.clone().normalize();
                    const basisX = new THREE.Vector3().crossVectors(basisY, basisZ);
                    const basis = new THREE.Matrix4().makeBasis(basisX, basisY, basisZ).invert();

                    // apply basis matrix
                    aVec = aVec.applyMatrix4(basis);
                    bVec = bVec.applyMatrix4(basis);
                    ax = aVec.x;
                    ay = aVec.y;
                    az = aVec.z;
                    bx = bVec.x;
                    by = bVec.y;
                    bz = bVec.z;

                    let det = ax * by + ay * bz + az * bx - ay * bx - az * by - ax * bz;
                    if (isNaN(det)) {
                        return 0;
                    }
                    if (aVec.dot(bVec) < 0) {
                        det += Math.sign(det);
                    }
                    return det;
                };
                const det = getDeterminant();
                if (det < 0) {
                    if (Math.random() * 0.5 < Math.abs(det)) {
                        el.components['globe-keyboard-controls'].onKeyDown({code: "KeyD", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA", synthetic: true});
                    } else {
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD", synthetic: true});
                    }
                } else if (det > 0) {
                    if (Math.random() * 0.33 < Math.abs(det)) {
                        el.components['globe-keyboard-controls'].onKeyDown({code: "KeyA", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD", synthetic: true});
                    } else {
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA", synthetic: true});
                    }
                } else {
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA", synthetic: true});
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD", synthetic: true});
                }

                if (Math.abs(det) < 0.1) {
                    el.components['globe-keyboard-controls'].onKeyDown({code: "KeyW", synthetic: true});
                } else {
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyW", synthetic: true});
                }
            },
        });

        AFRAME.registerComponent('draw-ship-indicator', {
            schema: {},
            currentIndicator: null,
            dataEntity: null,
            init: function () {
                this.currentIndicator = null;
                this.dataEntity = null;
                this.setNpcIndicator = (e) => {
                    const p = e.detail;
                    if (!this.currentIndicator) {
                        this.createIndicator(p);
                    }
                    this.updateIndicator(p);
                };
                this.clearNpcIndicator = () => {
                    this.removeIndicator();
                };
                this.el.addEventListener('set-ship-indicator', this.setNpcIndicator);
                this.el.addEventListener('clear-ship-indicator', this.clearNpcIndicator);
            },
            remove: function () {
                this.el.removeEventListener('set-ship-indicator', this.setNpcIndicator);
                this.el.removeEventListener('clear-ship-indicator', this.clearNpcIndicator);
                if (this.currentIndicator) {
                    this.removeIndicator();
                }
            },
            createIndicator: function (p) {
                const str = characterModels.get("SHIP_DESTINATION");
                if (str) {
                    const scene = document.querySelector("a-scene");
                    const entity = document.createElement("a-entity");
                    const data = document.createElement("a-entity");
                    data.setAttribute("gltf-model", str);
                    data.setAttribute("rotation", "90 0 0");
                    entity.appendChild(data);
                    entity.object3D.position.copy(p.clone().normalize().setLength(p.clone().length() + 1));
                    entity.object3D.up = p.clone().normalize();
                    this.currentIndicator = entity;
                    this.dataEntity = data;
                    scene.appendChild(entity);
                }
            },
            updateIndicator: function (p) {
                if (this.currentIndicator) {
                    const cameraEl = document.querySelector("#camera-rig");
                    let cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());

                    const entity = this.currentIndicator;
                    entity.object3D.position.copy(p.clone().normalize().setLength(p.clone().length() + 1));
                    entity.object3D.up = p.clone().normalize();
                    entity.object3D.lookAt(cameraPos);
                }
            },
            removeIndicator: function () {
                if (this.currentIndicator) {
                    const entity = this.currentIndicator;
                    entity.parentElement.removeChild(this.currentIndicator);
                    this.currentIndicator = null;
                    this.dataEntity = null;
                }
            },
            tick: function (t, dt) {
                if (this.currentIndicator) {
                    const cameraEl = document.querySelector("#camera-rig");
                    let cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());

                    const entity = this.currentIndicator;
                    entity.object3D.lookAt(cameraPos);
                }
                if (this.dataEntity) {
                    this.dataEntity.object3D.rotation.set(0, Math.PI / 2, 0, 'YXZ');
                    this.dataEntity.object3D.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), (Math.PI * t / 1000) % (Math.PI * 2)));
                }
            }
        });

        AFRAME.registerComponent('draw-npc-indicator', {
            schema: {},
            currentIndicator: null,
            dataEntity: null,
            init: function () {
                this.currentIndicator = null;
                this.dataEntity = null;
                this.setNpcIndicator = (e) => {
                    const p = e.detail;
                    if (!this.currentIndicator) {
                        this.createIndicator(p);
                    }
                    this.updateIndicator(p);
                };
                this.clearNpcIndicator = () => {
                    this.removeIndicator();
                };
                this.el.addEventListener('set-npc-indicator', this.setNpcIndicator);
                this.el.addEventListener('clear-npc-indicator', this.clearNpcIndicator);
            },
            remove: function () {
                this.el.removeEventListener('set-npc-indicator', this.setNpcIndicator);
                this.el.removeEventListener('clear-npc-indicator', this.clearNpcIndicator);
                if (this.currentIndicator) {
                    this.removeIndicator();
                }
            },
            createIndicator: function (p) {
                const str = characterModels.get("NPC_DESTINATION");
                if (str) {
                    const scene = document.querySelector("a-scene");
                    const entity = document.createElement("a-entity");
                    const data = document.createElement("a-entity");
                    data.setAttribute("gltf-model", str);
                    data.setAttribute("rotation", "90 0 0");
                    entity.appendChild(data);
                    entity.object3D.position.copy(p.clone().normalize().setLength(p.clone().length() + 1));
                    entity.object3D.up = p.clone().normalize();
                    this.currentIndicator = entity;
                    this.dataEntity = data;
                    scene.appendChild(entity);
                }
            },
            updateIndicator: function (p) {
                if (this.currentIndicator) {
                    const cameraEl = document.querySelector("#camera-rig");
                    let cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());

                    const entity = this.currentIndicator;
                    entity.object3D.position.copy(p.clone().normalize().setLength(p.clone().length() + 1));
                    entity.object3D.up = p.clone().normalize();
                    entity.object3D.lookAt(cameraPos);
                }
            },
            removeIndicator: function () {
                if (this.currentIndicator) {
                    const entity = this.currentIndicator;
                    entity.parentElement.removeChild(this.currentIndicator);
                    this.currentIndicator = null;
                    this.dataEntity = null;
                }
            },
            tick: function (t, dt) {
                if (this.currentIndicator) {
                    const cameraEl = document.querySelector("#camera-rig");
                    let cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());

                    const entity = this.currentIndicator;
                    entity.object3D.lookAt(cameraPos);
                }
                if (this.dataEntity) {
                    this.dataEntity.object3D.rotation.set(0, Math.PI / 2, 0, 'YXZ');
                    this.dataEntity.object3D.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), (Math.PI * t / 1000) % (Math.PI * 2)));
                }
            }
        });

        AFRAME.registerComponent('go-on-land', {
            schema: {
                raze: {
                    type: 'boolean',
                    default: false,
                },
            },
            init: function () {
                this.system = this.el.sceneEl.systems['globe-nav'];
                this.el.addEventListener('click', (e) => {
                    ClickManager.addToQueue(() => {
                        const scene = document.querySelector("a-scene");
                        const activeUnit = scene.components['coin-purse'].activeUnit;
                        const ship = scene.querySelector(`.${activeUnit}`);
                        if (!ship) {
                            return;
                        }

                        if (!e.detail.intersection) {
                            return;
                        }

                        const destination1 = e.detail.intersection.point.clone();

                        const ships = [
                            ...scene.querySelectorAll(`.ship-1`),
                            ...scene.querySelectorAll(`.ship-2`),
                            ...scene.querySelectorAll(`.ship-3`),
                        ];
                        ships.forEach((ship) => {
                            ship.setAttribute("globe-keyboard-controls", {enabled: false});
                        });

                        scene.components['coin-purse'].setUnit(unitMap.get(scene.components['coin-purse'].activeUnit));
                        const checkBox = document.querySelector(`#unit-selection-${scene.components['coin-purse'].activeUnit}`);
                        checkBox.click();

                        let addedNpcs = false;
                        const npcs = [...document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`), ...document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}-wizard`)];
                        if (npcs.length === 0) {
                            addWizardNpc();
                            const raiderAmount = scene.components['coin-purse'].getRaiderAmount();
                            for (let i = 0; i < raiderAmount; i++) {
                                addNpc(i);
                            }
                            addedNpcs = true;
                        }

                        if (addedNpcs) {

                            setTimeout(() => {
                                const npcEls = document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`);
                                npcEls.forEach(npcEl => {
                                    const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), destination1.clone().negate());
                                    const m = findParentScene(npcEl)?.systems['globe-nav'].getNavMesh();
                                    if (!m) {
                                        return;
                                    }
                                    const intersections = raycaster.intersectObject(m);
                                    if (intersections[0]) {
                                        const destination2 = intersections[0].point.clone();
                                        npcEl.setAttribute("globe-nav-agent", `active: false; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2; razeTarget: #${this.el.id};`);
                                    }
                                });
                            }, 500);
                            setTimeout(() => {
                                const npcEls = document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`);
                                const cameraEl = document.querySelector("#camera-rig");
                                cameraEl.setAttribute("look-at-box", `.${scene.components['coin-purse'].getUnit()}`);
                                npcEls.forEach(npcEl => {
                                    const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3).add(new THREE.Vector3().random()), destination1.clone().negate());
                                    const m = findParentScene(npcEl)?.systems['globe-nav'].getNavMesh();
                                    if (!m) {
                                        return;
                                    }
                                    const intersections = raycaster.intersectObject(m);
                                    if (intersections[0]) {
                                        const destination2 = intersections[0].point.clone();
                                        npcEl.setAttribute("globe-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2; razeTarget: #${this.el.id};`);
                                    }
                                });
                            }, 750);
                            setTimeout(() => {
                                const npcEls = document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`);
                                const cameraEl = document.querySelector("#camera-rig");
                                cameraEl.setAttribute("look-at-box", `.${scene.components['coin-purse'].getUnit()}`);
                                npcEls.forEach(npcEl => {
                                    const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3).add(new THREE.Vector3().random().multiplyScalar(2).subScalar(1)), destination1.clone().negate());
                                    const m = findParentScene(npcEl)?.systems['globe-nav'].getNavMesh();
                                    if (!m) {
                                        return;
                                    }
                                    const intersections = raycaster.intersectObject(m);
                                    if (intersections[0]) {
                                        const destination2 = intersections[0].point.clone();
                                        npcEl.setAttribute("globe-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2; razeTarget: #${this.el.id};`);
                                    }
                                });
                                const wizardEls = document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}-wizard`);
                                wizardEls.forEach(wizardEl => {
                                    const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), destination1.clone().negate());
                                    const m = findParentScene(wizardEl)?.systems['globe-nav'].getNavMesh();
                                    if (!m) {
                                        return;
                                    }
                                    const intersections = raycaster.intersectObject(m);
                                    if (intersections[0]) {
                                        const destination2 = intersections[0].point.clone();
                                        wizardEl.emit("moba-move", destination2.clone())
                                    }
                                })
                                scene.emit("set-npc-indicator", destination1.clone());
                                scene.emit("clear-ship-indicator");
                            }, 1000);
                        } else {
                            const npcEls = document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`);
                            const cameraEl = document.querySelector("#camera-rig");
                            cameraEl.setAttribute("look-at-box", `.${scene.components['coin-purse'].getUnit()}`);
                            npcEls.forEach(npcEl => {
                                const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3).add(new THREE.Vector3().random().multiplyScalar(2).subScalar(1)), destination1.clone().negate());
                                const m = findParentScene(npcEl)?.systems['globe-nav'].getNavMesh();
                                if (!m) {
                                    return;
                                }
                                const intersections = raycaster.intersectObject(m);
                                if (intersections[0]) {
                                    const destination2 = intersections[0].point.clone();
                                    npcEl.setAttribute("globe-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2; razeTarget: #${this.el.id};`);
                                }
                            });
                            const wizardEls = document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}-wizard`);
                            wizardEls.forEach(wizardEl => {
                                const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), destination1.clone().negate());
                                const m = findParentScene(wizardEl)?.systems['globe-nav'].getNavMesh();
                                if (!m) {
                                    return;
                                }
                                const intersections = raycaster.intersectObject(m);
                                if (intersections[0]) {
                                    const destination2 = intersections[0].point.clone();
                                    wizardEl.emit("moba-move", destination2.clone())
                                }
                            })
                            scene.emit("set-npc-indicator", destination1.clone());
                            scene.emit("clear-ship-indicator");

                            const buildMenuState = document.querySelector("#build-menu-state");
                            if (buildMenuState.hasAttribute("wizard-tower-build")) {
                                addGhostBuilding(destination1.clone());
                            }
                        }
                    }, "go-on-land");
                });
            }
        });

        AFRAME.registerComponent('go-to-sea', {
            init: function () {
                this.el.addEventListener('click', function (e) {
                    ClickManager.addToQueue(() => {
                        if (!e.detail.intersection) {
                            return;
                        }

                        const destination1 = e.detail.intersection.point.clone();

                        const scene = document.querySelector("a-scene");
                        scene.components['coin-purse'].setUnit(inverseUnitMap.get(scene.components['coin-purse'].activeUnit));
                        const checkBox = document.querySelector(`#unit-selection-${scene.components['coin-purse'].activeUnit}`);
                        checkBox.click();

                        const ships = [
                            ...scene.querySelectorAll(`.ship-1`),
                            ...scene.querySelectorAll(`.ship-2`),
                            ...scene.querySelectorAll(`.ship-3`),
                        ];
                        ships.forEach((ship) => {
                            ship.setAttribute("globe-keyboard-controls", {enabled: true});
                        });

                        let removedNpcs = false;
                        const npcs = document.querySelectorAll(`.${unitMap.get(scene.components['coin-purse'].activeUnit)}`);
                        if (npcs.length !== 0) {
                            removeNpc();
                            removedNpcs = true;
                        }

                        if (removedNpcs) {
                            setTimeout(() => {
                                const cameraEl = document.querySelector("#camera-rig");
                                cameraEl.setAttribute("look-at-box", `.${scene.components['coin-purse'].getUnit()}`);
                            }, 0);
                            setTimeout(() => {
                                scene.emit("clear-npc-indicator");
                            }, 1000);
                            setTimeout(() => {
                                const shipEls = document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`);
                                shipEls.forEach(shipEl => {
                                    const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), destination1.clone().negate());
                                    const m = findParentScene(shipEl)?.systems['globe-ocean-nav'].getNavMesh();
                                    if (!m) {
                                        return;
                                    }
                                    const intersections = raycaster.intersectObject(m);
                                    if (intersections[0]) {
                                        const destination2 = intersections[0].point.clone();
                                        shipEl.setAttribute("globe-ocean-nav-agent", `active: false; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2;`);
                                    }
                                });
                            }, 500);
                            setTimeout(() => {
                                const shipEls = document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`);
                                shipEls.forEach(shipEl => {
                                    const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), destination1.clone().negate());
                                    const m = findParentScene(shipEl)?.systems['globe-ocean-nav'].getNavMesh();
                                    if (!m) {
                                        return;
                                    }
                                    const intersections = raycaster.intersectObject(m);
                                    if (intersections[0]) {
                                        const destination2 = intersections[0].point.clone();
                                        shipEl.setAttribute("globe-ocean-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2;`);
                                    }
                                });
                                scene.emit("set-ship-indicator", destination1.clone());
                            }, 1000);
                        } else {
                            const shipEls = document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`);
                            shipEls.forEach(shipEl => {
                                const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), destination1.clone().negate());
                                const m = findParentScene(shipEl)?.systems['globe-ocean-nav'].getNavMesh();
                                if (!m) {
                                    return;
                                }
                                const intersections = raycaster.intersectObject(m);
                                if (intersections[0]) {
                                    const destination2 = intersections[0].point.clone();
                                    shipEl.setAttribute("globe-ocean-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2;`);
                                }
                            });
                            scene.emit("set-ship-indicator", destination1.clone());
                        }
                    }, "go-to-sea");
                });
            }
        });

        function getRandomPointsOnMesh(mesh, origin, count) {
            const geometry = mesh.geometry;
            const positionAttribute = geometry.attributes.position;
            const vertices = positionAttribute.array;
            const indices = geometry.index ? geometry.index.array : null;

            const randomPoints = [];
            const faceCount = indices ? indices.length / 3 : vertices.length / 9;
            const rng = new Math.seedrandom(`${origin.x} ${origin.y} ${origin.z} ${faceCount} ${count}`);

            for (let i = 0; i < count; i++) {
                const faceIndex = Math.floor(rng() * faceCount);

                let vA, vB, vC;
                if (indices) {
                    const offset = positionAttribute.offset;
                    const itemSize = positionAttribute.data.stride;
                    const i1 = indices[faceIndex * 3];
                    const i2 = indices[faceIndex * 3 + 1];
                    const i3 = indices[faceIndex * 3 + 2];
                    vA = new THREE.Vector3().fromArray(vertices, i1 * itemSize + offset);
                    vB = new THREE.Vector3().fromArray(vertices, i2 * itemSize + offset);
                    vC = new THREE.Vector3().fromArray(vertices, i3 * itemSize + offset);
                } else {
                    vA = new THREE.Vector3().fromArray(vertices, faceIndex * 9);
                    vB = new THREE.Vector3().fromArray(vertices, faceIndex * 9 + 3);
                    vC = new THREE.Vector3().fromArray(vertices, faceIndex * 9 + 6);
                }

                // Generate a random point inside the triangle
                const randomPoint = new THREE.Vector3();
                let r1 = rng();
                let r2 = rng();
                if (r1 + r2 > 1) {
                    r1 = 1 - r1;
                    r2 = 1 - r2;
                }
                randomPoint.add(vA);
                randomPoint.add(vB.clone().sub(vA).multiplyScalar(r1));
                randomPoint.add(vC.clone().sub(vA).multiplyScalar(r2));

                const randomNormal = new THREE.Vector3();
                randomNormal.crossVectors(vB.clone().sub(vA), vC.clone().sub(vA)).normalize();

                randomPoints.push({point: randomPoint, normal: randomNormal});
            }

            return randomPoints;
        }

        AFRAME.registerComponent('grass-particles', {
            schema: {
                origin: { type: 'vec3', default: {x: 0, y: 0, z: 0} },
            },
            init: function () {
                this.innerAddGrass = this.addGrass.bind(this);
                this.innerRemoveGrass = this.removeGrass.bind(this);
                this.el.addEventListener('add-grass', this.innerAddGrass);
                this.el.addEventListener('remove-grass', this.innerRemoveGrass);
            },
            addGrass: function () {
                const meshes = [];
                this.el.object3D.traverse((node) => {
                    if (node.isMesh) {
                        meshes.push(node);
                    }
                });
                const mesh = meshes[0];
                if (mesh) {
                    const randomPoints = getRandomPointsOnMesh(mesh, this.data.origin, 256);

                    const updateTerrainWithGrass = () => {
                        const particles = [];
                        for (const {point, normal} of randomPoints) {
                            const particle = document.createElement('a-entity');
                            particle.setAttribute('class', 'grass');
                            particle.setAttribute('position', `${point.x} ${point.y} ${point.z}`);
                            const model = document.createElement('a-entity');
                            model.setAttribute('rotation', '90 0 0');
                            model.setAttribute('instanced-mesh-member', 'mesh: #grass-mesh;');
                            particle.appendChild(model);
                            particle.object3D.up = normal;
                            particle.object3D.lookAt(new THREE.Vector3().copy(point).add(new THREE.Vector3().random()));
                            this.el.appendChild(particle);
                            model.components.rotation.update({x: 0, y: 0, z: 0});
                            model.object3D.updateMatrix();
                            particle.components.position.update({x: 0, y: 0, z: 0});
                            particle.object3D.updateMatrix();
                            particles.push(particle);
                        }
                        this.el.object3D.parent.matrixWorldAutoUpdate = true;
                        this.el.object3D.matrixWorldAutoUpdate = true;
                        this.el.object3D.updateWorldMatrix(false, true);
                        for (const particle of particles) {
                            particle.object3D.matrixAutoUpdate = false;
                            particle.object3D.matrixWorldAutoUpdate = false;
                        }
                        this.el.object3D.matrixWorldAutoUpdate = false;
                        this.el.object3D.parent.matrixWorldAutoUpdate = false;
                    };
                    const grassMesh = document.querySelector("#grass-mesh");
                    if (grassMesh.getObject3D("mesh")) {
                        updateTerrainWithGrass();
                    } else {
                        grassMesh.addEventListener("model-loaded", () => {
                            updateTerrainWithGrass();
                        });
                    }
                } else {
                    this.el.addEventListener('model-loaded', this.innerAddGrass);
                }
            },
            removeGrass: function () {
                const grasses = Array.from(this.el.querySelectorAll('.grass'));
                for (const grass of grasses) {
                    grass.parentNode.removeChild(grass);
                }
            },
            remove: function () {
                this.el.removeEventListener('add-grass', this.innerAddGrass);
                this.el.removeEventListener('remove-grass', this.innerRemoveGrass);
            },
        });

        AFRAME.registerComponent('tree-particles', {
            schema: {
                origin: { type: 'vec3', default: {x: 0, y: 0, z: 0} },
            },
            init: function () {
                this.innerAddGrass = this.addGrass.bind(this);
                this.innerRemoveGrass = this.removeGrass.bind(this);
                this.el.addEventListener('add-tree', this.innerAddGrass);
                this.el.addEventListener('remove-tree', this.innerRemoveGrass);
            },
            addGrass: function () {
                const meshes = [];
                this.el.object3D.traverse((node) => {
                    if (node.isMesh) {
                        meshes.push(node);
                    }
                });
                const mesh = meshes[0];
                if (mesh) {
                    const randomPoints = getRandomPointsOnMesh(mesh, this.data.origin, 16);

                    const updateTerrainWithGrass = () => {
                        for (const {point, normal} of randomPoints) {
                            const particle = document.createElement('a-entity');
                            particle.setAttribute('class', 'tree');
                            particle.setAttribute('position', `${point.x} ${point.y} ${point.z}`);
                            const model = document.createElement('a-entity');
                            model.setAttribute('rotation', '90 0 0');
                            model.setAttribute('instanced-mesh-member', 'mesh: #tree-mesh; memberMesh: true;');
                            model.setAttribute('hide-from-camera', '');
                            particle.appendChild(model);
                            particle.object3D.up = normal;
                            particle.object3D.lookAt(new THREE.Vector3().copy(point).add(new THREE.Vector3().random()));
                            this.el.appendChild(particle);
                            model.components.rotation.update({x: 0, y: 0, z: 0});
                            model.object3D.updateMatrix();
                            particle.components.position.update({x: 0, y: 0, z: 0});
                            particle.object3D.updateMatrix();
                        }
                    };
                    const treeMesh = document.querySelector("#tree-mesh");
                    if (treeMesh.getObject3D("mesh")) {
                        updateTerrainWithGrass();
                    } else {
                        treeMesh.addEventListener("model-loaded", () => {
                            updateTerrainWithGrass();
                        });
                    }
                } else {
                    this.el.addEventListener('model-loaded', this.innerAddGrass);
                }
            },
            removeGrass: function () {
                const trees = Array.from(this.el.querySelectorAll('.tree'));
                for (const tree of trees) {
                    tree.parentNode.removeChild(tree);
                }
            },
            remove: function () {
                this.el.removeEventListener('add-tree', this.innerAddGrass);
                this.el.removeEventListener('remove-tree', this.innerRemoveGrass);
            },
        });

        AFRAME.registerComponent('hide-from-camera', {
            schema: {},
            init: function () {
                this.elSet = new Set();
            },
            addTree: function (el) {
                this.elSet.add(el);
                this.updateVisible();
            },
            removeTree: function (el) {
                this.elSet.delete(el);
                this.updateVisible();
            },
            updateVisible: function () {
                this.el.object3D.visible = this.elSet.size === 0;
                this.el.emit("object3DUpdated");
            }
        });

        AFRAME.registerComponent("update-npc-position-entity", {
            schema: {},
            tick: function (t, dt) {
                const parent = this.el.parentElement;
                const center = this.el.parentElement.parentElement;
                const centerHeight = parent.object3D.getWorldPosition(new THREE.Vector3()).length();

                const scene = document.querySelector("a-scene");
                scene.object3D.attach(this.el.object3D);
                this.el.object3D.position.copy(this.el.object3D.getWorldPosition(new THREE.Vector3()).normalize().multiplyScalar(centerHeight));
                this.el.object3D.up = this.el.object3D.getWorldPosition(new THREE.Vector3()).normalize();
                this.el.object3D.lookAt(center.object3D.getWorldPosition(new THREE.Vector3()));
                parent.object3D.attach(this.el.object3D);
            },
        });

        AFRAME.registerComponent('hide-trees-from-camera', {
            schema: {},
            init: function () {
                this.oldIntersections = new Set();
            },
            tick: function (t, dt) {
                const origin = this.el.object3D.position.clone();
                const cameraEl = document.querySelector('[camera]');
                const threeCamera = cameraEl.getObject3D('camera'); // Access the Three.js camera
                const cameraDirection = threeCamera.getWorldPosition(new THREE.Vector3()).sub(origin.clone());
                const raycaster = new THREE.Raycaster(origin, cameraDirection.clone().normalize(), 0, cameraDirection.length());
                const scene = document.querySelector("a-scene");
                const terrainFolder = scene.querySelector("#terrain");
                const objects = Array.from(terrainFolder.querySelectorAll("[hide-from-camera]")).map(x => x.object3D);
                const newIntersections = raycaster.intersectObjects(objects, true).map(x => x.object);

                const newSet = new Set(newIntersections);
                const oldSet = this.oldIntersections;
                const addSet = newSet.difference(oldSet);
                const removeSet = oldSet.difference(newSet);

                for (const object of addSet) {
                    findParentAttribute(object.el, 'hide-from-camera').addTree(this);
                }
                for (const object of removeSet) {
                    findParentAttribute(object.el, 'hide-from-camera').removeTree(this);
                }
                this.oldIntersections = newSet;
            },
        });

        AFRAME.registerComponent('terrain-tile', {
            schema: {
                type: "string",
                default: ""
            },
            init: function () {
            },
            tick: function (t, dt) {
                if (!this.data) {
                    return;
                }

                const cameraEl = document.querySelector("#camera-rig");
                let cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());
                cameraPos = cameraPos.normalize();
                let tilePos = new THREE.Vector3();
                tilePos = tilePos.set.apply(tilePos, this.data.split(" "));
                tilePos = tilePos.normalize();

                const cos45 = Math.acos(Math.PI / 4);
                if (cameraPos.dot(tilePos) > cos45) {
                    this.el.setAttribute("visible", "true");
                } else {
                    this.el.setAttribute("visible", "false");
                }

                // auto update clickable
                const className = "clickable";
                if (cameraPos.dot(tilePos) > cos45 && !this.el.classList.contains(className)) {
                    this.el.classList.add(className);
                    if (this.el.components['grass-particles']) {
                        this.el.emit("add-grass");
                    }
                    if (this.el.components['tree-particles']) {
                        this.el.emit("add-tree");
                    }
                } else if (!(cameraPos.dot(tilePos) > cos45) && this.el.classList.contains(className)) {
                    this.el.classList.remove(className);
                    if (this.el.components['grass-particles']) {
                        this.el.emit("remove-grass");
                    }
                    if (this.el.components['tree-particles']) {
                        this.el.emit("remove-tree");
                    }
                }
            }
        });

        AFRAME.registerSystem('building', {
            schema: {},
            init: function () {
                this.seaPorts = new Map();
                this.ports = [];
                this.updatePorts = debounce(this.innerUpdatePorts.bind(this), 1000);
            },
            innerUpdatePorts: function () {
                this.ports.forEach(el => {
                    const building = el.components['building'];
                    const group = this.el.sceneEl.systems['globe-nav'].getGroup(el.components['position'].data);
                    const arr = this.seaPorts.get(group);
                    if (arr) {
                        building.locateNearestBuilding(arr);
                    }
                });
            },
            registerMe: function (el) {
                if (this.el.sceneEl.systems['globe-nav'].navMesh) {
                    const group = this.el.sceneEl.systems['globe-nav'].getGroup(el.components['position'].data);
                    if (this.seaPorts.has(group)) {
                        this.seaPorts.get(group).push(el);
                    } else {
                        this.seaPorts.set(group, [el]);
                    }
                    this.ports.push(el);
                    this.updatePorts();
                } else {
                    setTimeout(this.registerMe.bind(this, el), 100);
                }
            },
            unregisterMe: function (el) {
                const group = this.el.sceneEl.systems['globe-nav'].getGroup(el.components['position'].data);
                if (this.seaPorts.has(group)) {
                    const arr = this.seaPorts.get(group);
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
                {
                    const arr = this.ports;
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
            },
        });

        AFRAME.registerComponent('building', {
            schema: {
                type: "string",
                default: "house",
            },
            init: function () {
                this.system.registerMe(this.el);
                const tempType = this.data?.toString()?.toLowerCase() ?? "";
                let buildingTypes;
                switch (tempType) {
                    case "port": {
                        buildingTypes = [
                            "port"
                        ];
                        break;
                    }
                    case "temple": {
                        buildingTypes = [
                            "temple"
                        ];
                        break;
                    }
                    default: {
                        buildingTypes = [
                            "house",
                            "house",
                            "tavern",
                            "workshop",
                        ];
                    }
                }
                this.buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                if (this.buildingType === "house") {
                    const numNpcs = 1;
                    for (let i = 0; i < numNpcs; i++) {
                        this.el.setAttribute(`npc-spawner__${i}`, "");
                    }
                }
            },
            locateNearestBuilding: function (islandBuildings) {
                const buildingTypes = new Map();
                for (const el of islandBuildings) {
                    const building = el.components['building'];
                    const buildingType = building.buildingType;
                    if (buildingTypes.has(buildingType)) {
                        const arr = buildingTypes.get(buildingType);
                        arr.push(el);
                    } else {
                        const arr = [el];
                        buildingTypes.set(buildingType, arr);
                    }
                }

                this.nearestBuildingType = new Map();
                for (const [buildingType, els] of buildingTypes.entries()) {
                    const nearestBuilding = els.reduce((el, v) => {
                        if (!el) {
                            return v;
                        }

                        const start = new THREE.Vector3().copy(this.el.components['position'].data);
                        const endNew = new THREE.Vector3().copy(v.components['position'].data);
                        const endOld = new THREE.Vector3().copy(el.components['position'].data);
                        const distanceNew = start.distanceTo(endNew);
                        const distanceOld = start.distanceTo(endOld);
                        if (distanceNew < distanceOld) {
                            return v;
                        }
                        return el;
                    }, undefined);
                    if (nearestBuilding) {
                        this.nearestBuildingType.set(buildingType, nearestBuilding);
                    }
                }
                this.el.emit("found-nearest-building");
            },
            remove: function () {
                this.system.unregisterMe(this.el);
            },
        });

        AFRAME.registerSystem('pirate-port', {
            schema: {},
            init: function () {
                this.seaPorts = new Map();
                this.ports = [];
                this.updatePorts = debounce(this.innerUpdatePorts.bind(this), 1000);
            },
            innerUpdatePorts: function () {
                this.ports.forEach(el => {
                    const port = el.components['pirate-port'];
                    const group = this.el.sceneEl.systems['globe-ocean-nav'].getGroup(el.components['position'].data);
                    const arr = this.seaPorts.get(group);
                    if (arr) {
                        port.locateNearestPort(arr);
                    }
                });
            },
            registerMe: function (el) {
                if (this.el.sceneEl.systems['globe-ocean-nav'].navMesh) {
                    const group = this.el.sceneEl.systems['globe-ocean-nav'].getGroup(el.components['position'].data);
                    if (this.seaPorts.has(group)) {
                        this.seaPorts.get(group).push(el);
                    } else {
                        this.seaPorts.set(group, [el]);
                    }
                    this.ports.push(el);
                    this.updatePorts();
                } else {
                    setTimeout(this.registerMe.bind(this, el), 100);
                }
            },
            unregisterMe: function (el) {
                const group = this.el.sceneEl.systems['globe-ocean-nav'].getGroup(el.components['position'].data);
                if (this.seaPorts.has(group)) {
                    const arr = this.seaPorts.get(group);
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
                {
                    const arr = this.ports;
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
            },
        });

        AFRAME.registerComponent('pirate-port', {
            schema: {},
            init: function () {
                this.system.registerMe(this.el);
                this.el.setAttribute(`pirate-spawner__1`, "");
            },
            locateNearestPort: function (ports) {
                const els = [];
                for (const el of ports) {
                    els.push(el);
                }

                this.nearestPorts = [];
                for (let i = 0; i < 5; i++) {
                    const nearestBuilding = els.reduce((el, v) => {
                        if (!el) {
                            return v;
                        }
                        if (this.nearestPorts.includes(el) || el === this.el) {
                            return v;
                        }

                        const start = new THREE.Vector3().copy(this.el.components['position'].data);
                        const endNew = new THREE.Vector3().copy(v.components['position'].data);
                        const endOld = new THREE.Vector3().copy(el.components['position'].data);
                        const distanceNew = start.distanceTo(endNew);
                        const distanceOld = start.distanceTo(endOld);
                        if (distanceNew < distanceOld) {
                            return v;
                        }
                        return el;
                    }, undefined);
                    if (nearestBuilding) {
                        this.nearestPorts.push(
                            nearestBuilding
                        );
                    }
                }
                this.el.emit("found-nearest-building");
            },
            remove: function () {
                this.system.unregisterMe(this.el);
            },
        });

        window.spawnNpcsFlag = false;
        AFRAME.registerComponent('set-building-id', {
            schema: {},
            init: function () {
                this.elId = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
                this.el.setAttribute("id", this.elId);
            },
        });

        AFRAME.registerComponent('npc-spawner', {
            schema: {},
            multiple: true,
            init: function () {
                if (this.el.id) {
                    this.elId = this.el.id;
                } else {
                    this.elId = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
                    this.el.setAttribute("id", this.elId);
                }
                this.currentNpcId = null;
                this.initFiniteStateMachine();
                this.innerInitFiniteStateMachine = this.initFiniteStateMachine.bind(this)
                this.innerTransition = this.transition.bind(this);
                this.innerHandleDead = this.handleDead.bind(this);
                this.el.addEventListener('found-nearest-building', this.innerInitFiniteStateMachine);
                this.el.addEventListener('transition', this.innerTransition);
                this.el.addEventListener('dead', this.innerHandleDead);
            },
            initFiniteStateMachine: function () {
                const building = this.el.components['building'];
                if (!building.nearestBuildingType || this.isReady) {
                    return;
                }
                this.isHome = true;
                this.otherBuildings = new Map();
                for (const [key, value] of building.nearestBuildingType.entries()) {
                    this.otherBuildings.set(key, value);
                }
                if (this.otherBuildings.has('home')) {
                    this.otherBuildings.delete('home');
                }
                this.isReady = true;
                setTimeout(() => {
                    this.innerTransition();
                }, 10_000);
            },
            transition: function (evt) {
                const npcId = evt?.detail ?? null;
                if (!this.isReady) {
                    setTimeout(() => {
                        this.innerTransition(evt);
                    }, 10_000);
                    return;
                }
                if (!window.spawnNpcsFlag) {
                    setTimeout(() => {
                        this.innerTransition(evt);
                    }, 10_000);
                    return;
                }
                if (npcId && npcId !== this.currentNpcId) {
                    return;
                }
                if (this.isHome) {
                    const arr = Array.from(this.otherBuildings.values());
                    this.otherBuilding = arr[Math.floor(Math.random() * arr.length)];
                    if (this.otherBuilding) {
                        this.isHome = false;
                        if (this.currentNpcId) {
                            updateWalkingNpc(this.currentNpcId, this.otherBuilding);
                        } else {
                            this.currentNpcId = addWalkingNpc(this.elId, this.el, this.otherBuilding);
                        }
                    }
                } else {
                    this.isHome = true;
                    if (this.currentNpcId) {
                        updateWalkingNpc(this.currentNpcId, this.el);
                    } else {
                        this.currentNpcId = addWalkingNpc(this.elId, this.otherBuilding, this.el);
                    }
                    this.otherBuilding = undefined;
                }
            },
            handleDead: function (evt) {
                const npcId = evt?.detail ?? null;
                if (!this.isReady) {
                    setTimeout(() => {
                        this.innerHandleDead(evt);
                    }, 10_000);
                    return;
                }
                if (npcId && npcId !== this.currentNpcId) {
                    return;
                }
                if (npcId && npcId === this.currentNpcId) {
                    this.el.removeAttribute(`npc-spawner__${this.id}`);
                }
            },
            remove: function () {
                this.el.removeEventListener('found-nearest-building', this.innerInitFiniteStateMachine);
                this.el.removeEventListener('transition', this.innerTransition);
                this.el.removeEventListener('dead', this.innerHandleDead);
            },
        });

        AFRAME.registerComponent('pirate-spawner', {
            schema: {},
            multiple: true,
            init: function () {
                if (this.el.id) {
                    this.elId = this.el.id;
                } else {
                    this.elId = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
                    this.el.setAttribute("id", this.elId);
                }
                this.currentNpcId = null;
                this.initFiniteStateMachine();
                this.innerInitFiniteStateMachine = this.initFiniteStateMachine.bind(this)
                this.innerTransition = this.transition.bind(this);
                this.innerHandleDead = this.handleDead.bind(this);
                this.el.addEventListener('found-nearest-building', this.innerInitFiniteStateMachine);
                this.el.addEventListener('transition', this.innerTransition);
                this.el.addEventListener('dead', this.innerHandleDead);
            },
            initFiniteStateMachine: function () {
                const building = this.el.components['pirate-port'];
                if (!building.nearestPorts || this.isReady) {
                    return;
                }
                this.isHome = true;
                this.otherPorts = [...building.nearestPorts];
                this.isReady = true;
                setTimeout(() => {
                    this.innerTransition();
                }, 10_000);
            },
            transition: function (evt) {
                const npcId = evt?.detail ?? null;
                if (!this.isReady) {
                    setTimeout(() => {
                        this.innerTransition(evt);
                    }, 10_000);
                    return;
                }
                if (!window.spawnNpcsFlag) {
                    setTimeout(() => {
                        this.innerTransition(evt);
                    }, 10_000);
                    return;
                }
                if (npcId && npcId !== this.currentNpcId) {
                    return;
                }
                if (this.isHome) {
                    const arr = this.otherPorts;
                    this.otherPort = arr[Math.floor(Math.random() * arr.length)];
                    if (this.otherPort) {
                        this.isHome = false;
                        if (this.currentNpcId) {
                            updatePirateShip(this.currentNpcId, this.otherPort);
                        } else {
                            this.currentNpcId = addPirateShip(this.elId, this.el, this.otherPort);
                        }
                    }
                } else {
                    this.isHome = true;
                    if (this.currentNpcId) {
                        updatePirateShip(this.currentNpcId, this.el);
                    } else {
                        this.currentNpcId = addPirateShip(this.elId, this.otherPort, this.el);
                    }
                    this.otherPort = undefined;
                }
            },
            handleDead: function (evt) {
                const npcId = evt?.detail ?? null;
                if (!this.isReady) {
                    setTimeout(() => {
                        this.innerHandleDead(evt);
                    }, 10_000);
                    return;
                }
                if (npcId && npcId !== this.currentNpcId) {
                    return;
                }
                if (npcId && npcId === this.currentNpcId) {
                    this.el.removeAttribute(`pirate-spawner__${this.id}`);
                }
            },
            remove: function () {
                this.el.removeEventListener('found-nearest-building', this.innerInitFiniteStateMachine);
                this.el.removeEventListener('transition', this.innerTransition);
                this.el.removeEventListener('dead', this.innerHandleDead);
            },
        });

        AFRAME.registerComponent('npc-agent', {
            schema: {
                building: {type: 'selector'}
            },
            init: function () {
                this.innerBeginTransition = this.beginTransition.bind(this);
                this.innerHandleDead = this.handleDead.bind(this);
                this.el.addEventListener("navigation-end", this.innerBeginTransition);
                this.el.addEventListener("dead", this.innerHandleDead);
            },
            beginTransition: function () {
                if (!this.data.building) {
                    return;
                }
                this.data.building.emit('transition', this.el.id);
            },
            handleDead: function () {
                if (!this.data.building) {
                    return;
                }
                this.data.building.emit('dead', this.el.id);
            },
            remove: function () {
                this.el.removeEventListener("navigation-end", this.innerBeginTransition);
                this.el.removeEventListener("dead", this.innerHandleDead);
            },
        });

        AFRAME.registerComponent('npc-faction', {
            schema: {
                type: 'string',
                default: ''
            },
        });

        AFRAME.registerComponent('pirate-aim', {
            schema: {},
            init: function () {
                this.target = null;
                this.prevTarget = null;
            },
            tick: function (t, dt) {
                const el = this.el;
                if (!this.target) {
                    if (this.prevTarget) {
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyW", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyE", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyQ", synthetic: true});
                    }
                    this.prevTarget = this.target;
                    return;
                }
                this.prevTarget = this.target;

                const vPos = new THREE.Vector3().copy(el.components['dynamic-body'].body.position);
                const vForward = new THREE.Vector3(0, 0, -1).applyQuaternion(new THREE.Quaternion().copy(el.components['dynamic-body'].body.quaternion));
                const vTargetPos = new THREE.Vector3().copy(this.target.components['dynamic-body']?.body?.position ?? this.target.object3D.position);

                // Look at the next waypoint.
                // gazeTarget.y = vCurrent.y;
                // |  x  y  z |
                // | ax ay az |
                // | bx by bz |
                const getDeterminant = (vCurrent, forward, gazeTarget) => {
                    const a = vCurrent.clone().normalize();
                    const v1 = forward.clone().normalize();
                    const v2 = gazeTarget.clone().sub(vCurrent.clone()).normalize();

                    // make two vectors for determinant
                    let ax = v1.x;
                    let ay = v1.y;
                    let az = v1.z;
                    let bx = v2.x;
                    let by = v2.y;
                    let bz = v2.z;

                    // make basis matrix for sphere
                    let aVec = new THREE.Vector3().set(ax, ay, az).normalize();
                    let bVec = new THREE.Vector3().set(bx, by, bz).normalize();
                    const basisY = aVec.clone().normalize();
                    const basisZ = a.clone().normalize();
                    const basisX = new THREE.Vector3().crossVectors(basisY, basisZ);
                    const basis = new THREE.Matrix4().makeBasis(basisX, basisY, basisZ).invert();

                    // apply basis matrix
                    aVec = aVec.applyMatrix4(basis);
                    bVec = bVec.applyMatrix4(basis);
                    ax = aVec.x;
                    ay = aVec.y;
                    az = aVec.z;
                    bx = bVec.x;
                    by = bVec.y;
                    bz = bVec.z;

                    let det = ax * by + ay * bz + az * bx - ay * bx - az * by - ax * bz;
                    if (isNaN(det)) {
                        return 0;
                    }
                    if (aVec.dot(bVec) < 0) {
                        det += Math.sign(det);
                    }
                    return det;
                };
                const det2 = getDeterminant(vPos, vForward, vTargetPos);

                // get direction or side of boat target is on
                const vSide = new THREE.Vector3(det2 <= 0 ? 1 : -1, 0, 0)
                    .applyQuaternion(new THREE.Quaternion().copy(el.components['dynamic-body'].body.quaternion));
                const det3 = getDeterminant(vPos, vSide, vTargetPos);
                if (det3 < 0) {
                    if (Math.random() * 0.5 < Math.abs(det3)) {
                        el.components['globe-keyboard-controls'].onKeyDown({code: "KeyD", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA", synthetic: true});
                    } else {
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD", synthetic: true});
                    }
                } else if (det3 > 0) {
                    if (Math.random() * 0.33 < Math.abs(det3)) {
                        el.components['globe-keyboard-controls'].onKeyDown({code: "KeyA", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD", synthetic: true});
                    } else {
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA", synthetic: true});
                    }
                } else {
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyA", synthetic: true});
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyD", synthetic: true});
                }

                if (Math.abs(det3) < 0.1) {
                    if (Math.random() < 0.5) {
                        el.components['globe-keyboard-controls'].onKeyDown({code: det2 >= 0 ? "KeyQ" : "KeyE", synthetic: true});
                    } else {
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyQ", synthetic: true});
                        el.components['globe-keyboard-controls'].onKeyUp({code: "KeyE", synthetic: true});
                    }
                } else {
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyQ", synthetic: true});
                    el.components['globe-keyboard-controls'].onKeyUp({code: "KeyE", synthetic: true});
                }
            },
        });

        AFRAME.registerComponent('pirate-attack', {
            schema: {
                range: {type: 'number', default: 5},
            },
            init: function () {
                this.attackEls = [];
                this.innerAttack = this.attack.bind(this);
                this.innerBeginAttack = this.beginAttack.bind(this);
                this.innerEndAttack = this.endAttack.bind(this);
                this.el.addEventListener('pirate-attack', this.innerAttack);
                this.el.addEventListener('pirate-begin-attack', this.innerBeginAttack);
                this.el.addEventListener('pirate-end-attack', this.innerEndAttack);

                this.tickCounter = 0;
                this.findTickCount = 2;
                this.wasAttacking = false;
            },
            remove: function () {
                this.el.removeEventListener('pirate-attack', this.innerAttack);
                this.el.removeEventListener('pirate-begin-attack', this.innerBeginAttack);
                this.el.removeEventListener('pirate-end-attack', this.innerEndAttack);
                this.attackEls = [];
            },
            tick: function (t, dt) {
                if (this.tickCounter < this.findTickCount) {
                    this.tickCounter += dt / 1000;
                    return;
                }
                this.tickCounter = 0;

                const pos = this.el.object3D.position;
                for (const el of this.attackEls) {
                    const p = el.object3D.position;
                    const distance = pos.distanceTo(p);
                    if (distance < this.data.range) {
                        this.el.emit('pirate-begin-attack', el);
                        this.wasAttacking = true;
                        return;
                    }
                }
                if (this.wasAttacking) {
                    this.wasAttacking = false;
                    this.el.emit('pirate-end-attack');
                }
            },
            attack: function (evt) {
                this.attackEls = evt.detail;
            },
            beginAttack: function (evt) {
                this.el.components['pirate-aim'].target = evt.detail;
                this.el.setAttribute('globe-ocean-nav-agent', { enabled: false });
            },
            endAttack: function (evt) {
                this.el.components['pirate-aim'].target = null;
                this.el.setAttribute('globe-ocean-nav-agent', { enabled: true });
            },
        });

        const NPC_MELEE_STATE_ENUM = {
            IDLE: 0,
            BEGIN_ATTACK: 1,
            END_ATTACK: 2,
        };

        AFRAME.registerComponent('npc-melee-state', {
            init: function () {
                this.npcState = NPC_MELEE_STATE_ENUM.IDLE;
                this.innerNpcBeginAttack = this.npcBeginAttack.bind(this);
                this.innerNpcNavigationEnd = this.npcNavigationEnd.bind(this);
                this.el.addEventListener('npc-begin-attack', this.innerNpcBeginAttack);
                this.el.addEventListener('navigation-end', this.innerNpcNavigationEnd);
            },
            remove: function () {
                this.el.removeEventListener('npc-begin-attack', this.innerNpcBeginAttack);
                this.el.removeEventListener('navigation-end', this.innerNpcNavigationEnd);
            },
            npcBeginAttack: function () {
                if (this.npcState === NPC_MELEE_STATE_ENUM.IDLE) {
                    // detected begin attack event, block AI
                    this.npcState = NPC_MELEE_STATE_ENUM.BEGIN_ATTACK;
                }
            },
            npcNavigationEnd: function () {
                if (this.npcState === NPC_MELEE_STATE_ENUM.BEGIN_ATTACK) {
                    // detected end attack event, block AI
                    this.npcState = NPC_MELEE_STATE_ENUM.END_ATTACK;
                } else if (this.npcState === NPC_MELEE_STATE_ENUM.END_ATTACK) {
                    // detected second end attack event, unbLOCK AI
                    this.npcState = NPC_MELEE_STATE_ENUM.IDLE;
                }
            }
        });

        AFRAME.registerComponent('npc-melee', {
            schema: {
                origin: { type: 'vec3', default: '0 0 0' },
                target: { type: 'selector', default: null },
                speed: { type: 'number', default: 6 },
            },
            init: function () {
                this.tickCounter = 0;
                this.findTickCount = 2;
            },
            goToTarget: function (t, dt) {
                const vDelta = new THREE.Vector3();
                const vNext = new THREE.Vector3();

                const el = this.el;
                const data = this.data;
                const speed = data.speed * dt / 1000;

                // Current segment is a vector from current position to next waypoint.
                const vCurrent = el.object3D.position;
                const vWaypoint = this.data.target.object3D.position.clone();
                vDelta.subVectors(vWaypoint, vCurrent);

                const distance = vDelta.length();
                let gazeTarget;

                if (distance <= speed) {
                    vNext.copy(vCurrent);
                    gazeTarget = vWaypoint;
                } else {
                    // If still far away from next waypoint, find next position for
                    // the current frame.
                    vNext.copy(vDelta.setLength(speed)).add(vCurrent);
                    gazeTarget = vWaypoint;
                }

                // Look at the next waypoint.
                // gazeTarget.y = vCurrent.y;
                el.object3D.up = new THREE.Vector3().copy(vCurrent).normalize();
                el.object3D.lookAt(gazeTarget);

                vCurrent.copy(vNext);

                const destination1 = new THREE.Vector3().copy(vCurrent);
                const raycaster = new THREE.Raycaster(destination1.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), destination1.clone().negate());
                const m = findParentScene(this.el)?.systems['globe-nav'].getNavMesh();
                if (!m) {
                    return;
                }
                const intersections = raycaster.intersectObject(m);
                if (intersections[0]) {
                    const destination2 = intersections[0].point.clone();
                    vCurrent.copy(destination2);
                }
            },
            tick: function (t, dt) {
                if (this.data.target && ((this.data.target.components['health'] && this.data.target.components['health'].data.health > 0) || this.data.target.components['networked-health'])) {
                    // go to target
                    this.goToTarget.call(this, t, dt);

                    // every 2 seconds
                    if (this.tickCounter < this.findTickCount) {
                        this.tickCounter += dt / 1000;
                        return;
                    }
                    this.tickCounter = 0;

                    // melee attack
                    const pos = this.el.object3D.position;
                    const p = this.data.target.object3D.position;
                    const distance = pos.distanceTo(p);
                    if (distance < 1) {
                        this.el.emit('npc-begin-melee', this.data.target);
                    }
                } else {
                    // return to origin
                    const destination1 = this.data.origin;
                    const destination2 = this.el.object3D.position.clone();
                    setTimeout(() => {
                        const raycaster = new THREE.Raycaster(destination2.clone().normalize().multiplyScalar(PLANET_SIZE * 1.3), destination2.clone().negate());
                        const m = findParentScene(this.el)?.systems['globe-nav'].getNavMesh();
                        if (!m) {
                            return;
                        }
                        const intersections = raycaster.intersectObject(m);
                        if (intersections[0]) {
                            const destination2 = intersections[0].point.clone();
                            this.el.setAttribute("globe-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2;`);
                        }
                    }, 250);
                    setTimeout(() => {
                        this.el.setAttribute("globe-nav-agent", `active: false; destination: ${destination1.x} ${destination1.y} ${destination1.z}; speed: 2;`);
                    }, 500);
                    setTimeout(() => {
                        this.el.setAttribute("globe-nav-agent", `active: true; destination: ${destination1.x} ${destination1.y} ${destination1.z}; speed: 2;`);
                    }, 1000);
                    this.el.removeAttribute("npc-melee");
                }
            }
        });

        AFRAME.registerComponent('npc-attack', {
            schema: {
                range: {type: 'number', default: 10},
                melee: {type: 'boolean', default: false},
                charModelId: {type: 'string', default: ''},
            },
            init: function () {
                this.attackEls = [];
                this.innerAttack = this.attack.bind(this);
                this.innerBeginAttack = this.beginAttack.bind(this);
                this.innerBeginMelee = this.beginMelee.bind(this);
                this.el.addEventListener('npc-attack', this.innerAttack);
                this.el.addEventListener('npc-begin-attack', this.innerBeginAttack);
                this.el.addEventListener('npc-begin-melee', this.innerBeginMelee);

                this.tickCounter = 0;
                this.findTickCount = 2;
            },
            remove: function () {
                this.el.removeEventListener('npc-attack', this.innerAttack);
                this.el.removeEventListener('npc-begin-attack', this.innerBeginAttack);
                this.el.removeEventListener('npc-begin-melee', this.innerBeginMelee);
                this.attackEls = [];
            },
            tick: function (t, dt) {
                if (this.tickCounter < this.findTickCount) {
                    this.tickCounter += dt / 1000;
                    return;
                }
                this.tickCounter = 0;

                const pos = this.el.object3D.position;
                for (const el of this.attackEls) {
                    const p = el.object3D.position;
                    const distance = pos.distanceTo(p);
                    if (distance < this.data.range) {
                        this.el.emit('npc-begin-attack', el);
                        return;
                    }
                }
            },
            attack: function (evt) {
                this.attackEls = evt.detail;
            },
            beginAttack: function (evt) {
                const target = evt.detail;
                if (this.data.melee && !this.el.hasAttribute('npc-melee')) {
                    if ([NPC_MELEE_STATE_ENUM.IDLE, NPC_MELEE_STATE_ENUM.END_ATTACK].includes(this.el.components['npc-melee-state'].npcState)) {
                        const p = this.el.components['globe-nav-agent'].data.destination;
                        const pv = new THREE.Vector3().copy(p);
                        if (pv.distanceTo(this.el.object3D.position) < this.data.range) {
                            this.el.setAttribute("npc-melee", `origin: ${p.x} ${p.y} ${p.z}; target: #${target.id}`);
                        }
                    }
                } else {
                    addProjectile(this.el, target, this.data.charModelId);
                }
            },
            beginMelee: function (evt) {
                const target = evt.detail;
                addProjectile(this.el, target, this.data.charModelId);
            },
        });

        AFRAME.registerComponent('projectile-flight', {
            schema: {
                target: {type: 'selector'},
                speed: {type: 'number', default: 10},
            },
            init: function () {
            },
            tick: function (t, dt) {
                const vDelta = new THREE.Vector3();
                const vNext = new THREE.Vector3();

                const el = this.el;
                const data = this.data;
                const speed = data.speed * dt / 1000;

                if (!this.data.target) {
                    this.el.emit('miss');
                    this.el.parentNode.removeChild(this.el);
                    return;
                }

                // Current segment is a vector from current position to next waypoint.
                const vCurrent = el.object3D.position;
                let vWaypoint = this.data.target.object3D.position.clone();
                vWaypoint = vWaypoint.add(vWaypoint.clone().normalize());
                vDelta.subVectors(vWaypoint, vCurrent);

                const distance = vDelta.length();
                let gazeTarget;

                if (distance <= speed) {
                    vNext.copy(vCurrent);
                    gazeTarget = vWaypoint;

                    this.data.target.emit('hit', 40);
                    this.el.parentNode.removeChild(this.el);
                } else {
                    // If still far away from next waypoint, find next position for
                    // the current frame.
                    vNext.copy(vDelta.setLength(speed)).add(vCurrent);
                    gazeTarget = vWaypoint;
                }

                // Look at the next waypoint.
                // gazeTarget.y = vCurrent.y;
                el.object3D.up = new THREE.Vector3().copy(vCurrent).normalize();
                el.object3D.lookAt(gazeTarget);

                vCurrent.copy(vNext);
            },
        });

        AFRAME.registerComponent('cannon-ball-flight', {
            schema: {
                speed: {type: 'number', default: 10},
            },
            init: function () {
            },
        });

        AFRAME.registerComponent('health', {
            schema: {
                health: { type: 'number', default: 100 }
            },
            init: function () {
                this.innerHandleHit = this.handleHit.bind(this);
                this.el.addEventListener('hit', this.innerHandleHit);

                this.maxHealth = this.data.health;
                this.healTickDelay = 10;
                this.healTickCount = this.healTickDelay;
                this.healTickAmount = this.maxHealth / 10;
                this.el.setAttribute("set-follow-id", "");
            },
            remove: function () {
                this.el.removeEventListener('hit', this.innerHandleHit);
            },
            tick: function (t, dt) {
                if (this.data.health >= this.maxHealth) {
                    return;
                }

                if (this.healTickCount >= 0) {
                    this.healTickCount -= dt / 1000;
                    return;
                }

                const oldHealth = this.data.health;
                const newHealth = Math.min(oldHealth + this.healTickAmount, this.maxHealth);
                this.el.setAttribute("health", `health: ${newHealth}`);
                addHealSound(this.el);
            },
            update(oldData) {
                this.healTickCount = this.healTickDelay;
            },
            handleHit: function (evt) {
                const hit = evt.detail;
                const oldHealth = this.data.health;
                const newHealth = this.data.health - hit;
                this.el.setAttribute("health", `health: ${newHealth}`);

                if (newHealth <= 0 && oldHealth > 0) {
                    this.el.emit('dead');
                    addWilhelmScream(this.el);
                    this.el.parentNode.removeChild(this.el);
                }
            },
        });

        AFRAME.registerComponent('networked-health', {
            schema: {
            },
            init: function () {
                this.innerHandleHit = this.handleHit.bind(this);
                this.el.addEventListener('hit', this.innerHandleHit);
            },
            remove: function () {
                this.el.removeEventListener('hit', this.innerHandleHit);
            },
            handleHit: function (evt) {
                const hit = evt.detail;
                const senderId = this.el.components['networked'].data.owner;
                const networkId = this.el.components['networked'].data.networkId;
                NAF.connection.sendDataGuaranteed(senderId, "networkedHealth", {
                    networkId,
                    hit,
                });
            },
        });

        AFRAME.registerComponent('ship-health', {
            schema: {
                health: { type: 'number', default: 4000 }
            },
            init: function () {
                this.innerHandleHit = this.handleHit.bind(this);
                this.el.addEventListener('hit', this.innerHandleHit);

                this.maxHealth = this.data.health;
                this.healTickDelay = 10;
                this.healTickCount = this.healTickDelay;
                this.healTickAmount = this.maxHealth / 10;
                this.el.setAttribute("set-follow-id", "");
            },
            remove: function () {
                this.el.removeEventListener('hit', this.innerHandleHit);
            },
            tick: function (t, dt) {
                if (this.data.health >= this.maxHealth) {
                    return;
                }

                if (this.healTickCount >= 0) {
                    this.healTickCount -= dt / 1000;
                    return;
                }

                const oldHealth = this.data.health;
                const newHealth = Math.min(oldHealth + this.healTickAmount, this.maxHealth);
                this.el.setAttribute("ship-health", `health: ${newHealth}`);
                addRepairSound(this.el);
            },
            update(oldData) {
                this.healTickCount = this.healTickDelay;
            },
            handleHit: function (evt) {
                const hit = evt.detail;
                const oldHealth = this.data.health;
                const newHealth = this.data.health - hit;
                this.el.setAttribute("ship-health", `health: ${newHealth}`);

                if (newHealth <= 0 && oldHealth > 0) {
                    this.el.emit('dead');
                }
            },
        });

        AFRAME.registerComponent('networked-ship-health', {
            schema: {
            },
            init: function () {
                this.innerHandleHit = this.handleHit.bind(this);
                this.el.addEventListener('hit', this.innerHandleHit);
            },
            remove: function () {
                this.el.removeEventListener('hit', this.innerHandleHit);
            },
            handleHit: function (evt) {
                const hit = evt.detail;
                const senderId = this.el.components['networked'].data.owner;
                const networkId = this.el.components['networked'].data.networkId;
                NAF.connection.sendDataGuaranteed(senderId, "networkedShipHealth", {
                    networkId,
                    hit,
                });
            },
        });

        AFRAME.registerComponent("ship-death", {
            schema: {},
            init: function () {
                this.innerHandleDeath = this.handleDeath.bind(this);
                this.el.addEventListener('dead', this.innerHandleDeath);
            },
            remove: function () {
                this.el.removeEventListener('dead', this.innerHandleDeath);
            },
            handleDeath: function () {
                this.el.setAttribute("despawn", "");
                this.el.setAttribute("globe-gravity", "ship: true; buoyancy: false;");
            },
        });

        AFRAME.registerComponent("spawn-gold", {
            schema: {},
            init: function () {
                this.innerHandleDead = this.handleDead.bind(this);
                this.innerHandleRaze = this.handleRaze.bind(this);
                this.el.addEventListener('dead', this.innerHandleDead);
                this.el.addEventListener('raze', this.innerHandleRaze);
            },
            remove: function () {
                this.el.removeEventListener('dead', this.innerHandleDead);
                this.el.removeEventListener('raze', this.innerHandleRaze);
            },
            handleDead: function () {
                for (let i = 0; i < 3; i++) {
                    addGoldCoin(this.el);
                }
            },
            handleRaze: function () {
                for (let i = 0; i < 1; i++) {
                    addPirateArr(this.el);
                    addGoldCoin(this.el);
                }
            },
        });

        AFRAME.registerComponent("gold-coin-movement", {
            schema: {},
            init: function () {
                this.interval = setTimeout(this.applyImpulse.bind(this), 100);
            },
            remove: function () {
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }
            },
            applyImpulse: function () {
                if (this.el.body) {
                    const getRandom1to1 = () => (Math.random() * 2) - 1;
                    const bPos = this.el.body.position.clone();
                    const impulse = new CANNON.Vec3().set(getRandom1to1(), getRandom1to1(), getRandom1to1());
                    const bPosNorm = bPos.clone();
                    bPosNorm.normalize();
                    impulse.normalize();
                    impulse.vadd(bPosNorm, impulse);
                    impulse.scale(300, impulse);
                    const bPosOffset = new CANNON.Vec3().set(getRandom1to1(), getRandom1to1(), getRandom1to1());
                    bPosOffset.normalize();
                    bPosOffset.scale(0.5, bPosOffset);
                    this.el.body.applyImpulse(impulse, bPosOffset);
                    this.interval = setTimeout(this.removeGoldCoin.bind(this), 10_000);
                } else {
                    this.interval = setTimeout(this.applyImpulse.bind(this), 100);
                }
            },
            removeGoldCoin: function () {
                this.el.parentNode.removeChild(this.el);
            },
        });

        AFRAME.registerComponent("handle-shadow-parameter", {
            schema: {},
            tick: function (t, dt) {
                const cameraEl = document.querySelector("#camera-rig");
                const cameraPos = cameraEl.object3D.getWorldPosition(new THREE.Vector3());

                const size = 30;
                const shadowCameraBottom = -cameraPos.z - size;
                const shadowCameraTop = -cameraPos.z + size;
                const shadowCameraLeft = cameraPos.x - size;
                const shadowCameraRight = cameraPos.x + size;

                const el = this.el;
                el.setAttribute("light", {
                    shadowCameraBottom,
                    shadowCameraTop,
                    shadowCameraLeft,
                    shadowCameraRight,
                });
            },
        });

        AFRAME.registerComponent("set-follow-id", {
            schema: {},
            init: function () {
                this.delay = 1;
            },
            tick: function (t, dt) {
                if (this.delay >= 0) {
                    this.delay -= dt / 1000;
                    return;
                }

                if (!this.el.id) {
                    this.el.id = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
                }
                this.el.removeAttribute("set-follow-id");
            },
        });

        AFRAME.registerComponent('follow-entity', {
            schema: {
                target: { type: 'selector' }, // Selector for the entity to follow
                offset: { type: 'vec3', default: { x: 0, y: 0, z: -1 } }, // Offset from the target
                speed: { type: 'number', default: 0.1 } // Speed of following
            },

            tick: function (time, deltaTime) {
                const targetEl = this.data.target;
                if (!targetEl) return;

                const targetPosition = targetEl.object3D.position;
                const followerPosition = this.el.object3D.position;

                // Calculate desired position with offset
                const desiredPosition = new THREE.Vector3();
                desiredPosition.copy(targetPosition).add(this.data.offset);

                // Lerp towards the desired position for smooth following
                followerPosition.lerp(desiredPosition, this.data.speed);

                // Optional: Make the follower look at the target
                // this.el.object3D.lookAt(targetPosition);
            }
        });

        function addTemplate(templateId, charModelId, instanceModelId, memberMesh) {
            const scene = document.querySelector("a-scene");

            const str = characterModels.get(charModelId).split("|")[0];

            const rootGoldCoin = document.createElement("a-entity");
            if (charModelId === "SHIP" || charModelId === "PIRATE_SHIP") {
                const dataEl = document.createElement("a-entity");
                dataEl.setAttribute("class", "data");
                dataEl.setAttribute("scale", "0.001 0.001 0.001");
                dataEl.setAttribute("rotation", "0 -90 0");
                getBuildingLodHash(str, 100, "auto");
                dataEl.setAttribute("globe-networked-instanced-mesh-member", `meshUrl: ${str}; memberMesh: ${memberMesh};`);
                dataEl.setAttribute("shadow", "");
                rootGoldCoin.setAttribute("networked-ship-health", "");
                rootGoldCoin.setAttribute("cannonball-collider", "");
                rootGoldCoin.appendChild(dataEl);
            } else if (charModelId === "WIZARD_TOWER") {
                const dataEl = document.createElement("a-entity");
                dataEl.setAttribute("class", "data");
                dataEl.setAttribute("scale", "1 1 1");
                dataEl.setAttribute("rotation", "-90 0 0");
                getBuildingLodHash(str, 1000, "auto");
                dataEl.setAttribute("globe-networked-instanced-mesh-member", `meshUrl: ${str}; memberMesh: ${memberMesh};`);
                dataEl.setAttribute("shadow", "");
                rootGoldCoin.appendChild(dataEl);
            } else {
                getBuildingLodHash(str, 2000, "auto");
                rootGoldCoin.setAttribute("globe-networked-instanced-mesh-member", `meshUrl: ${str}; capacity: 2000; memberMesh: ${memberMesh};`);
                rootGoldCoin.setAttribute("shadow", "");
            }

            if (charModelId === "FIREBALL") {
                rootGoldCoin.setAttribute("scale", "0.05 0.05 0.05");
            }

            if (charModelId === "SHIP") {
                rootGoldCoin.setAttribute("npc-faction", "other-players");
                rootGoldCoin.setAttribute("npc-finder", "active: false;");
            }

            if (charModelId === "PIRATE_SHIP") {
                rootGoldCoin.setAttribute("npc-faction", "pirate");
                rootGoldCoin.setAttribute("npc-finder", "active: false;");
            }

            if (charModelId === "PERSON") {
                rootGoldCoin.setAttribute("npc-faction", "native");
                rootGoldCoin.setAttribute("npc-finder", "active: false;");
                rootGoldCoin.setAttribute("networked-health", "");
                rootGoldCoin.setAttribute("networked-globe-nav-agent", `active: false; startTime: ${+new Date()}; speed: 1;`);
                rootGoldCoin.setAttribute("position", "");
                rootGoldCoin.setAttribute("rotation", "");
            }

            if (charModelId === "WARRIOR" || charModelId === "WIZARD") {
                rootGoldCoin.setAttribute("npc-faction", "other-players");
                rootGoldCoin.setAttribute("npc-finder", "active: false;");
                rootGoldCoin.setAttribute("networked-health", "");
            }

            const a = (() => {
                const assets = document.querySelector("a-assets");
                if (assets) {
                    return assets;
                } else {
                    const a1 = document.createElement("a-assets");
                    scene.appendChild(a1);
                    return a1;
                }
            })();

            const t = (() => {
                const template = a.querySelector(`#${templateId}`);
                if (template) {
                    return null;
                } else {
                    const t1 = document.createElement("template");
                    t1.setAttribute("id", templateId);
                    return [t1];
                }
            })();

            const componentRequiresUpdate = () => {
                let prev = null;

                return curr => {
                    if (prev === null) {
                        prev = curr;
                        return true;
                    } else if (JSON.stringify(prev) !== JSON.stringify(curr)) {
                        prev = curr;
                        return true;
                    }

                    return false;
                };
            };

            if (t) {
                t[0].content.appendChild(rootGoldCoin);
                a.appendChild(t[0]);

                if (charModelId === "SHIP" || charModelId === "PIRATE_SHIP") {
                    if (!NAF.schemas.hasTemplate(`#${templateId}`)) {
                        NAF.schemas.add({
                            template: `#${templateId}`,
                            components: [
                                {
                                    component: 'position',
                                    requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.001)
                                },
                                {
                                    component: 'rotation',
                                    requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.5)
                                },
                                {
                                    selector: '.data',
                                    component: 'scale',
                                },
                                {
                                    selector: '.data',
                                    component: 'rotation',
                                },
                                {
                                    selector: '.data',
                                    component: 'globe-networked-instanced-mesh-member',
                                    requiresNetworkUpdate: componentRequiresUpdate,
                                },
                            ]
                        });
                    }
                } else if (charModelId === "WIZARD_TOWER") {
                    if (!NAF.schemas.hasTemplate(`#${templateId}`)) {
                        NAF.schemas.add({
                            template: `#${templateId}`,
                            components: [
                                {
                                    component: 'position',
                                    requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.001)
                                },
                                {
                                    component: 'rotation',
                                    requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.5)
                                },
                                {
                                    selector: '.data',
                                    component: 'scale',
                                },
                                {
                                    selector: '.data',
                                    component: 'rotation',
                                },
                                {
                                    selector: '.data',
                                    component: 'globe-networked-instanced-mesh-member',
                                    requiresNetworkUpdate: componentRequiresUpdate,
                                },
                            ]
                        });
                    }
                } else if (charModelId === "PERSON") {
                    if (!NAF.schemas.hasTemplate(`#${templateId}`)) {
                        NAF.schemas.add({
                            template: `#${templateId}`,
                            components: [
                                {
                                    component: 'networked-globe-nav-agent',
                                },
                                {
                                    component: 'globe-networked-instanced-mesh-member',
                                    requiresNetworkUpdate: componentRequiresUpdate,
                                },
                            ]
                        });
                    }
                } else {
                    if (!NAF.schemas.hasTemplate(`#${templateId}`)) {
                        NAF.schemas.add({
                            template: `#${templateId}`,
                            components: [
                                {
                                    component: 'position',
                                    requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.001)
                                },
                                {
                                    component: 'rotation',
                                    requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.5)
                                },
                                {
                                    component: 'scale',
                                    requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.001)
                                },
                                {
                                    component: 'globe-networked-instanced-mesh-member',
                                    requiresNetworkUpdate: componentRequiresUpdate,
                                },
                            ]
                        });
                    }
                }
            }
        }

        function addGoldCoin(startEl) {
            const scene = document.querySelector("a-scene");

            const rootGoldCoin = document.createElement("a-entity");
            const id = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
            rootGoldCoin.setAttribute("id", id);
            rootGoldCoin.setAttribute("class", "gold-coin");
            const pos = startEl.object3D.getWorldPosition(new THREE.Vector3());
            pos.add(pos.clone().normalize());
            rootGoldCoin.setAttribute("position", `${pos.x} ${pos.y} ${pos.z}`);
            rootGoldCoin.setAttribute("rotation", "0 0 0");
            rootGoldCoin.setAttribute("dynamic-body", "shape: sphere; sphereRadius: 0.5; mass: 100");
            rootGoldCoin.setAttribute("globe-gravity", "");
            rootGoldCoin.setAttribute("collision-filter", "group: gold-coin; ");
            rootGoldCoin.setAttribute("gold-coin-movement", "");
            rootGoldCoin.setAttribute("shadow", "");

            if (characterModels.has("GOLD_COIN")) {
                const str = characterModels.get("GOLD_COIN");

                // add graphics
                getBuildingLodHash(str, 1000, "auto");
                rootGoldCoin.setAttribute("globe-networked-instanced-mesh-member", `meshUrl: ${str}; capacity: 1000; memberMesh: true`);
                rootGoldCoin.setAttribute("networked", "template: #gold-coin-template; attachTemplateToLocal: false;");

                scene.components['coin-purse'].addGoldCoins(1);
            } else {
                const modelGold = document.createElement("a-sphere");
                modelGold.setAttribute("scale", "0.1 0.1 0.1");
                modelGold.setAttribute("position", "0 0 0");

                rootGoldCoin.appendChild(modelGold);
            }

            scene.appendChild(rootGoldCoin);

            return id;
        }

        function addProjectile(startEl, destinationEl, charModelId) {
            const scene = document.querySelector("a-scene");

            const rootProjectile = document.createElement("a-entity");
            const id = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
            rootProjectile.setAttribute("id", id);
            rootProjectile.setAttribute("class", "projectile");
            rootProjectile.setAttribute("projectile-flight", `target: #${destinationEl.id}`);
            const pos = startEl.object3D.position.clone().add(startEl.object3D.position.clone().normalize());
            rootProjectile.setAttribute("position", `${pos.x} ${pos.y} ${pos.z}`);
            rootProjectile.setAttribute("rotation", "0 0 0");
            rootProjectile.setAttribute("shadow", "");
            if (charModelId === "FIREBALL") {
                rootProjectile.setAttribute("scale", "0.05 0.05 0.05");
            }

            if (characterModels.has(charModelId)) {
                const str = characterModels.get(charModelId).split("|")[0];

                // add graphics
                getBuildingLodHash(str, 1000, "auto");
                rootProjectile.setAttribute("globe-networked-instanced-mesh-member", `meshUrl: ${str}; capacity: 1000; memberMesh: true`);
                rootProjectile.setAttribute("networked", "template: #arrow-template; attachTemplateToLocal: false;");
            } else {
                const modelArrow = document.createElement("a-sphere");
                modelArrow.setAttribute("scale", "0.1 0.1 0.1");
                modelArrow.setAttribute("position", "0 0 0");

                rootProjectile.appendChild(modelArrow);
            }

            scene.appendChild(rootProjectile);

            return id;
        }

        function findParentAttribute(el, attribute) {
            if (!el) {
                return "";
            }
            if (el.components[attribute]) {
                return el.components[attribute];
            }
            return findParentAttribute(el.parentElement, attribute);
        }

        function findParentScene(el) {
            if (!el) {
                return null;
            }
            if (el.sceneEl) {
                return el.sceneEl;
            }
            return findParentAttribute(el.parentElement);
        }

        function addCannonBall(pos, velocity, el, damage) {
            const scene = document.querySelector("a-scene");

            const rootProjectile = document.createElement("a-entity");
            const id = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
            rootProjectile.setAttribute("id", id);
            rootProjectile.setAttribute("class", "cannonball");
            rootProjectile.setAttribute("position", `${pos.x} ${pos.y} ${pos.z}`);
            rootProjectile.setAttribute("rotation", "0 0 0");
            rootProjectile.setAttribute("shadow", "");
            rootProjectile.setAttribute("dynamic-body", "shape: sphere; sphereRadius: 0.5; mass: 5");
            rootProjectile.setAttribute("globe-gravity", "");
            rootProjectile.setAttribute("collision-filter", "group: cannonball; collidesWith: default");
            rootProjectile.setAttribute("initial-velocity", `${velocity.x} ${velocity.y} ${velocity.z}`);
            rootProjectile.setAttribute("cannonball-collider-ground", "");
            rootProjectile.setAttribute("cannonball-collider-water", "");
            rootProjectile.setAttribute("cannonball-hit-ready", `damage: ${damage}`);
            rootProjectile.setAttribute("npc-faction", findParentAttribute(el, "npc-faction").data);
            rootProjectile.setAttribute("despawn", "");

            if (characterModels.has("CANNONBALL")) {
                const str = characterModels.get("CANNONBALL");

                // add graphics
                getBuildingLodHash(str, 1000, "auto");
                rootProjectile.setAttribute("globe-networked-instanced-mesh-member", `meshUrl: ${str}; capacity: 1000; memberMesh: true`);
                rootProjectile.setAttribute("networked", "template: #cannonball-template; attachTemplateToLocal: false;");
            } else {
                const modelArrow = document.createElement("a-sphere");
                modelArrow.setAttribute("scale", "0.1 0.1 0.1");
                modelArrow.setAttribute("position", "0 0 0");

                rootProjectile.appendChild(modelArrow);
            }

            addCannonballFire(el);

            scene.appendChild(rootProjectile);

            return id;
        }

        function addWalkingNpc(buildingId, buildingEl, destinationEl) {
            const scene = document.querySelector("a-scene");

            const rootNpc = document.createElement("a-entity");
            const id = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
            rootNpc.setAttribute("id", id);
            rootNpc.setAttribute("class", "walking-npc");
            const destination2 = destinationEl.components['position'].data;
            const pos = buildingEl.components['position'].data;
            rootNpc.setAttribute("position", `${pos.x} ${pos.y} ${pos.z}`);
            rootNpc.setAttribute("rotation", "0 0 0");
            rootNpc.setAttribute("npc-agent", `building: #${buildingId}`);
            rootNpc.setAttribute("npc-faction", "native");
            rootNpc.setAttribute("npc-finder", "active: false;");
            rootNpc.setAttribute("health", "");
            rootNpc.setAttribute("spawn-gold", "");
            rootNpc.setAttribute("networked-globe-nav-agent", {active: false});
            rootNpc.setAttribute("shadow", "");
            setTimeout(() => {
                rootNpc.setAttribute("networked-globe-nav-agent", {
                    active: true,
                    start: pos,
                    startTime: +new Date(),
                    destination: destination2,
                    speed: 1,
                });
            }, 2000);

            if (characterModels.has("PERSON")) {
                const str = characterModels.get("PERSON");

                // add graphics
                getBuildingLodHash(str, 1000, "auto");
                rootNpc.setAttribute("globe-networked-instanced-mesh-member", `meshUrl: ${str}; capacity: 1000; memberMesh: true`);
                rootNpc.setAttribute("networked", "template: #person-template; attachTemplateToLocal: false;");
            } else {
                const modelNpc = document.createElement("a-sphere");
                modelNpc.setAttribute("scale", "0.1 0.1 0.1");
                modelNpc.setAttribute("position", "0 0 0");

                rootNpc.appendChild(modelNpc);
            }

            scene.appendChild(rootNpc);

            return id;
        }

        function updateWalkingNpc(npcId, destinationEl) {
            const rootNpc = document.querySelector(`#${npcId}`);
            const destination2 = destinationEl.components['position'].data;
            rootNpc.setAttribute("networked-globe-nav-agent", {active: false});
            setTimeout(() => {
                const start = new THREE.Vector3().copy(rootNpc.components['networked-globe-nav-agent'].data.destination);
                if (start.length() <= 0) {
                    start.copy(destination2);
                    rootNpc.components['position'].data = start.clone();
                }
                rootNpc.setAttribute("networked-globe-nav-agent", {
                    active: true,
                    start,
                    startTime: +new Date(),
                    destination: destination2,
                    speed: 1,
                });
            }, 2000);
        }

        function addPirateShipSpawnPoint(data) {
            const scene = document.querySelector("a-scene");
            const terrain = scene.querySelector("#terrain");

            const {
                point
            } = JSON.parse(data);

            const entity = document.createElement("a-entity");
            entity.setAttribute("class", "pirate-ship-spawn");
            entity.setAttribute("building-id", "");
            entity.setAttribute("terrain-tile", `${point[0]} ${point[1]} ${point[2]}`);
            entity.setAttribute("position", `${point[0]} ${point[1]} ${point[2]}`);
            entity.setAttribute("pirate-port", "");
            terrain.appendChild(entity);
        }

        function addPirateShip(buildingId, buildingEl, destinationEl) {
            const scene = document.querySelector("a-scene");

            const str = characterModels.get("PIRATE_SHIP");

            const rootShip = document.createElement("a-entity");
            const id = "id" + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
            rootShip.setAttribute("id", id);
            rootShip.setAttribute("class", "pirate-ship");
            const destination2 = destinationEl.components['position'].data;
            const pos = buildingEl.components['position'].data;

            rootShip.setAttribute("dynamic-body", "shape: sphere; sphereRadius: 1; mass: 100");
            rootShip.setAttribute("collision-filter", "group: ship; collidesWith: default");
            rootShip.setAttribute("globe-gravity", "ship: true;");
            rootShip.setAttribute("ship-health", "");
            rootShip.setAttribute("ship-death", "");
            rootShip.setAttribute("cannonball-damage", "damage: 50;");
            rootShip.setAttribute("fire-cannons", "");
            rootShip.setAttribute("firing-cannons", "");
            rootShip.setAttribute("globe-keyboard-controls", "enabled: true; fly: true; npc: true;");
            rootShip.setAttribute("globe-ocean-nav-agent", `active: false;`);
            rootShip.setAttribute("npc-agent", `building: #${buildingId}`);
            rootShip.setAttribute("shadow", "");
            rootShip.setAttribute("cannonball-collider", "");
            rootShip.setAttribute("position", `${pos.x} ${pos.y} ${pos.z}`);
            rootShip.setAttribute("rotation", "0 0 0");
            rootShip.setAttribute("npc-faction", "pirate");
            rootShip.setAttribute("pirate-finder", "active: true;");
            rootShip.setAttribute("pirate-attack", "range: 10");
            rootShip.setAttribute("pirate-aim", "");

            const rootModel = document.createElement("a-entity");
            rootModel.setAttribute("class", "data");
            getBuildingLodHash(str, 100, "auto");
            rootModel.setAttribute("globe-networked-instanced-mesh-member", `meshUrl: ${str}; capacity: 100; memberMesh: true`);
            rootModel.setAttribute("scale", "0.001 0.001 0.001");
            rootModel.setAttribute("rotation", "0 -90 0");
            rootModel.setAttribute("setup-cannons", `url: ${str};`);
            rootShip.appendChild(rootModel);
            rootShip.setAttribute("networked", "template: #pirate-ship-template; attachTemplateToLocal: false;");

            scene.appendChild(rootShip);

            setTimeout(() => {
                rootShip.setAttribute("globe-ocean-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 1;`);
            }, 2000);

            return id;
        }

        function updatePirateShip(npcId, destinationEl) {
            const rootNpc = document.querySelector(`#${npcId}`);
            const destination2 = destinationEl.components['position'].data;
            rootNpc.setAttribute("globe-ocean-nav-agent", `active: false;`);
            setTimeout(() => {
                rootNpc.setAttribute("globe-ocean-nav-agent", `active: true; destination: ${destination2.x} ${destination2.y} ${destination2.z}; speed: 2;`);
            }, 2000);
        }

        function addNpc(i) {
            const scene = document.querySelector("a-scene");

            const rootNpc = document.createElement("a-entity");
            rootNpc.setAttribute("class", `${scene.components['coin-purse'].activeUnit}`);
            rootNpc.setAttribute("globe-nav-agent", "");
            rootNpc.setAttribute("position", "0 0 0");
            rootNpc.setAttribute("rotation", "0 0 0");
            rootNpc.setAttribute("npc-faction", "player");
            rootNpc.setAttribute("npc-finder", "active: true;");
            rootNpc.setAttribute("npc-attack", `range: 5; melee: true; charModelId: ARROW`);
            rootNpc.setAttribute("npc-melee-state", "");
            rootNpc.setAttribute("health", "");
            rootNpc.setAttribute("shadow", "");
            rootNpc.setAttribute("hide-trees-from-camera", "");

            if (characterModels.has("WARRIOR")) {
                const str = characterModels.get("WARRIOR");
                getBuildingLodHash(str, 1000, "auto");
                rootNpc.setAttribute("globe-networked-instanced-mesh-member", `meshUrl: ${str}; capacity: 1000; memberMesh: true`);
                rootNpc.setAttribute("networked", "template: #warrior-template; attachTemplateToLocal: false;");
            } else {
                const modelNpc = document.createElement("a-sphere");
                modelNpc.setAttribute("scale", "0.1 0.1 0.1");
                modelNpc.setAttribute("position", "0 0 0");
                rootNpc.appendChild(modelNpc);
            }

            const positionCenterNpc = document.createElement("a-entity");
            positionCenterNpc.setAttribute("position", "0 0 -5");
            rootNpc.appendChild(positionCenterNpc);

            const positionNpc = document.createElement("a-entity");
            positionNpc.setAttribute("class", `${scene.components['coin-purse'].activeUnit}-position`);
            positionNpc.setAttribute("update-npc-position-entity", "");
            positionCenterNpc.appendChild(positionNpc);

            scene.appendChild(rootNpc);
        }

        function removeNpc() {
            const scene = document.querySelector("a-scene");
            const arr = Array.from(document.querySelectorAll(`.${unitMap.get(scene.components['coin-purse'].activeUnit)}`));
            arr.forEach(a => scene.removeChild(a));
            const arr2 = Array.from(document.querySelectorAll(`.${unitMap.get(scene.components['coin-purse'].activeUnit)}-wizard`));
            arr2.forEach(a => scene.removeChild(a));
        }

        AFRAME.registerComponent("rise-out-of-ground", {
            schema: {
                position: {
                    type: "vec3",
                    default: new THREE.Vector3(),
                },
            },
            init: function () {
                this.done = false;
                this.begin = false;
                this.active = false;
                this.maxHeight = -100;
            },
            tick: function () {
                if (this.done) {
                    return;
                }

                const meshes = [];
                this.el.object3D.traverse((x) => {
                    if (x.isMesh) {
                        meshes.push(x);
                    }
                });

                if (meshes.length <= 0) {
                    return;
                }

                if (!this.begin && !this.active) {
                    this.maxHeight = meshes.reduce((acc, x) => Math.max(acc, x.geometry.boundingBox.max.z), -100);
                    this.startTime = +new Date() / 1000;
                    this.endTime = (+new Date() / 1000) + this.maxHeight;
                    this.begin = true;
                    this.active = true;
                }

                if (this.begin && this.active) {
                    const l = THREE.MathUtils.mapLinear(+new Date() / 1000, this.startTime, this.endTime, -this.maxHeight, 0);
                    const c = THREE.MathUtils.clamp(l, -this.maxHeight, 0);
                    this.el.object3D.position.copy(this.data.position).add(new THREE.Vector3().copy(this.data.position).normalize().multiplyScalar(c));
                    if (c >= 0) {
                        this.active = false;
                    }
                }

                if (this.begin && !this.active) {
                    const scene = document.querySelector("a-scene");
                    scene.systems['globe-nav'].insertGhostBuilding(this.el);

                    this.done = true;
                }
            },
        });

        let ghostBuilding = null;

        function addGhostBuilding(position) {
            const scene = document.querySelector("a-scene");

            const rootHouse = document.createElement("a-entity");
            rootHouse.setAttribute("class", "wizard-tower");
            rootHouse.setAttribute("position", position);
            rootHouse.setAttribute("orthographic-camera-building", "");
            rootHouse.setAttribute("projected-texture__wizard-tower", "image: /meshes/WizardTowerProjection.png; enabled: true");

            scene.appendChild(rootHouse);
            if (ghostBuilding) {
                scene.removeChild(ghostBuilding);
                ghostBuilding = null;
            }
            ghostBuilding = rootHouse;

            rootHouse.buildActivate = () => {
                rootHouse.setAttribute("projected-texture__wizard-tower", {
                    enabled: false,
                });

                const type = "WIZARD_TOWER";
                const str = characterModels.get(type).split("|")[0];
                const point = [position.x, position.y, position.z];
                const lookAt = new THREE.Vector3(0, 0, -1).applyQuaternion(rootHouse.components["orthographic-camera-building"].camera.getWorldQuaternion(new THREE.Quaternion()));
                rootHouse.setAttribute("rise-out-of-ground", {
                    position,
                });

                const rootModel = document.createElement("a-entity");
                rootModel.setAttribute("class", "data");
                getBuildingLodHash(str, 1000, "auto");
                rootModel.setAttribute("globe-networked-instanced-mesh-member", `meshUrl: ${str}; capacity: 1000; memberMesh: true; ghostBuilding: true;`);
                rootModel.setAttribute("scale", "1 1 1");
                rootModel.setAttribute("rotation", "-90 0 0");
                rootModel.setAttribute("position", "0 0 0");
                rootHouse.appendChild(rootModel);
                rootHouse.setAttribute("networked", "template: #wizard-tower-template; attachTemplateToLocal: false;");

                rootHouse.object3D.up = new THREE.Vector3(point[0], point[1], point[2]).normalize();
                rootHouse.object3D.lookAt(new THREE.Vector3(lookAt[0], lookAt[1], lookAt[2]));
            };
        }

        function addWizardNpc() {
            const scene = document.querySelector("a-scene");

            const rootNpc = document.createElement("a-entity");
            rootNpc.setAttribute("class", `${scene.components['coin-purse'].activeUnit}-wizard`);
            rootNpc.setAttribute("globe-nav-agent", "");
            rootNpc.setAttribute("position", "0 0 0");
            rootNpc.setAttribute("rotation", "0 0 0");
            rootNpc.setAttribute("npc-faction", "player");
            rootNpc.setAttribute("npc-finder", "active: true;");
            rootNpc.setAttribute("npc-attack", `range: 10; charModelId: FIREBALL`);
            rootNpc.setAttribute("health", "health: 1000;");
            rootNpc.setAttribute("wizard-mana", "");
            rootNpc.setAttribute("shadow", "");
            rootNpc.setAttribute("globe-moba-controls", "");
            rootNpc.setAttribute("hide-trees-from-camera", "");

            if (characterModels.has("WIZARD")) {
                const str = characterModels.get("WIZARD");
                getBuildingLodHash(str, 1000, "auto");
                rootNpc.setAttribute("globe-networked-instanced-mesh-member", `meshUrl: ${str}; capacity: 1000; memberMesh: true`);
                rootNpc.setAttribute("networked", "template: #wizard-template; attachTemplateToLocal: false;");
            } else {
                const modelNpc = document.createElement("a-sphere");
                modelNpc.setAttribute("scale", "0.1 0.1 0.1");
                modelNpc.setAttribute("position", "0 0 0");
                rootNpc.appendChild(modelNpc);
            }

            const positionCenterNpc = document.createElement("a-entity");
            positionCenterNpc.setAttribute("update-wizard-position-entity", "0 0 0");
            rootNpc.appendChild(positionCenterNpc);

            const positionNpc = document.createElement("a-entity");
            positionNpc.setAttribute("class", `${scene.components['coin-purse'].activeUnit}-wizard-position`);
            positionNpc.setAttribute("update-npc-position-entity", "");
            positionCenterNpc.appendChild(positionNpc);

            const orthographicCamera = document.createElement("a-entity");
            orthographicCamera.setAttribute("class", "wizard-area-of-effect");
            orthographicCamera.setAttribute("position", "0 0 5");
            orthographicCamera.setAttribute("orthographic-camera", "");
            orthographicCamera.setAttribute("projected-texture__forward-attack", "image: /images/attack-front.png");
            orthographicCamera.setAttribute("obb-attack-zone__forward-attack", "center: 0 0 -5; dimension: 2 50 5; debug: false;");
            orthographicCamera.setAttribute("projected-texture__area-attack", "image: /images/attack-area.png");
            orthographicCamera.setAttribute("obb-attack-zone__area-attack", "center: 0 0 0; dimension: 2 50 2; debug: false;");
            positionNpc.appendChild(orthographicCamera);

            scene.appendChild(rootNpc);
        }

        function addTerrain(item) {
            const [str, collidable, navmesh, ocean, oceanNavmesh, vertex, projected] = JSON.parse(item);
            const rootTerrain = document.createElement("a-entity");
            rootTerrain.setAttribute("gltf-model", str);
            rootTerrain.addEventListener("model-loaded", buildBoundsTree);
            rootTerrain.setAttribute("position", "0 0 0");
            rootTerrain.setAttribute("shadow", "");
            rootTerrain.setAttribute("terrain-tile", (vertex ?? []).join(" "));
            if (oceanNavmesh) {
                // ocean nav mesh
                rootTerrain.setAttribute("go-to-sea", "");
                rootTerrain.setAttribute("globe-ocean-nav-mesh", "");
            } else if (projected) {
                // land nav mesh
                rootTerrain.setAttribute("globe-nav-projected-mesh", "");
            }  else if (navmesh) {
                // land nav mesh
                rootTerrain.setAttribute("globe-nav-mesh", "");
            } else if (ocean) {
                // transparent ocean
                // do nothing
                rootTerrain.setAttribute("go-to-sea", "");
            } else if (collidable) {
                // physics land
                rootTerrain.setAttribute("static-body", "shape: none;");
                rootTerrain.setAttribute("globe-trimesh", "");
                rootTerrain.setAttribute("go-on-land", "");
                rootTerrain.setAttribute("grass-particles", `origin: ${vertex[0] * PLANET_SIZE} ${vertex[1] * PLANET_SIZE} ${vertex[2] * PLANET_SIZE}`);
                rootTerrain.setAttribute("tree-particles", `origin: ${vertex[0] * PLANET_SIZE} ${vertex[1] * PLANET_SIZE} ${vertex[2] * PLANET_SIZE}`);
            } else {
                // physics ocean bottom
                rootTerrain.setAttribute("static-body", "shape: none;");
                rootTerrain.setAttribute("globe-trimesh", "");
            }

            const scene = document.querySelector("a-scene");
            const terrainFolder = scene.querySelector("#terrain");
            terrainFolder.appendChild(rootTerrain);
        }

        AFRAME.registerComponent("terrain-folder-optimization", {
            schema: {},
            init: function () {
                this.el.object3D.matrixAutoUpdate = false;
                this.el.object3D.matrixWorldAutoUpdate = false;
            },
        });

        function clearTerrain() {
            const scene = document.querySelector("a-scene");
            const arr = Array.from(document.querySelectorAll("[terrain-tile]"));
            arr.forEach(a => a.parentElement.removeChild(a));
        }

        var characterModels = new Map();

        function addCharacterModel(item) {
            const {
                data: str, type
            } = JSON.parse(item);

            characterModels.set(type, str);

            switch (type) {
                case "WIZARD": {
                    addTemplate("wizard-template", "WIZARD", "wizard-model", false);
                    break;
                }
                case "WARRIOR": {
                    addTemplate("warrior-template", "WARRIOR", "warrior-model", false);
                    break;
                }
                case "PERSON": {
                    addTemplate("person-template", "PERSON", "person-model", false);
                    break;
                }
                case "ARROW": {
                    addTemplate("arrow-template", "ARROW", "arrow-model", false);
                    break;
                }
                case "FIREBALL": {
                    addTemplate("fireball-template", "FIREBALL", "fireball-model", false);
                    break;
                }
                case "CANNONBALL": {
                    addTemplate("cannonball-template", "CANNONBALL", "cannonball-model", false);
                    break;
                }
                case "GOLD_COIN": {
                    addTemplate("gold-coin-template", "GOLD_COIN", "gold-coin-model", false);
                    break;
                }
                case "SHIP": {
                    addTemplate("ship-template", "SHIP", "ship-model", false);
                    break;
                }
                case "PIRATE_SHIP": {
                    addTemplate("pirate-ship-template", "PIRATE_SHIP", "pirate-ship-model", false);
                    break;
                }
                case "WIZARD_TOWER": {
                    addTemplate("wizard-tower-template", "WIZARD_TOWER", "wizard-tower-model", false);
                    break;
                }
            }
        }

        /**
         * Building placement should have a ghost building moving across terrain,
         * The ghost building should appear if it is in a valid location,
         * The ghost building should disappear if it is not in a valid location,
         *
         * Clicking should spawn a building below ground level,
         * The building will rise out of the ground for a few seconds until maximum height
         * The building will then be part of the map.
         * @param item
         */
        function placeBuildingBegin(item) {
            const {
                type
            } = JSON.parse(item);


        }

        function addHouse(item) {
            const {
                type, point, lookAt
            } = JSON.parse(item);

            const rootHouse = document.createElement("a-entity");
            rootHouse.setAttribute("class", "house");
            rootHouse.setAttribute("position", `${point[0]} ${point[1]} ${point[2]}`);
            rootHouse.setAttribute("terrain-tile", "");
            rootHouse.setAttribute("building", type.toString().toLowerCase());

            const rootModel = document.createElement("a-entity");
            rootModel.setAttribute("globe-lod", characterModels.get(type));
            if (type === "PORT") {
                rootModel.setAttribute("scale", "0.1 0.1 0.1");
                rootModel.setAttribute("rotation", "90 0 0");
                rootModel.setAttribute("position", "0 -1.35 -0.5");
            } else {
                rootModel.setAttribute("scale", "1 1 1");
                rootModel.setAttribute("rotation", "90 0 0");
                rootModel.setAttribute("position", "0 0 0");
            }
            rootModel.components.scale.update({x: 1, y: 1, z: 1});
            rootModel.components.rotation.update({x: 0, y: 0, z: 0});
            rootModel.components.position.update({x: 0, y: 0, z: 0});
            rootModel.object3D.updateMatrix();
            rootHouse.appendChild(rootModel);

            const lod0 = document.createElement("a-entity");
            lod0.setAttribute("class", `lod0 clickable${type === "PORT" ? " port" : ""}`);
            if (type !== "PORT") {
                lod0.setAttribute("go-on-land", "raze: true");
                lod0.setAttribute("spawn-gold", "");
                lod0.setAttribute("set-building-id", "");
            }
            lod0.setAttribute("shadow", "");
            rootModel.appendChild(lod0);

            const lod1 = document.createElement("a-entity");
            lod1.setAttribute("class", `lod1 clickable${type === "PORT" ? " port" : ""}`);
            if (type !== "PORT") {
                lod1.setAttribute("go-on-land", "raze: true");
                lod1.setAttribute("spawn-gold", "");
                lod1.setAttribute("set-building-id", "");
            }
            lod1.setAttribute("shadow", "");
            rootModel.appendChild(lod1);

            const lod2 = document.createElement("a-entity");
            lod2.setAttribute("class", `lod2 clickable${type === "PORT" ? " port" : ""}`);
            if (type !== "PORT") {
                lod2.setAttribute("go-on-land", "raze: true");
                lod2.setAttribute("spawn-gold", "");
                lod2.setAttribute("set-building-id", "");
            }
            lod2.setAttribute("shadow", "");
            rootModel.appendChild(lod2);

            const scene = document.querySelector("a-scene");
            const terrainFolder = scene.querySelector("#terrain");
            terrainFolder.appendChild(rootHouse);

            rootHouse.object3D.up = new THREE.Vector3(point[0], point[1], point[2]).normalize();
            rootHouse.object3D.lookAt(new THREE.Vector3(lookAt[0], lookAt[1], lookAt[2]));
            rootHouse.components.position.update({x: 0, y: 0, z: 0});
            rootHouse.object3D.updateMatrix();
            rootHouse.object3D.updateWorldMatrix(false, true);
            rootHouse.object3D.matrixAutoUpdate = false;
            rootHouse.object3D.matrixWorldAutoUpdate = false;
            rootModel.object3D.matrixAutoUpdate = false;
            rootModel.object3D.matrixWorldAutoUpdate = false;
        }

        function addCannonballFire(el) {
            const position = el.object3D.getWorldPosition(new THREE.Vector3());
            const scene = document.querySelector("a-scene");

            const entity = document.createElement("a-entity");
            entity.setAttribute("position", position);
            entity.setAttribute("networked", "template: #cannonball-fire-template; attachTemplateToLocal: true;");
            entity.setAttribute("despawn", "1");
            scene.appendChild(entity);
        }

        function addCannonballHit(el) {
            const position = el.object3D.getWorldPosition(new THREE.Vector3()).sub(new THREE.Vector3().copy(el.body.velocity.clone()));
            const scene = document.querySelector("a-scene");

            const entity = document.createElement("a-entity");
            entity.setAttribute("position", position);
            entity.setAttribute("networked", "template: #cannonball-hit-template; attachTemplateToLocal: true;");
            entity.setAttribute("despawn", "1");
            scene.appendChild(entity);
        }

        function addCannonballThump(el) {
            const position = el.object3D.getWorldPosition(new THREE.Vector3());
            const scene = document.querySelector("a-scene");

            const entity = document.createElement("a-entity");
            entity.setAttribute("position", position);
            entity.setAttribute("networked", "template: #cannonball-thump-template; attachTemplateToLocal: true;");
            entity.setAttribute("despawn", "1");
            scene.appendChild(entity);
        }

        function addCannonballSplash(el) {
            const position = el.object3D.getWorldPosition(new THREE.Vector3());
            const scene = document.querySelector("a-scene");

            const entity = document.createElement("a-entity");
            entity.setAttribute("position", position);
            entity.setAttribute("networked", "template: #cannonball-splash-template; attachTemplateToLocal: true;");
            entity.setAttribute("despawn", "1");
            scene.appendChild(entity);
        }

        function addWilhelmScream(el) {
            const position = el.object3D.getWorldPosition(new THREE.Vector3());
            const scene = document.querySelector("a-scene");

            const entity = document.createElement("a-entity");
            entity.setAttribute("position", position);
            entity.setAttribute("networked", "template: #wilhelm-scream-template; attachTemplateToLocal: true;");
            entity.setAttribute("despawn", "");
            scene.appendChild(entity);
        }

        function addPirateArr(el) {
            const position = el.object3D.getWorldPosition(new THREE.Vector3());
            const scene = document.querySelector("a-scene");

            const entity = document.createElement("a-entity");
            entity.setAttribute("position", position);
            entity.setAttribute("networked", "template: #arr-template; attachTemplateToLocal: true;");
            entity.setAttribute("despawn", "");
            scene.appendChild(entity);
        }

        function addRepairSound(el) {
            const position = el.object3D.getWorldPosition(new THREE.Vector3());
            const scene = document.querySelector("a-scene");

            const entity = document.createElement("a-entity");
            entity.setAttribute("position", position);
            entity.setAttribute("networked", "template: #repair-template; attachTemplateToLocal: true;");
            if (el.id) {
                entity.setAttribute("follow-entity", {
                    target: `#${el.id}`,
                    offset: new THREE.Vector3().set(0, 0, 0),
                    speed: 1,
                });
            }
            entity.setAttribute("despawn", "");
            scene.appendChild(entity);
        }

        function addHealSound(el) {
            const position = el.object3D.getWorldPosition(new THREE.Vector3());
            const scene = document.querySelector("a-scene");

            const entity = document.createElement("a-entity");
            entity.setAttribute("position", position);
            entity.setAttribute("networked", "template: #heal-template; attachTemplateToLocal: true;");
            if (el.id) {
                entity.setAttribute("follow-entity", {
                    target: el.id,
                    offset: new THREE.Vector3().set(0, 0, 0),
                    speed: 1,
                });
            }
            entity.setAttribute("despawn", "");
            scene.appendChild(entity);
        }

        window.shipModelStr = "";
        window.shipSpawnPoint = new THREE.Vector3(0, 0, PLANET_SIZE);

        async function addShip(item) {
            const scene = document.querySelector("a-scene");

            const {
                data: str, point
            } = JSON.parse(item);

            if (!window.shipModelStr) {
                window.shipModelStr = str;
                window.shipSpawnPoint = new THREE.Vector3(point[0], point[1], point[2]);
            }

            while (!scene.components['coin-purse']) {
                await new Promise((resolve) => {
                    setTimeout(() => {
                        resolve();
                    }, 100);
                });
            }

            const rootShip = document.createElement("a-entity");
            rootShip.setAttribute("class", `${scene.components['coin-purse'].activeUnit} clickable`);
            rootShip.setAttribute("dynamic-body", "shape: sphere; sphereRadius: 1; mass: 100");
            rootShip.setAttribute("collision-filter", "group: ship; collidesWith: default");
            rootShip.setAttribute("globe-gravity", "ship: true;");
            rootShip.setAttribute("globe-keyboard-controls", "enabled: true; fly: true");
            rootShip.setAttribute("ship-health", "");
            rootShip.setAttribute("ship-death", "");
            rootShip.setAttribute("cannonball-damage", "damage: 100;");
            rootShip.setAttribute("fire-cannons", "");
            rootShip.setAttribute("firing-cannons", "");
            rootShip.setAttribute("shadow", "");
            rootShip.setAttribute("position", `${point[0]} ${point[1]} ${point[2]}`);
            rootShip.setAttribute("rotation", "0 0 0");
            rootShip.setAttribute("npc-faction", "player");
            rootShip.setAttribute("cannonball-collider", "");
            rootShip.setAttribute("pirate-finder", "active: false;");

            const rootModel = document.createElement("a-entity");
            rootModel.setAttribute("class", "data");
            getBuildingLodHash(str, 100, "auto");
            rootModel.setAttribute("globe-networked-instanced-mesh-member", `meshUrl: ${str}; capacity: 100; memberMesh: true`);
            rootModel.setAttribute("go-to-sea", "");
            rootModel.setAttribute("scale", "0.001 0.001 0.001");
            rootModel.setAttribute("rotation", "0 -90 0");
            rootModel.setAttribute("setup-cannons", `url: ${str}`);
            rootShip.appendChild(rootModel);
            rootShip.setAttribute("networked", "template: #ship-template; attachTemplateToLocal: false;");

            const rootPosition = document.createElement("a-entity");
            rootPosition.setAttribute("class", `${scene.components['coin-purse'].activeUnit}-position`);
            rootPosition.setAttribute("position", "0 0 5");
            rootShip.appendChild(rootPosition);

            scene.appendChild(rootShip);
            const cameraEl = document.querySelector("#camera-rig");
            cameraEl.setAttribute("look-at-box", `.${scene.components['coin-purse'].getUnit()}`);
        }

        function addClientSecret(item) {
            const {
                roomId,
                clientSecret,
            } = JSON.parse(item);

            window.gmRoomId = roomId;

            if (roomId === "demo") {
                return;
            }

            const scene = document.querySelector("a-scene");
            scene.setAttribute("networked-scene", `room: ${roomId}; adapter: ws; debug: true;`);
        }

        window.didSpawnNpcsFlag = false;
        function spawnNpcsNow() {
            if (!window.didSpawnNpcsFlag) {
                window.spawnNpcsFlag = true;
                window.didSpawnNpcsFlag = true;
            }
        }

        if (window.location.href.includes("localhost:3000")) {
            setTimeout(() => {
                spawnNpcsNow();
            }, 10_000);
        }

        function onConnect() {
            document.body.addEventListener("clientConnected", function (evt) {
                console.log("CLIENT CONNECTED", evt.detail.clientId);
            });
            document.body.addEventListener("clientDisconnected", function (evt) {
                console.log("CLIENT DISCONNECTED", evt.detail.clientId);
            });

            NAF.connection.subscribeToDataChannel('isHost', function (sender, dataType, data, targetId) {
                const hostSpanEle = document.getElementById("host-span");
                hostSpanEle.textContent = "HOST";
                spawnNpcsNow();
            });

            NAF.connection.subscribeToDataChannel('networkedHealth', function (sender, dataType, data, targetId) {
                const {
                    networkId,
                    hit,
                } = data;
                const entity = NAF.entities.entities[networkId];
                if (entity) {
                    entity.emit("hit", hit);
                }
            });

            NAF.connection.subscribeToDataChannel('networkedShipHealth', function (sender, dataType, data, targetId) {
                const {
                    networkId,
                    hit,
                } = data;
                const entity = NAF.entities.entities[networkId];
                if (entity) {
                    entity.emit("hit", hit);
                }
            });

            let micEnabled = true;
            const micBtnEle = document.getElementById("mic-btn");

            micBtnEle.addEventListener('click', function () {
                NAF.connection.adapter.enableMicrophone(!micEnabled);
                micEnabled = !micEnabled;
                micBtnEle.textContent = micEnabled ? 'Mute Mic' : 'Unmute Mic';
            });
        }

        AFRAME.registerComponent('align-with-projection', {
            schema: {
                offset: {
                    type: "vec3",
                    default: "0 0 -5",
                },
                rotation: {
                    type: "vec3",
                    default: "0 0 0",
                },
                scale: {
                    type: "vec3",
                    default: "1 1 1",
                },
                portShow: {
                    type: "boolean",
                    default: false,
                },
                wizardShow: {
                    type: "boolean",
                    default: false,
                },
                menuShow: {
                    type: "boolean",
                    default: false,
                },
                hammerShow: {
                    type: "boolean",
                    default: false,
                },
                buildShow: {
                    type: "boolean",
                    default: false,
                },
            },
            tick: function (t, dt) {
                const scene = document.querySelector("a-scene");
                if (!this.data.portShow) {
                    if (isDemoMode) {
                        this.el.object3D.visible = false;
                        return;
                    } else {
                        const wizard = scene.querySelector(`.${scene.components['coin-purse'].activeUnit}-wizard`);
                        if (this.data.wizardShow) {
                            this.el.object3D.visible = !!wizard;
                        } else {
                            this.el.object3D.visible = !wizard;
                        }

                        const buildMenuState = scene.querySelector("#build-menu-state");
                        if (this.data.menuShow && this.data.wizardShow) {
                            this.el.object3D.visible = !buildMenuState.hasAttribute("show-build") && !buildMenuState.hasAttribute("show-hammer");
                        }
                        if (this.data.buildShow && this.data.wizardShow) {
                            this.el.object3D.visible = buildMenuState.hasAttribute("show-build");
                        }
                        if (this.data.hammerShow && this.data.wizardShow) {
                            this.el.object3D.visible = buildMenuState.hasAttribute("show-hammer");
                        }
                    }
                }

                const camera = scene.camera;

                // do nothing if it is mobile
                const cameraLookControlsEl = document.querySelector('[globe-look-controls]');

                // align with camera in desktop
                const position = new THREE.Vector3(0, 0, 0);
                const rotation = new THREE.Quaternion(0, 0, 0, 1);
                const scale = new THREE.Vector3(1, 1, 1);
                if (!(this.el.sceneEl?.renderer?.xr?.isPresenting || cameraLookControlsEl.components['globe-look-controls']?.magicWindowControls?.enabled)) {
                    camera.projectionMatrix.decompose(position, rotation, scale);
                }
                const aspect = scene.canvas.width / scene.canvas.height;
                const offset = new THREE.Vector3(aspect, 1, 1).multiply(this.data.offset);
                position.add(offset).multiply(scale);
                if (!(this.el.sceneEl?.renderer?.xr?.isPresenting || cameraLookControlsEl.components['globe-look-controls']?.magicWindowControls?.enabled)) {
                    camera.getWorldQuaternion(rotation);
                }
                position.applyQuaternion(rotation);
                this.el.object3D.position.copy(position);
                this.el.object3D.quaternion.copy(rotation.multiply(new THREE.Quaternion().setFromEuler(new THREE.Euler(
                    THREE.MathUtils.degToRad(this.data.rotation.x),
                    THREE.MathUtils.degToRad(this.data.rotation.y),
                    THREE.MathUtils.degToRad(this.data.rotation.z)
                ))));
                this.el.object3D.scale.copy(this.data.scale);
            }
        });

        AFRAME.registerComponent('respawn', {
            schema: {},
            init: function () {
                this.respawnTick = +new Date() + 10_000;
                this.activeRespawn = false;
                this.respawnTime = 15_000;
            },
            tick: function (t, dt) {
                // respawn 5 seconds after no more ships
                const time = +new Date();
                if (this.respawnTick < time) {
                    if (this.activeRespawn) {
                        this.respawnTick = time + this.respawnTime;
                        this.activeRespawn = false;
                        const scene = document.querySelector("a-scene");
                        scene.components['coin-purse'].shipCount = 1;
                        scene.components['coin-purse'].buyShips();
                    } else {
                        const ships = [];
                        const activeUnits = [
                            'ship-1',
                            'ship-2',
                            'ship-3',
                        ];
                        for (const activeUnit of activeUnits) {
                            const s = Array.from(document.querySelectorAll(`.${activeUnit}`));
                            ships.push(...s);
                        }
                        if (ships.length === 0 && !!window.shipModelStr) {
                            this.respawnTick = time + this.respawnTime;
                            this.activeRespawn = true;
                        }
                    }
                }
            },
        });

        AFRAME.registerComponent('setup-cannons', {
            schema: {
                url: {type: 'string'},
            },
            init: function () {
                const updateMesh = (e) => {
                    const meshes = [];
                    e.traverse((x) => {
                        if (x.isMesh && x.name.includes("Cylinder")) {
                            meshes.push(x);
                        }
                    });
                    let leftCannons;
                    let rightCannons;
                    if (meshes.length) {
                        leftCannons = meshes.filter(x => x.position.z <= 0);
                        rightCannons = meshes.filter(x => x.position.z > 0);
                    } else {
                        e.el.components['instanced-mesh'].originalMesh.traverse((x) => {
                            if (x.isMesh && x.name.includes("Cylinder")) {
                                meshes.push(x);
                            }
                        });
                        leftCannons = meshes.filter(x => x.position.z <= 0);
                        rightCannons = meshes.filter(x => x.position.z > 0);
                    }
                    leftCannons.forEach(x => {
                        const entity = document.createElement("a-entity");
                        entity.setAttribute("position", x.position);
                        entity.setAttribute("class", "left-cannon");
                        this.el.appendChild(entity);

                        const positionEntity = document.createElement("a-entity");
                        positionEntity.setAttribute("position", new THREE.Vector3(0, 0, 5000).add(x.position));
                        positionEntity.setAttribute("class", "left-cannon-position");
                        this.el.appendChild(positionEntity);
                    });
                    rightCannons.forEach(x => {
                        const entity = document.createElement("a-entity");
                        entity.setAttribute("position", x.position);
                        entity.setAttribute("class", "right-cannon");
                        this.el.appendChild(entity);

                        const positionEntity = document.createElement("a-entity");
                        positionEntity.setAttribute("position", new THREE.Vector3(0, 0, -5000).add(x.position));
                        positionEntity.setAttribute("class", "right-cannon-position");
                        this.el.appendChild(positionEntity);
                    });
                };
                const shipMesh = document.querySelector(`#${getBuildingLodHash(this.data.url, 100, "auto")}`);
                const m = shipMesh.getObject3D("mesh");
                if (m) {
                    updateMesh(m);
                } else {
                    shipMesh.addEventListener("model-loaded", (e) => {
                        updateMesh(e.detail.model);
                    });
                }
            }
        });

        AFRAME.registerComponent('select-cannon-side', {
            schema: {
                selector: {
                    type: "string",
                    default: ""
                },
            },
            init: function () {
                this.innerDebounce = debounce(this.selectCannonSide.bind(this), 1, true);
                this.innerSelectCannonSide = () => {
                    this.innerDebounce.trigger();
                };
                this.el.addEventListener("click", this.innerSelectCannonSide);
            },
            remove: function () {
                this.el.removeEventListener("click", this.innerSelectCannonSide);
            },
            tick: function (t, dt) {
                const scene = document.querySelector("a-scene");
                const unit = scene.components['coin-purse'].getUnit();
                const visible = unit.startsWith("ship");
                this.el.setAttribute("visible", visible);
                this.el.emit("object3DUpdated");
            },
            selectCannonSide: function () {
                if (this.data.selector === "none-cannon") {
                    const cameraEl = document.querySelector("#camera-rig");
                    const selector = `.${scene.components['coin-purse'].getUnit()}`;
                    const firstClick = cameraEl.getAttribute("look-at-box") !== selector;
                    if (firstClick) {
                        cameraEl.setAttribute("look-at-box", selector);
                    }
                } else if (this.data.selector === "wizard-tower-build") {
                    const buildMenuState = document.querySelector("#build-menu-state");
                    buildMenuState.removeAttribute("show-hammer");
                    buildMenuState.setAttribute("show-build", "");
                    buildMenuState.setAttribute("wizard-tower-build", "");

                }  else if (this.data.selector === "hammer-build") {
                    const buildMenuState = document.querySelector("#build-menu-state");
                    buildMenuState.setAttribute("show-hammer", "");
                    buildMenuState.removeAttribute("show-build");
                    buildMenuState.removeAttribute("wizard-tower-build");

                } else if (this.data.selector === "cancel-build") {
                    const buildMenuState = document.querySelector("#build-menu-state");
                    buildMenuState.removeAttribute("show-hammer");
                    buildMenuState.removeAttribute("show-build");
                    buildMenuState.removeAttribute("wizard-tower-build");
                    const scene = document.querySelector("a-scene");
                    if (ghostBuilding) {
                        scene.removeChild(ghostBuilding);
                        ghostBuilding = null;
                    }

                } else if (this.data.selector === "ok-build") {
                    if (!ghostBuilding) {
                        return;
                    }

                    ghostBuilding.buildActivate();
                    ghostBuilding = null;
                    const buildMenuState = document.querySelector("#build-menu-state");
                    buildMenuState.removeAttribute("show-hammer");
                    buildMenuState.removeAttribute("show-build");
                    buildMenuState.removeAttribute("wizard-tower-build");

                } else if (this.data.selector === "forward-attack") {
                    const selector = `.${scene.components['coin-purse'].getUnit()} .wizard-area-of-effect`;
                    const el = document.querySelector(selector);
                    if (!el) {
                        return;
                    }
                    if (!findParentAttribute(el, "wizard-mana")?.canAttack()) {
                        return;
                    }
                    const firstClick = !el.components['projected-texture__forward-attack'].data.enabled;
                    if (firstClick) {
                        el.setAttribute("projected-texture__forward-attack", {
                            enabled: true,
                        });
                    } else {
                        el.setAttribute("projected-texture__forward-attack", {
                            enabled: false,
                        });
                        el.components['obb-attack-zone__forward-attack'].attack();
                    }
                } else if (this.data.selector === "area-attack") {
                    const selector = `.${scene.components['coin-purse'].getUnit()} .wizard-area-of-effect`;
                    const el = document.querySelector(selector);
                    if (!el) {
                        return;
                    }
                    if (!findParentAttribute(el, "wizard-mana")?.canAttack()) {
                        return;
                    }
                    const firstClick = !el.components['projected-texture__area-attack'].data.enabled;
                    if (firstClick) {
                        el.setAttribute("projected-texture__area-attack", {
                            enabled: true,
                        });
                    } else {
                        el.setAttribute("projected-texture__area-attack", {
                            enabled: false,
                        });
                        el.components['obb-attack-zone__area-attack'].attack();
                    }
                } else {
                    const cameraEl = document.querySelector("#camera-rig");
                    const selector = `.${scene.components['coin-purse'].getUnit()} .${this.data.selector}`;
                    const firstClick = cameraEl.getAttribute("look-at-box") !== selector;
                    if (firstClick) {
                        cameraEl.setAttribute("look-at-box", selector);
                    } else {
                        const ships = document.querySelectorAll(`.${scene.components['coin-purse'].getUnit().split(":", 2)[0]}`);
                        ships.forEach(s => {
                            s.emit("fire-cannons", this.data.selector);
                        });
                    }
                }
            },
        });

        AFRAME.registerComponent('fire-cannons', {
            schema: {},
            init: function () {
                this.innerFireCannons = this.fireCannons.bind(this);
                this.el.addEventListener("fire-cannons", this.innerFireCannons);
                this.lastFire = 0;
            },
            remove: function () {
                this.el.removeEventListener("fire-cannons", this.innerFireCannons);
            },
            fireCannons: function (e) {
                // fire every 2 seconds
                const dateValue = +new Date();
                if (this.lastFire < dateValue) {
                    this.lastFire = dateValue + 2_000;
                    this.el.emit('firing-cannons', e.detail);
                }
            },
        });

        AFRAME.registerComponent('cannonball-damage', {
            schema: {
                damage: {
                    type: 'number',
                    default: 10,
                },
            },
        });

        AFRAME.registerComponent('firing-cannons', {
            schema: {},
            init: function () {
                this.innerFiringCannons = this.firingCannons.bind(this);
                this.el.addEventListener("firing-cannons", this.innerFiringCannons);
            },
            remove: function () {
                this.el.removeEventListener("firing-cannons", this.innerFiringCannons);
            },
            firingCannons: function (e) {
                const selector = `.${e.detail}`;
                let cannons = Array.from(this.el.querySelectorAll(selector));
                if (!cannons.length) {
                    cannons = Array.from(this.el.object3D.el.querySelectorAll(selector));
                }
                cannons.forEach(cannon => {
                    const worldPosition = cannon.object3D.getWorldPosition(new THREE.Vector3());
                    worldPosition.add(worldPosition.clone().normalize().multiplyScalar(1.2));
                    const cannonBallOrientation = cannon.object3D.getWorldQuaternion(new THREE.Quaternion());
                    const velocity = new THREE.Vector3(0, 100, e.detail.includes("left") ? -300 : 300).applyQuaternion(cannonBallOrientation);

                    addCannonBall(worldPosition, velocity, cannon, this.el.components['cannonball-damage'].data.damage);
                });
            },
        });

        AFRAME.registerComponent("initial-velocity", {
            schema: {
                type: "vec3",
                default: "0 0 0",
            },
            tickSum: 2,
            tick: function (t, dt) {
                if (this.el.body && this.tickSum >= 0) {
                    this.el.body.applyForce(new CANNON.Vec3(this.data.x, this.data.y, this.data.z).scale(dt / 1000 * (1000 / 60)), new CANNON.Vec3(0, 0, 0));
                    this.tickSum -= dt / 1000;
                }
                if (this.el.body && this.tickSum < 0) {
                    this.el.removeAttribute("initial-velocity");
                }
            },
        });

        AFRAME.registerComponent("despawn", {
            schema: {
                type: "number",
                default: 10,
            },
            init: function () {
                this.deleteTime = +new Date() + this.data * 1000;
            },
            tick: function (t, dt) {
                if (+new Date() > this.deleteTime) {
                    this.el.parentElement.removeChild(this.el);
                }
            },
        });

        AFRAME.registerComponent("port-show", {
            schema: {},
            tick: function (t, dt) {
                const scene = document.querySelector("a-scene");
                const activeUnit = scene.components['coin-purse'].activeUnit;
                const ship = scene.querySelector(`.${activeUnit}`);
                if (ship) {
                    const position = ship.object3D.getWorldPosition(new THREE.Vector3());
                    const ports = Array.from(document.querySelectorAll(".port"));
                    const port = ports.find(x => {
                        const xPos = x.object3D.getWorldPosition(new THREE.Vector3());
                        const distance = xPos.distanceTo(position);
                        return distance < 5;
                    });
                    const visible = !!port;
                    this.el.setAttribute("visible", visible);
                    if (visible && !this.el.classList.contains("clickable")) {
                        this.el.classList.add("clickable");
                    }
                    if (!visible && this.el.classList.contains("clickable")) {
                        this.el.classList.remove("clickable");
                    }
                } else {
                    const visible = true;
                    this.el.setAttribute("visible", visible);
                    if (visible && !this.el.classList.contains("clickable")) {
                        this.el.classList.add("clickable");
                    }
                }
            },
        });

        AFRAME.registerComponent("cannonball-hit-ready", {
            schema: {
                damage: {
                    type: 'number',
                    default: 10,
                },
            },
        });

        AFRAME.registerComponent("cannonball-collider", {
            schema: {},
            init: function () {
                this.innerCollision = this.collision.bind(this);
                this.cannonballHits = new Map();
            },
            tick: function (t, dt) {
                const shipPosition = this.el.object3D.getWorldPosition(new THREE.Vector3());
                const cannonballs = Array.from(document.querySelectorAll("[cannonball-hit-ready]"));
                cannonballs.filter(x => {
                    return x.components['npc-faction'].data !== this.el.components['npc-faction'].data;
                }).forEach((cannonball) => {
                    const cannonballPosition = cannonball.object3D.getWorldPosition(new THREE.Vector3());
                    const distance = shipPosition.distanceTo(cannonballPosition);
                    if (distance < 1.5 && !this.cannonballHits.has(cannonball)) {
                        this.cannonballHits.set(cannonball, distance);
                    }
                    if (this.cannonballHits.has(cannonball)) {
                        const oldDistance = this.cannonballHits.get(cannonball);
                        if (oldDistance >= distance) {
                            // entering closer to sphere
                            this.cannonballHits.set(cannonball, distance);
                        } else {
                            // leaving sphere, now hit
                            this.innerCollision(cannonball);
                            this.cannonballHits.delete(cannonball);
                            cannonball.removeAttribute("cannonball-hit-ready");
                            cannonball.removeAttribute("cannonball-collider-ground");
                            cannonball.removeAttribute("cannonball-collider-water");
                        }
                    }
                });
            },
            collision: function (el) {
                this.el.emit("hit", el.components['cannonball-hit-ready'].data.damage);
                addCannonballHit(el);
            },
        });

        AFRAME.registerComponent("cannonball-collider-ground", {
            init: function () {
                this.eventHandler = (e) => {
                    if (e.body.el.components["go-on-land"]) {
                        addCannonballThump(this.el);
                        this.el.removeAttribute("cannonball-collider-water");
                    }
                };
                this.el.body.addEventListener("collide", this.eventHandler);
            },
            remove: function () {
                this.el?.body?.removeEventListener("collide", this.eventHandler);
            }
        });

        AFRAME.registerComponent("cannonball-collider-water", {
            init: function () {
                this.emitSound = false;
                this.startTime = +new Date();
            },
            tick: function (t, dt) {
                const time = +new Date();
                if (time < this.startTime + 500) {
                    return;
                }
                if (this.emitSound) {
                    return;
                }

                const center = new THREE.Vector3(0, 0, 0);
                const worldPosition = this.el.object3D.getWorldPosition(new THREE.Vector3());
                if (center.distanceTo(worldPosition) < PLANET_SIZE - 0.2) {
                    addCannonballSplash(this.el);
                    this.emitSound = true;
                }
            }
        });

        AFRAME.registerComponent('coin-purse', {
            schema: {},
            init: function () {
                this.activeUnit = 'ship-1';
                this.goldCoins = 30;
                this.shipCount = 0;
                this.raiderCount = 0;
                this.raiderAmount = new Map([
                    ['raider-1', 10],
                    ['raider-2', 0],
                    ['raider-3', 0],
                ]);
                this.updateUi();
            },
            updateUi: function () {
                const goldAmount = document.querySelector("#gold-amount");
                const shipAmount = document.querySelector("#ship-amount");
                const raiderAmount = document.querySelector("#raider-amount");
                goldAmount.innerText = this.goldCoins;
                shipAmount.innerText = this.shipCount;
                raiderAmount.innerText = this.raiderCount;
            },
            addGoldCoins: function (goldCoins) {
                this.goldCoins += goldCoins;
                this.updateUi();
            },
            addShip: function () {
                const ships = Array.from(scene.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`));
                const existingShips = ships.length;
                if (this.goldCoins >= 30 && this.shipCount + existingShips < 5) {
                    this.shipCount += 1;
                    this.goldCoins -= 30;
                    this.updateUi();
                }
            },
            removeShip: function () {
                if (this.shipCount > 0) {
                    this.shipCount -= 1;
                    this.goldCoins += 30;
                    this.updateUi();
                }
            },
            getRaiderAmount: function () {
                return this.raiderAmount.get(unitMap.get(this.activeUnit));
            },
            setRaiderAmount: function (amount) {
                this.raiderAmount.set(unitMap.get(this.activeUnit), amount);
            },
            addRaider: function () {
                if (this.goldCoins >= 30 && this.raiderCount + this.getRaiderAmount() < 50) {
                    this.raiderCount += 10;
                    this.goldCoins -= 30;
                    this.updateUi();
                }
            },
            removeRaider: function () {
                if (this.raiderCount > 0) {
                    this.raiderCount -= 10;
                    this.goldCoins += 30;
                    this.updateUi();
                }
            },
            setUnit: function(u) {
                this.activeUnit = u;
            },
            getUnit: function () {
                const postfix = this.activeUnit.startsWith("ship") ? ":first-of-type" : "-wizard";
                return this.activeUnit + postfix;
            },
            buyShips: function () {
                const numShips = this.shipCount;
                this.shipCount = 0;
                const numRaiders = this.raiderCount;
                this.raiderCount = 0;
                this.updateUi();

                const ships = Array.from(document.querySelectorAll(this.activeUnit));
                const point = ships.reduce((acc, x) => acc.add(x.object3D.position), new THREE.Vector3());
                if (point.length() === 0) {
                    point.copy(window.shipSpawnPoint);
                } else {
                    point.divideScalar(ships.length);
                }

                for (let i = 0; i < numShips; i++) {
                    addShip(JSON.stringify({data: window.shipModelStr, point: [point.x, point.y, point.z]}));
                }

                const initialRaiderAmount = this.getRaiderAmount();
                this.setRaiderAmount(initialRaiderAmount + numRaiders);
            }
        });

        function openStoreMenu() {
            const menu1 = document.querySelector("#over-world-menu");
            const menu2 = document.querySelector("#store-menu");
            menu1.style.visibility = "collapse";
            menu1.style.display = "none";
            menu2.style.visibility = "visible";
            menu2.style.display = "inline-block";
        }

        function closeStoreMenu() {
            const menu1 = document.querySelector("#over-world-menu");
            const menu2 = document.querySelector("#store-menu");
            menu1.style.visibility = "visible";
            menu1.style.display = "inline-block";
            menu2.style.visibility = "collapse";
            menu2.style.display = "none";
        }

        function decrementShipAmount() {
            const scene = document.querySelector("a-scene");
            scene.components['coin-purse'].removeShip();
        }

        function incrementShipAmount() {
            const scene = document.querySelector("a-scene");
            scene.components['coin-purse'].addShip();
        }

        function decrementRaiderAmount() {
            const scene = document.querySelector("a-scene");
            scene.components['coin-purse'].removeRaider();
        }

        function incrementRaiderAmount() {
            const scene = document.querySelector("a-scene");
            scene.components['coin-purse'].addRaider();
        }

        function handleCheckbox(t) {
            const scene = document.querySelector("a-scene");
            scene.components['coin-purse'].setUnit(t.value);

            setTimeout(() => {
                const scene = document.querySelector("a-scene");
                const cameraEl = document.querySelector("#camera-rig");
                const ships = Array.from(scene.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`));
                const existingShips = ships.length;
                if (existingShips) {
                    cameraEl.setAttribute("look-at-box", `.${scene.components['coin-purse'].getUnit()}`);
                }
            }, 0);
        }

        function buyShips() {
            const scene = document.querySelector("a-scene");
            scene.components['coin-purse'].buyShips();
        }

        AFRAME.registerSystem('npc-finder', {
            schema: {},
            init: function () {
                this.islandNpcList = new Map();
                this.npcs = [];
                this.findNpc = this.findNpc.bind(this);
            },
            registerMe: function (el) {
                const pos = el.object3D.position;
                if (pos.length() === 0) {
                    setTimeout(this.registerMe.bind(this, el), 100);
                    return;
                }

                if (this.el.sceneEl.systems['globe-nav'].navMesh) {
                    const group = this.el.sceneEl.systems['globe-nav'].getGroup(pos);
                    if (this.islandNpcList.has(group)) {
                        this.islandNpcList.get(group).push(el);
                    } else {
                        this.islandNpcList.set(group, [el]);
                    }
                    this.npcs.push(el);
                } else {
                    setTimeout(this.registerMe.bind(this, el), 100);
                }
            },
            unregisterMe: function (el) {
                const group = this.el.sceneEl.systems['globe-nav'].getGroup(el.object3D.position);
                if (this.islandNpcList.has(group)) {
                    const arr = this.islandNpcList.get(group);
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
                {
                    const arr = this.npcs;
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
            },
            findNpc: function (checkingNpc) {
                const factionName = checkingNpc.components['npc-faction'].data;
                const position = new THREE.Vector3().copy(checkingNpc.object3D.position);
                const radius = 20;
                const group = this.el.sceneEl.systems['globe-nav'].getGroup(position);
                if (this.islandNpcList.has(group)) {
                    const list = this.islandNpcList.get(group);
                    const els = list.filter(x => {
                        const pos = x.object3D.position;
                        const dist = position.distanceTo(pos);
                        return dist <= radius;
                    });
                    const filtered = els.filter(x => x && x.components['npc-faction'].data !== factionName);
                    return filtered.sort((a, b) => {
                        const distA = new THREE.Vector3().copy(a.object3D.position).distanceTo(position);
                        const distB = new THREE.Vector3().copy(b.object3D.position).distanceTo(position);
                        return distA - distB;
                    });
                }
                return [];
            },
        });

        AFRAME.registerComponent('npc-finder', {
            schema: {
                active: {type: 'boolean', default: false},
            },
            init: function () {
                this.system = this.el.sceneEl.systems['npc-finder'];
                this.system.registerMe(this.el);
                this.tickCounter = 0;
                this.findTickCount = 2;
                this.innerHandleNavigationGroupChange = this.navigationGroupChange.bind(this);
                this.innerHandleNavigationGroupChanged = this.navigationGroupChanged.bind(this);
                this.el.addEventListener("navigation-group-change", this.innerHandleNavigationGroupChange);
                this.el.addEventListener("navigation-group-changed", this.innerHandleNavigationGroupChanged);
            },
            tick: function (t, dt) {
                if (!this.data.active) {
                    return;
                }

                if (this.tickCounter < this.findTickCount) {
                    this.tickCounter += dt / 1000;
                    return;
                }
                this.tickCounter = 0;

                const els = this.system.findNpc(this.el);
                this.el.emit('npc-attack', els);
            },
            remove: function () {
                this.system.unregisterMe(this.el);
                this.tickCounter = null;
                this.findTickCount = null;
                this.el.removeEventListener("navigation-group-change", this.innerHandleNavigationGroupChange);
                this.el.removeEventListener("navigation-group-changed", this.innerHandleNavigationGroupChanged);
            },
            navigationGroupChange: function () {
                this.system.unregisterMe(this.el);
            },
            navigationGroupChanged: function () {
                this.system.registerMe(this.el);
            },
        });

        AFRAME.registerSystem('pirate-finder', {
            schema: {},
            init: function () {
                this.seaNpcList = new Map();
                this.npcs = [];
                this.findNpc = this.findNpc.bind(this);
            },
            registerMe: function (el) {
                const pos = el.object3D.position;
                if (pos.length() === 0) {
                    setTimeout(this.registerMe.bind(this, el), 1000);
                    return;
                }

                if (this.el.sceneEl.systems['globe-ocean-nav'].navMesh) {
                    const group = this.el.sceneEl.systems['globe-ocean-nav'].getGroup(pos);
                    if (this.seaNpcList.has(group)) {
                        this.seaNpcList.get(group).push(el);
                    } else {
                        this.seaNpcList.set(group, [el]);
                    }
                    this.npcs.push(el);
                } else {
                    setTimeout(this.registerMe.bind(this, el), 100);
                }
            },
            unregisterMe: function (el) {
                const group = this.el.sceneEl.systems['globe-ocean-nav'].getGroup(el.object3D.position);
                if (this.seaNpcList.has(group)) {
                    const arr = this.seaNpcList.get(group);
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
                {
                    const arr = this.npcs;
                    const idx = arr.indexOf(el);
                    if (idx >= 0) {
                        arr.splice(idx, 1);
                    }
                }
            },
            findNpc: function (checkingNpc) {
                const factionName = checkingNpc.components['npc-faction'].data;
                const position = new THREE.Vector3().copy(checkingNpc.object3D.position);
                const radius = 20;
                const group = this.el.sceneEl.systems['globe-ocean-nav'].getGroup(position);
                if (this.seaNpcList.has(group)) {
                    const list = this.seaNpcList.get(group);
                    const els = list.filter(x => {
                        const pos = x.object3D.position;
                        const dist = position.distanceTo(pos);
                        return dist <= radius;
                    });
                    const filtered = els.filter(x => x && x.components['npc-faction'].data !== factionName);
                    return filtered.sort((a, b) => {
                        const distA = new THREE.Vector3().copy(a.object3D.position).distanceTo(position);
                        const distB = new THREE.Vector3().copy(b.object3D.position).distanceTo(position);
                        return distA - distB;
                    })
                }
                return [];
            },
        });

        AFRAME.registerComponent('pirate-finder', {
            schema: {
                active: {type: 'boolean', default: false},
            },
            init: function () {
                this.system = this.el.sceneEl.systems['pirate-finder'];
                this.system.registerMe(this.el);
                this.tickCounter = Math.random() * 10;
                this.tickFindCount = 10;
                this.innerHandleNavigationGroupChange = this.navigationGroupChange.bind(this);
                this.innerHandleNavigationGroupChanged = this.navigationGroupChanged.bind(this);
            },
            tick: function (t, dt) {
                if (!this.data.active) {
                    return;
                }

                if (this.tickCounter < this.tickFindCount) {
                    this.tickCounter += dt / 1000;
                    return;
                }
                this.tickCounter = 0;

                const els = this.system.findNpc(this.el);
                this.el.emit('pirate-attack', els);
            },
            remove: function () {
                this.system.unregisterMe(this.el);
                this.tickCounter = null;
                this.findTickCount = null;
                this.el.removeEventListener("navigation-group-change", this.innerHandleNavigationGroupChange);
                this.el.removeEventListener("navigation-group-changed", this.innerHandleNavigationGroupChanged);
            },
            navigationGroupChange: function () {
                this.system.unregisterMe(this.el);
            },
            navigationGroupChanged: function () {
                this.system.registerMe(this.el);
            },
        });

        AFRAME.registerComponent('play-all-animations', {
            schema: {},
            init: function () {
                this.el.setAttribute("animation-mixer", {timeScale: 1});
            },
        });

        AFRAME.registerComponent('ui-clicked', {
            schema: {
                rayOrigin: {
                    default: 'mouse',
                    oneOf: ['mouse', 'entity', 'xrselect'],
                },
                debug: {
                    type: 'boolean',
                    default: false,
                },
            },
            init: function () {
                this.eventDetail = {};
                this.intersectedEventDetail = {cursorEl: this.el};

                this.onMouseMove = this.onMouseMove.bind(this);
                this.onCursorDown = this.onCursorDown.bind(this);

                this.intersections = [];
                this.raycaster = new THREE.Raycaster(this.el.sceneEl.camera);

                // Debounce.
                this.updateCanvasBounds = debounce(() => {
                    this.canvasBounds = this.el.sceneEl.canvas.getBoundingClientRect();
                }, 500);

                this.el.addEventListener("model-loaded", buildBoundsTree);
            },
            remove: function () {
                this.el.removeEventListener("model-loaded", buildBoundsTree);
            },
            play: function () {
                this.el.sceneEl.addEventListener('rendererresize', this.updateCanvasBounds);
                window.addEventListener('resize', this.updateCanvasBounds);
                window.addEventListener('scroll', this.updateCanvasBounds);

                this.el.sceneEl.canvas.addEventListener('touchstart', this.onMouseMove);
                this.el.sceneEl.canvas.addEventListener('touchmove', this.onMouseMove);
                this.el.sceneEl.canvas.addEventListener('mousemove', this.onMouseMove);
                this.el.sceneEl.canvas.addEventListener('click', this.onCursorDown);
            },
            pause: function () {
                this.el.sceneEl.removeEventListener('rendererresize', this.updateCanvasBounds);
                window.removeEventListener('resize', this.updateCanvasBounds);
                window.removeEventListener('scroll', this.updateCanvasBounds);

                this.el.sceneEl.canvas.removeEventListener('touchstart', this.onMouseMove);
                this.el.sceneEl.canvas.removeEventListener('touchmove', this.onMouseMove);
                this.el.sceneEl.canvas.removeEventListener('mousemove', this.onMouseMove);
                this.el.sceneEl.canvas.removeEventListener('click', this.onCursorDown);
            },
            onMouseMove: (function () {
                var direction = new THREE.Vector3();
                var mouse = new THREE.Vector2();
                var origin = new THREE.Vector3();
                var rayCasterConfig = {origin: origin, direction: direction};

                return function (evt) {
                    var bounds = this.canvasBounds;
                    var camera = this.el.sceneEl.camera;
                    var cameraElParent;
                    var left;
                    var point;
                    var top;

                    var frame;
                    var inputSource;
                    var referenceSpace;
                    var pose;
                    var transform;

                    camera.parent.updateMatrixWorld();

                    // Calculate mouse position based on the canvas element
                    if (evt.type === 'touchmove' || evt.type === 'touchstart') {
                        // Track the first touch for simplicity.
                        point = evt.touches.item(0);
                    } else {
                        point = evt;
                    }

                    if (!bounds) {
                        return;
                    }

                    left = point.clientX - bounds.left;
                    top = point.clientY - bounds.top;
                    mouse.x = (left / bounds.width) * 2 - 1;
                    mouse.y = -(top / bounds.height) * 2 + 1;

                    if (this.data.rayOrigin === 'xrselect' && (evt.type === 'selectstart' || evt.type === 'fakeselectevent')) {
                        frame = evt.frame;
                        inputSource = evt.inputSource;
                        referenceSpace = this.el.sceneEl.renderer.xr.getReferenceSpace();
                        pose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                        if (pose) {
                            transform = pose.transform;
                            direction.set(0, 0, -1);
                            direction.applyQuaternion(transform.orientation);
                            origin.copy(transform.position);

                            // Transform XRPose into world space
                            cameraElParent = camera.el.object3D.parent;
                            cameraElParent.localToWorld(origin);
                            direction.transformDirection(cameraElParent.matrixWorld);
                        }
                    } else if (evt.type === 'fakeselectout') {
                        direction.set(0, 1, 0);
                        origin.set(0, 9999, 0);
                    } else if (camera && camera.isPerspectiveCamera) {
                        origin.setFromMatrixPosition(camera.matrixWorld);
                        direction.set(mouse.x, mouse.y, 0.5).unproject(camera).sub(origin).normalize();
                    } else if (camera && camera.isOrthographicCamera) {
                        origin.set(mouse.x, mouse.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
                        direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
                    } else {
                        console.error('AFRAME.Raycaster: Unsupported camera type: ' + camera.type);
                    }

                    //this.el.setAttribute('raycaster', rayCasterConfig);
                    this.raycaster.ray.origin.copy(rayCasterConfig.origin);
                    this.raycaster.ray.direction.copy(rayCasterConfig.direction);
                    if (evt.type === 'touchmove') { evt.preventDefault(); }
                };
            })(),

            /**
             * Trigger mousedown and keep track of the mousedowned entity.
             */
            onCursorDown: function (evt) {
                if (!this.el.object3D.visible) {
                    return;
                }

                this.isCursorDown = true;
                // Raycast again for touch.
                if (this.data.rayOrigin === 'mouse' && (evt.type === 'touchstart' || evt.type === 'click')) {
                    this.onMouseMove(evt);
                    this.intersections.length = 0;
                    this.raycaster.intersectObject(this.el.object3D, true, this.intersections);
                    this.intersectedEl = this.intersections[0] || null;
                    evt.preventDefault();
                }

                if (this.data.rayOrigin === 'xrselect' && evt.type === 'selectstart') {
                    this.activeXRInput = evt.inputSource;
                    this.onMouseMove(evt);
                    this.raycaster.checkIntersections();

                    // if something was tapped on don't do ar-hit-test things
                    if (
                        this.raycaster.intersectedEls.length &&
                        this.el.sceneEl.components['ar-hit-test'] !== undefined &&
                        this.el.sceneEl.getAttribute('ar-hit-test').enabled
                    ) {
                        // Cancel the ar-hit-test behaviours and disable the ar-hit-test
                        this.el.sceneEl.setAttribute('ar-hit-test', 'enabled', false);
                        this.reenableARHitTest = true;
                    }
                }

                if (this.data.debug) {
                    console.log("INTERSECTED", !!this.intersectedEl);
                }

                this.cursorDownEl = this.intersectedEl;
                this.twoWayEmit('click', evt);
            },

            /**
             * Helper to emit on both the cursor and the intersected entity (if exists).
             */
            twoWayEmit: function (evtName, originalEvent) {
                var el = this.el;
                var intersectedEl = this.intersectedEl;
                var intersection;

                function addOriginalEvent (detail, evt) {
                    if (originalEvent instanceof MouseEvent) {
                        detail.mouseEvent = originalEvent;
                    } else if (typeof TouchEvent !== 'undefined' &&
                        originalEvent instanceof TouchEvent) {
                        detail.touchEvent = originalEvent;
                    }
                }

                intersection = this.intersections[0] || null;
                this.eventDetail.intersectedEl = intersectedEl;
                this.eventDetail.intersection = intersection;
                addOriginalEvent(this.eventDetail, originalEvent);
                // el.emit(evtName, this.eventDetail);

                if (!intersectedEl) { return; }

                this.intersectedEventDetail.intersection = intersection;
                addOriginalEvent(this.intersectedEventDetail, originalEvent);
                ClickManager.addToQueue(() => {
                        intersectedEl.object.el.emit(evtName, this.intersectedEventDetail);
                    }, "ui-clicked"
                );
            }
        });

        const clickQueue = [];
        const ClickManager = {
            addToQueue: function (fn, type) {
                clickQueue.push({
                    fn,
                    type,
                    tick: 3,
                });
            },
            iterateQueue: function () {
                const uiClick = clickQueue.find(x => x.type === "ui-clicked");
                const readyClick = clickQueue.find(x => x.tick <= 0);
                const readyClickIndex = clickQueue.findIndex(x => x.tick <= 0);

                if (uiClick) {
                    uiClick.fn();
                    clickQueue.length = 0;
                    return;
                }
                if (readyClick) {
                    readyClick.fn();
                    clickQueue.splice(readyClickIndex, 1);
                    return;
                }

                clickQueue.forEach(x => x.tick -= 1);
            },
        };

        AFRAME.registerComponent("click-manager", {
            schema: {},
            tick: function(t, dt) {
                ClickManager.iterateQueue();
            },
        });

        AFRAME.registerComponent("health-bar", {
            schema: {},
            tick: function(t, dt) {
                const scene = document.querySelector("a-scene");
                const shipEls = [
                    ...Array.from(document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}-wizard`)),
                    ...Array.from(document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}`)),
                ];
                const ship = shipEls.slice(0, 1)[0];

                const meshes = [];
                this.el.object3D.traverse((node) => {
                    if (node.isMesh) {
                        meshes.push(node);
                    }
                });
                const mesh = meshes[0];

                if (mesh) {
                    if (ship) {
                        const healthComponent = ship.components['ship-health'] || ship.components['health'];
                        const maxHealth = healthComponent.maxHealth;
                        const health = healthComponent.data.health;
                        const ratio = health / maxHealth;
                        mesh.morphTargetInfluences[0] = ratio;
                    } else {
                        mesh.morphTargetInfluences[0] = 0;
                    }
                }
            },
        });

        AFRAME.registerComponent("mana-bar", {
            schema: {},
            tick: function(t, dt) {
                const scene = document.querySelector("a-scene");
                const shipEls = [
                    ...Array.from(document.querySelectorAll(`.${scene.components['coin-purse'].activeUnit}-wizard`)),
                ];
                const ship = shipEls.slice(0, 1)[0];

                const meshes = [];
                this.el.object3D.traverse((node) => {
                    if (node.isMesh) {
                        meshes.push(node);
                    }
                });
                const mesh = meshes[0];

                if (mesh) {
                    if (ship) {
                        const healthComponent = ship.components['wizard-mana'];
                        const endTime = healthComponent.endTime;
                        const startTime = healthComponent.startTime;
                        const time = +new Date();
                        const ratio = Math.min((time - startTime) / (endTime - startTime), 1);
                        mesh.morphTargetInfluences[0] = ratio;
                    } else {
                        mesh.morphTargetInfluences[0] = 0;
                    }
                }
            },
        });
    </script>
    <style>
        a-scene {
            width: 100%;
            aspect-ratio: 1;
        }
        #dom-overlay {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: none;
        }
        #my-interface {
            pointer-events: visible;
        }
        .host-span {
            border-radius: 8px;
            pointer-events: none;
            display: inline-block;
        }
        body {
            margin: 0;
        }
    </style>
</head>
<body>
    <a-scene click-manager onclick="isDemoMode === false && playMusic === true ? window.musicPlayer.start() : undefined" draw-ship-indicator draw-npc-indicator coin-purse respawn physics="driver: local; gravity: 0 0 0;" globe-nav="debug: true;" globe-ocean-nav embedded fog shadow="enabled: true" id="scene" webxr="referenceSpaceType: local; requiredFeatures: local;" embedded inspector="url: https://cdn.jsdelivr.net/gh/aframevr/aframe-inspector@master/dist/aframe-inspector.min.js">
        <a-assets>
            <template id="avatar-template">
                <a-entity class="avatar" networked-audio-source>
                </a-entity>
            </template>
            <template id="cannonball-fire-template">
                <a-entity class="cannonball-fire"
                          sound="src: #fire; poolSize: 1; volume: 1; autoplay: true;"
                          damage-particles="particleType: smoke"
                ></a-entity>
            </template>
            <template id="cannonball-hit-template">
                <a-entity class="cannonball-hit"
                          sound="src: #hit; poolSize: 1; volume: 1; autoplay: true;"
                          damage-particles="particleType: smoke"
                ></a-entity>
            </template>
            <template id="cannonball-thump-template">
                <a-entity class="cannonball-thump"
                          sound="src: #thump; poolSize: 1; volume: 1; autoplay: true;"
                          damage-particles="particleType: dirt"
                ></a-entity>
            </template>
            <template id="cannonball-splash-template">
                <a-entity class="cannonball-splash"
                          sound="src: #splash; poolSize: 1; volume: 1; autoplay: true;"
                          damage-particles="particleType: water"
                ></a-entity>
            </template>
            <template id="wilhelm-scream-template">
                <a-entity class="wilhelm-scream"
                          sound="src: #scream; poolSize: 1; volume: 1; autoplay: true;"
                ></a-entity>
            </template>
            <template id="arr-template">
                <a-entity class="arr"
                          sound="src: #arr; poolSize: 1; volume: 1; autoplay: true;"
                ></a-entity>
            </template>
            <template id="repair-template">
                <a-entity class="repair"
                          sound="src: #repair; poolSize: 1; volume: 1; autoplay: true;"
                          damage-particles
                ></a-entity>
            </template>
            <template id="heal-template">
                <a-entity class="heal"
                          sound="src: #heal; poolSize: 1; volume: 1; autoplay: true;"
                          damage-particles
                ></a-entity>
            </template>
            <audio id="fire" src="/sounds/FireSFX.m4a" preload="auto"></audio>
            <audio id="hit" src="/sounds/WoodHitSFX.m4a" preload="auto"></audio>
            <audio id="scream" src="/sounds/WilhelmScreamSFX.mp3" preload="auto"></audio>
            <audio id="thump" src="/sounds/ThumpSFX.mp3" preload="auto"></audio>
            <audio id="splash" src="/sounds/SplashSFX.mp3" preload="auto"></audio>
            <audio id="arr" src="/sounds/PirateArrSFX.mp3" preload="auto"></audio>
            <audio id="repair" src="/sounds/RepairSFX.wav" preload="auto"></audio>
            <audio id="heal" src="/sounds/HealSFX.wav" preload="auto"></audio>
            <img id="fog" src="/assets/fog.png" alt="fog"/>
            <img id="blob" src="/assets/blob.png" alt="blob"/>
        </a-assets>
        <a-sphere color="black" radius="0.01" id="cursor" port-show></a-sphere>
        <a-entity light="type: ambient; color: #CCC"></a-entity>
        <a-entity light="type: directional; color: #EEE; intensity: 0.8; castShadow: true; shadowCameraBottom: -150; shadowCameraTop: 150; shadowCameraLeft: -150; shadowCameraRight: 150; shadowCameraNear: -150; shadowCameraFar: 150; shadowMapWidth: 1024; shadowMapHeight: 1024;" position="0 1 0" handle-shadow-parameter></a-entity>
        <a-entity light="type: directional; color: #EEE; intensity: 0.15" position="0 -1 0"></a-entity>
        <a-entity id="demo-node" position="0 105 5">
            <a-entity id="demo-node-position" position="0 0 -5"></a-entity>
        </a-entity>
        <a-entity id="terrain" terrain-folder-optimization></a-entity>
        <a-entity id="grass-mesh" gltf-model="/meshes/Model_Redo/Grass/Grass.glb" instanced-mesh="capacity: 20480; positioning: world;"></a-entity>
        <a-entity id="tree-mesh" gltf-model="/meshes/Model_Redo/stylished_fir/Tree.glb" instanced-mesh="capacity: 2048; positioning: world;"></a-entity>
        <a-entity id="camera-rig" position="0 105 5" networked="template: #avatar-template; attachTemplateToLocal: false;">
            <a-entity camera globe-look-controls="mouseEnabled: false; touchEnabled: false;" position="0 1.6 0" cursor-updater cursor="rayOrigin: mouse" raycaster="far: 50; interval: 100; objects: .clickable">
                <a-entity id="port-menu" align-with-projection="offset: 0.25 0.2 -0.5; rotation: 0 0 0; portShow: true" port-show html="cursor:#cursor;html:#my-interface" class="clickable"></a-entity>
                <a-entity laser-controls="hand: left;" raycaster="far: 50; interval: 100; objects: .clickable"></a-entity>
                <a-entity laser-controls="hand: right;" raycaster="far: 50; interval: 100; objects: .clickable"></a-entity>
                <a-entity id="health-bar" align-with-projection="offset: 0 -0.25 -0.5; rotation: 0 -90 0; scale: 0.03 0.03 0.03;" gltf-model="/meshes/ui/healthbar/HealthBar.glb" health-bar></a-entity>
                <a-entity id="health-bar" align-with-projection="offset: 0 -0.25 -0.5; rotation: 0 -90 0; scale: 0.03 0.03 0.03; wizardShow: true;" gltf-model="/meshes/ui/healthbar/HealthBar.glb" health-bar></a-entity>
                <a-entity id="mana-bar" align-with-projection="offset: 0 -0.3 -0.5; rotation: 0 -90 0; scale: 0.03 0.03 0.03; wizardShow: true;" gltf-model="/meshes/ui/healthbar/ManaBar.glb" mana-bar></a-entity>
                <a-entity id="left-cannon-fire" align-with-projection="offset: -0.25 -0.2 -0.5; rotation: 0 90 0; scale: 0.03 0.03 0.03;" gltf-model="/meshes/Model_Redo/Cannon/Cannon.glb" select-cannon-side="selector: left-cannon" ui-clicked></a-entity>
                <a-entity id="right-cannon-fire" align-with-projection="offset: 0.25 -0.2 -0.5; rotation: 0 -90 0; scale: 0.03 0.03 0.03;" gltf-model="/meshes/Model_Redo/Cannon/Cannon.glb" select-cannon-side="selector: right-cannon" ui-clicked></a-entity>
                <a-entity id="none-cannon-fire" align-with-projection="offset: 0 -0.2 -0.5; rotation: 0 0 0; scale: 0.015 0.015 0.015;" gltf-model="/meshes/Model_Redo/Ship Wheel/ShipWheel.glb" select-cannon-side="selector: none-cannon" ui-clicked></a-entity>
                <a-entity id="area-attack-fire" align-with-projection="offset: 0.2 -0.2 -0.5; rotation: 90 0 0; scale: 0.015 0.015 0.015; wizardShow: true;" gltf-model="/meshes/EpicStore/Fireball/source/Fireball.glb" select-cannon-side="selector: area-attack" play-all-animations ui-clicked></a-entity>
                <a-entity id="forward-attack-fire" align-with-projection="offset: -0.2 -0.2 -0.5; rotation: 0 90 0; scale: 0.015 0.015 0.015; wizardShow: true;" gltf-model="/meshes/EpicStore/Fireball/source/Fireball.glb" select-cannon-side="selector: forward-attack" play-all-animations ui-clicked></a-entity>
                <a-entity id="hammer-build" align-with-projection="offset: -0.05 -0.2 -0.5; rotation: 0 -90 0; scale: 0.03 0.03 0.03; wizardShow: true; menuShow: true;" gltf-model="/meshes/ui/build/Hammer.glb" select-cannon-side="selector: hammer-build" ui-clicked></a-entity>
                <a-entity id="ok-build" align-with-projection="offset: -0.03 -0.2 -0.5; rotation: 0 -90 0; scale: 0.03 0.03 0.03; wizardShow: true; buildShow: true;" gltf-model="/meshes/ui/build/Ok.glb" select-cannon-side="selector: ok-build" ui-clicked></a-entity>
                <a-entity id="cancel-build" align-with-projection="offset: 0.03 -0.2 -0.5; rotation: 0 -90 0; scale: 0.03 0.03 0.03; wizardShow: true; buildShow: true;" gltf-model="/meshes/ui/build/Cancel.glb" select-cannon-side="selector: cancel-build" ui-clicked></a-entity>
                <a-entity id="wizard-tower-build" align-with-projection="offset: 0.06 -0.4 -1; rotation: 0 -90 0; scale: 0.015 0.015 0.015; wizardShow: true; hammerShow: true;" gltf-model="/meshes/WizardTower.glb" select-cannon-side="selector: wizard-tower-build" ui-clicked></a-entity>
                <a-entity id="build-menu-state"></a-entity>
            </a-entity>
        </a-entity>
    </a-scene>
    <div id="dom-overlay">
        <section id="my-interface" style="display: inline-block; background: lavenderblush; position: absolute; left: -9999px; color: #333; border-radius: 1em; padding: 1em; margin: 0; accent-color: hotpink;">
            <div class="actions">
                <button id="mic-btn" type="button" class="button">Mute Mic</button>
                <span id="host-span" class="host-span">CLIENT</span>
            </div>
            <div class="actions" id="over-world-menu" style="visibility: collapse; display: none">
                <button onclick="openStoreMenu()">Shop</button>
            </div>
            <div class="actions" id="store-menu">
                <button onclick="closeStoreMenu()" style="visibility: collapse; display: none">Exit</button>
                <fieldset>
                    <legend>Gold Amount</legend>
                    <label style="width: 50px; display: inline-block">Gold</label>
                    <label style="width: 50px; display: inline-block; text-align: right; padding: 8px" id="gold-amount">0</label>
                </fieldset>
                <fieldset>
                    <legend>Purchases</legend>
                    <label style="width: 50px; display: inline-block">Ships</label>
                    <button onclick="decrementShipAmount()">-</button>
                    <label style="width: 50px; display: inline-block; text-align: right; padding: 8px" id="ship-amount">0</label>
                    <button onclick="incrementShipAmount()">+</button>
                    <br/>
                    <label style="width: 50px; display: inline-block">Raiders</label>
                    <button onclick="decrementRaiderAmount()">-</button>
                    <label style="width: 50px; display: inline-block; text-align: right; padding: 8px" id="raider-amount">0</label>
                    <button onclick="incrementRaiderAmount()">+</button>
                    <br/>
                    <button onclick="buyShips()">Buy</button>
                </fieldset>
                <fieldset>
                    <legend>Units</legend>
                    <input onclick="handleCheckbox(this)" id="unit-selection-ship-1" type="radio" name="unit-selection" value="ship-1" checked><label for="unit-selection-ship-1">Ship 1</label>
                    <input onclick="handleCheckbox(this)" id="unit-selection-raider-1" type="radio" name="unit-selection" value="raider-1"><label for="unit-selection-ship-1">Raider 1</label>
                    <br/>
                    <input onclick="handleCheckbox(this)" id="unit-selection-ship-2" type="radio" name="unit-selection" value="ship-2"><label for="unit-selection-ship-2">Ship 2</label>
                    <input onclick="handleCheckbox(this)" id="unit-selection-raider-2" type="radio" name="unit-selection" value="raider-2"><label for="unit-selection-raider-2">Raider 2</label>
                    <br/>
                    <input onclick="handleCheckbox(this)" id="unit-selection-ship-3" type="radio" name="unit-selection" value="ship-3"><label for="unit-selection-ship-3">Ship 3</label>
                    <input onclick="handleCheckbox(this)" id="unit-selection-raider-3" type="radio" name="unit-selection" value="raider-3"><label for="unit-selection-raider-3">Raider 3</label>
                </fieldset>
            </div>
        </section>
    </div>
</body>
</html>
